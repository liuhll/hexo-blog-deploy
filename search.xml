<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[开发者工具推荐]]></title>
    <url>%2Fhexo-blog-deploy%2F2019%2F07%2F25%2F2019-07-dev-tools-recommend%2F</url>
    <content type="text"><![CDATA[版本管理工具git 开源的分布式版本控制系统，可以有效、高速地处理从很小到非常大的项目版本管理，创建分支和合并分支异常简单、方便 https://git-scm.com/ https://www.liaoxuefeng.com/wiki/896043488029600 非常不建议使用svn作为版本管理工具,无论是版本管理、分支管理、代码检视都无法做到，团队中如果有人代码不规范，后期代码就会变得越来越差，产品质量根本得不到保证 gitlab GitLab 是一个用于仓库管理系统的开源项目，使用Git作为代码管理工具，并在此基础上搭建起来的web服务 https://about.gitlab.com/pricing/#gitlab-com 持续集成工具jenkins 基于java开发的一个持续集成工具,提供超过1000个插件来支持构建、部署、自动化， 满足任何项目的需要。 https://jenkins.io/zh/ gitlab-runner gitlab提供的持续集成工具，能够与gitlab整合在一起，方便的实现持续集成与构建 https://docs.gitlab.com/ee/ci/quick_start/README.html 文档管理(API文档、在线文档)docfx 微软官方提供的在线文档工具 https://dotnet.github.io/docfx/ hexo Hexo 是一个快速、简洁且高效的博客框架。Hexo 使用 Markdown（或其他渲染引擎）解析文章，在几秒内，即可利用靓丽的主题生成静态网页。 如果需要团建的话可以考虑通过该工具维护内部的学习文档 swagger Swagger 可以生成一个具有互动性的API控制台,开发者可以用来快速学习和尝试API https://swagger.io/ easy-mock Easy Mock 是一个可视化，并且能快速生成 模拟数据 的持久化服务 https://www.easy-mock.com/ gitbook https://www.gitbook.com/ 容器与容器管理docker 一个开源的服务引擎管理工具,可以说改变软件行业开发与交付的模式(Build Once,Run AnyWhere)不是吹的。 https://www.docker.com/ k8s Google开源的容器集群管理系统 https://www.kubernetes.org.cn/k8s https://kubernetes.io/docs/concepts/overview/what-is-kubernetes/ docker-swarm docker 官方提供的容器集群管理平台 https://docs.docker.com/swarm/ rancher Rancher是一个开源的企业级容器管理平台，1.6.x支持docker-swarm,2.0+支持k8s https://rancher.com/docs/rancher/v1.6/zh/ https://www.cnrancher.com/docs/rancher/v2.x/cn/overview/ 什么时候使用k8s什么时候使用docker-swarm?我个人推荐优先使用k8s作为容器管理平台。但是目标客户不愿意投入的情况下，并且服务节点相对较少(比如只有不到几十个)的情况下，推荐使用docker-swarm作为容器管理平台,大型的集群服务管理推荐使用k8s 仓库管理nuget.server 提供nuget包管理工具 https://github.com/NuGet/NuGet.Server helm k8s软件包(源)管理工具 https://helm.sh/ harbor docker私有镜像仓库 https://goharbor.io/ nexus 除了支持上面所述的各种软件源(包)管理之外,还支持yum、python、npm等包管理(推荐) https://www.sonatype.com/nexus-repository-sonatype 微服务框架surging dotnetcore社区的一个微服务框架,主要维护者范亮 https://github.com/dotnetcore/surging https://github.com/liuhll/Surging.Sample spring cloud https://spring.io/projects/spring-cloudeShopOnContainers 微软官方案列 https://github.com/dotnet-architecture/eShopOnContainers https://docs.microsoft.com/zh-cn/dotnet/standard/microservices-architecture/ microdot .net framework平台下的一个微服务框架,可以与Orleans(奥尔良)结合使用 https://github.com/gigya/microdot enode cqrs + ddd实现的soa框架 https://github.com/tangxuehua/enode 推荐使用的工具 版本管理工具(git+gitlab) 持续集成工具(gitlab-runnber|Jenkins) 文档工具(在线文档docfx+api文档swagger+模拟数据easymock) 仓库管理工具(nexus) 微服务框架(推荐surging|spring-cloud) 服务器(centos|ubuntu) 容器和容器管理工具(docker|rancher2.0+|k8s)]]></content>
      <tags>
        <tag>微服务</tag>
        <tag>dev-tools</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Surging实践经验]]></title>
    <url>%2Fhexo-blog-deploy%2F2019%2F07%2F22%2F2019-07-surging-practical-experi%2F</url>
    <content type="text"><![CDATA[背景在去年9月份的时候,我入职一家做航空软件产品的公司。当时公司部门领导决定构建一个技术平台(或称为技术中台),通过该技术平台进而孵化各个业务系统。说白了就是需要通过一个分布式框架或是微服务框架提高应用系统的性能和并发处理能力、业务处理能力。当时现有的系统是在 .net framework平台上搭建的简单的单体应用，并不具备可用性、扩展性、易用性等。我在入职前也学习过一些微服务相关的知识,并通过搜索引擎了解了.net平台下的一些微服务框架和分布式架构。在对比不同技术框架的背景后,我决定使用surging作为公司的技术平台。原因在于: Surging的设计思想和理念更符合微服务的架构思想,通过dotnetty框架实现的RPC通信,内置了服务治理保证通信的可靠性。 通过向服务注册中心(Zookeeper、Consul)注册相关元数据来管理集群的服务命令、路由信息、缓存中间件等数据,服务注册不需要进行额外的处理 Surging内置了负载均衡算法。 Surging支持多种协议的通信方式,并且支持ws服务主机与一般服务(Http、TCP)主机之间直接通过RPC进行通信。 服务之间的调用很方便,作者提供了基于ServiceProxyProvider、和基于ServiceProxyFactory的rpc调用方式,简单易用。 模块化设计,很方便的对模块进行扩展。 支持事件总线,通过消息对象实现的时效件纵向的适配可以实现发布订阅的交互模式。 .net core 跨平台，性能更高。 架构维护由于作者一直在维护surging,而且我们也需要对surging的一些模块进行调整,也需要扩展一些surging的组件包,所以我们在使用surging的过程中是直接获取源代码后,在公司维护一份自己的源码，然后打包成nuget包,并发布到内部的nuget服务，通过内部的nuget对surging组件进行分发。在获取surging源码后,我对surging进行了如下调整： 根据公司要求,对名称空间和包名称进行了调整。 对异常处理进行了重构 将消息返回的数据结果名称重命名为Data,统一了消息返回码。 修改了默认的json序列化器,默认使用camelCame风格 重构了签发token的方法(使用jose-jwt组件) 支持通过RpcContext设置token的payload和获取payload,通过扩展RpcContextSession获取运行时登录用户 扩展了Dapper、Domain、Validation、Schedule(基于Quartz的分布式任务调度)等组件包 swagger文档支持jwt token验证 新增surging打包脚本等等 现在surging的demo案例和内部的开发者文档 如果你在使用surging的过程中,对surging源码较为熟悉,并希望对surging进行一定的调整、扩展自己公司的一些组件的时候,您可以通过社区获取surging的源代码,并在公司的代码库维护自己的分支。但是需要对作者对源码的修改要及时了解和熟悉。nuget服务的搭建可以使用nuget官方提供的nuget.server或是nexus 。对架构的维护可能是一个持续的和长久的过程,你可以通过企业内部的需求和作者对框架的调整对技术框架持续的进行调整和维护。在对surging进行调整维护后,就通过通过打包脚本进行打包发布到内部的nuget服务。 业务框架构建微服务主机由于在构建每个微服务主机的代码和配置文件都是一致的,无法就是对配置文件的一些配置项进行调整，所以可以将构建微服务主机的代码和配置文件抽象出来,统一放置在Shared目录中，再在项目文件中通过import进入即可。如何将公共的脚本、配置文件、属性抽象出来,可以参考:https://github.com/surging-cloud/Surging.Hero/tree/develop/hero/src/Shared 。如何构建主机呢?Surging通过ServiceHostBuilder来构建微服务主机,在构建主机过程中，可以添加一些服务组件或是指定相应的配置文件。构建主机的代码如下:12345678910111213141516171819202122232425262728293031323334353637383940414243444546var host = new ServiceHostBuilder() .RegisterServices(builder =&gt; &#123; builder.AddMicroService(option =&gt; &#123; option.AddServiceRuntime() .AddClientProxy() .AddRelateServiceRuntime() .AddConfigurationWatch() .AddServiceEngine(typeof(SurgingServiceEngine)) ; builder.Register(p =&gt; new CPlatformContainer(ServiceLocator.Current)); &#125;); &#125;) .ConfigureLogging(loggging =&gt; &#123; loggging.AddConfiguration( AppConfig.GetSection("Logging")); &#125;) .UseServer(options =&gt; &#123; &#125;) .UseConsoleLifetime() .Configure(build =&gt; &#123;#if DEBUG build.AddCacheFile("$&#123;cachePath&#125;|/app/configs/cacheSettings.json", optional: false, reloadOnChange: true); build.AddCPlatformFile("$&#123;surgingPath&#125;|/app/configs/surgingSettings.json", optional: false, reloadOnChange: true); build.AddEventBusFile("$&#123;eventBusPath&#125;|/app/configs/eventBusSettings.json", optional: false); build.AddConsulFile("$&#123;consulPath&#125;|/app/configs/consul.json", optional: false, reloadOnChange: true);#else build.AddCacheFile("$&#123;cachePath&#125;|configs/cacheSettings.json", optional: false, reloadOnChange: true); build.AddCPlatformFile("$&#123;surgingPath&#125;|configs/surgingSettings.json", optional: false,reloadOnChange: true); build.AddEventBusFile("configs/eventBusSettings.json", optional: false); build.AddConsulFile("configs/consul.json", optional: false, reloadOnChange: true);#endif &#125;) .UseProxy() .UseStartup&lt;Startup&gt;() .Build(); using (host.Run()) &#123; Console.WriteLine($"服务主机启动成功&#123;DateTime.Now&#125;。"); &#125; 需要注意的是可以通过SurgingServiceEngine来指定surging服务引擎扫描的业务组件的目录。以及也可以通过Startup注入相应的服务或是制定配置文件。 业务框架的分层一般地,我会将每个微服务组件分为如下几层: 1. Host用于构建微服务主机和服务寄宿,一般我会直接引用Application层,托管应用服务本身。 2. IApplication 应用接口层 用于定义应用接口,每个应用接口都应当继承IServiceKey,Surging通过应用接口生成服务条目(ServiceEntry) 使用ServiceBundle特性来标识路由模板。 可以使用ServiceCommand来对Action进行注解,该元数据会被注册到服务注册中心,在RPC通信过程中，通过ServiceCommand注解的元数据实现服务治理。该特性可不需要配置,可以通过SurgingSettings.json统一指定相关的配置,如果配置了ServiceCommand特性,会优先选择特性指定的配置值。 可以通过Service特性指定Action的一些元数据。 应用接口层除了定义应用接口之外,还需要定义相关的DTO对象。 应用接口层可以被其他微服务组件应用或是通过nuget进行分发,通过IServiceProxyFactory创建应用接口的代理,从而实现RPC通信。 3. Application 应用层 应用层主要是实现业务流程和输入输出判断，不实现复杂的业务逻辑 应用层的应用需要实现应用接口定义的接口,并继承ProxyServiceBase,基类ProxyServiceBase提供了一些通用的方法。 4. Domain 领域层 领域层主要是实现具体的业务逻辑 5. Domian.Shared 定义微服务组件通用的值类型(model或是枚举类型),可被其他微服务组件引用 容器化服务和服务编排服务容器化docker是一款优秀的容器引擎产品。将服务容器化,能够最大化的发挥微服务的体验性。能够让开发者感受到docker构建一次,处处运行的魅力所在。所以我强烈推荐在开发过程中,使用docker容器化服务组件,使用docker-compose编排微服务组件。vs对docker-compose进行开发调试提供了非常友好的体验性。一般地,会在服务组件的Host层提供Dockerfile用于构建docker镜像。如下的dockerfile提供了微服务组件的编译、构建等过程。 1234567891011121314151617181920212223242526FROM microsoft/dotnet:2.2.0-runtime AS baseWORKDIR /appARG rpc_port=100ARG http_port=8080ARG ws_port=96ENV TZ=Asia/Shanghai RUN ln -snf /usr/share/zoneinfo/$TZ /etc/localtime &amp;&amp; echo $TZ &gt; /etc/timezone EXPOSE $&#123;rpc_port&#125; $&#123;http_port&#125; $&#123;ws_port&#125;FROM microsoft/dotnet:2.2-sdk AS buildWORKDIR /srcCOPY . .ARG sln_nameRUN dotnet restore $&#123;sln_name&#125; &amp;&amp; \ dotnet build --no-restore -c Release $&#123;sln_name&#125;FROM build AS publishARG host_workdirWORKDIR $&#123;host_workdir&#125;RUN dotnet publish --no-restore -c Release -o /appFROM base AS finalARG host_nameENV host_name=$&#123;host_name&#125;COPY --from=publish /app .ENTRYPOINT dotnet $&#123;host_name&#125; 服务编排使用docker-compose编排微服务组件,一般的,使用docker-compose.yml定义镜像构建的上下文、指定网络、镜像名称、挂载的目录等，通过docker-compose.override.yml来指定配置文件的环境变量，.env来设置环境变量的值,通过docker-compose.vs.debug.yml来指定调试过程中的相关设置(部署中可不指定该编排文件)。 需要注意的是,surging在开发过程中,基础服务也通过docker-compose来编排和启动,且必须在开发和调试前启动基础服务。基础服务和surging服务组件指定的网络必须同一个。 基础服务编排如下所示：12345678910111213141516171819202122232425262728293031323334353637383940version: '3.7'services: consul: image: consul:latest ports: - "8400:8400" - "8500:8500" - "8600:8600" - "8600:8600/udp" command: "agent -server -bootstrap-expect 1 -ui -client 0.0.0.0" networks: - surging_hero_service_net redis: image: redis:latest ports: - "6379:6379" networks: - surging_hero_service_net rabbitmq: image: rabbitmq:management environment: RABBITMQ_ERLANG_COOKIE: "SWQOKODSQALRPCLNMEQG" RABBITMQ_DEFAULT_USER: "rabbitmq" RABBITMQ_DEFAULT_PASS: "rabbitmq" RABBITMQ_DEFAULT_VHOST: "/" ports: - "15672:15672" - "5672:5672" networks: - surging_hero_service_net networks: surging_hero_service_net: driver: bridge name: surging_hero_service_net ipam: driver: default config: - subnet: 172.22.0.1/16 由于开发过程中的基础服务并没有考虑到高可用,在生产环境中建议基础服务集群化。 微服务组件的编排请参考: https://github.com/surging-cloud/Surging.Hero/tree/develop/hero/docker-compose/surging.hero 开发与调试其实在开发过程中,由于业务模块的不同，责任人不同,开发团队不同，开发者拥有的权限不同,业务模块的代码有可能放到不同的git仓库。建议将微服务服务组件的应用接口层和Domian.Shared可以发布的企业内部的nuget服务。其他微服务组件可以通过nuget服务引用应用接口层和Domian.Shared组件。如果源代码都放到一个git仓库中,也可以建立多个解决方案或是docker-compose编排文件项目来编排不同的服务，方便开发和调试。 常见问题首次使用docker-compose进行调试服务时,由于vs会从网络上下载vsdbg组件,由于网络原因,一般都会比较慢,开发者可以从其他同事的电脑的家目录下拷贝vsdbg到本机,重新打开vs,然后再进行调试。 Devops业务流程在开发过程中,我们使用Jenkins实现持续集成和部署。整个流程如下所述: 开发者编写业务代码或修复完bug后,提交代码,push到远程仓库,并发起pr请求,请求合并到develop分支。 当代码审核通过后,合并到develop分支后,通过设置gitlab或是gitee的webhook，触发jenkins执行构建。或是通过设置Jenkins的定时任务检测代码库变化,当代码库变化后,jenkins获取最新代码,执行构建操作(由于当时我们Jenkins部署的环境是内网,gitee无法访问公司内网,所以无法设置webhook) Jenkins通过预先设置好的命令和脚本执行构建打包程序。本质上是执行docker-compose build打包docker镜像,当完成构建和打包docker镜像后,然后将镜像推送到企业内部的docker镜像仓库。 之后,jenkins通过Jenkins SSH插件将部署脚本拷贝到k8集群的master节点,通过ssh插件在k8s master节点执行部署命令。完成后,微服务集群将自动部署到指定的k8s集群中。 整个devops流程如下所述(但是我们没有与钉钉做集成): 注意事项 企业内部的docker仓库除了可以使用harbor搭建之外,还可以使用nexus。推荐使用nexus作为仓库管理服务，因为nexus除了支持docker镜像仓库之外,还支持nuget包、npm等格式的包管理。 建议企业内部在构建业务平台时,根据业务模块划分主题,一个主题对应一个数据库,一个git仓库,一个项目组,多个相关的微服务组件，一个Jenkins构建项目。每个主题独立的进行持续集成与部署。 建议基础服务consul、rabbitmq、redis考虑集群。 产品交付和部署 一般的，我们通过docker镜像完成产品交付与部署。可以通过编写部署脚本在k8s集群或是通过rancher进行部署。 可以使用k8s或是rancher提供的Dashborad进行容器和服务的监控和管理。 体会 surging的设计思想是无疑正确的。相比于市面上其他的.net微服务框架或是分布式框架,无论是服务治理还是内部通信机制,服务引擎设置，主机寄宿均有独到之处。(abp vnext的微服务框架通过内部网关Ocelot进行通信,完全违反的去中心化设计，而且性能也相对较差的多) 在使用surging的过程中,也遇到了一些问题或是bug(例如:1.首次访问性能较差；2.服务实例无法支持同时扩展),在反馈到github社区或是请求作者协助,都能够得到及时反馈。目前作者已经即将完成对surging2.0的开发，相信会有更优秀的体验。 在开发和测试、部署和产品交付中推荐将服务容器化，推荐使用linux作为部署服务器。 最后 如果你对surging感兴趣,可以在github上对surging关注。 如果你对如何使用surging落地开发，您可以在github上关注surging.hero。 surging.hero是一个使用surging作为开发框架的权限管理平台。目前项目刚刚开始,欢迎各位开发者加入,如果您想加入surging.hero的开发或是愿意为surging的生态做出贡献,欢迎加入surging-cloud社区。 如果你希望加入surging-cloud社区，可以将你的github账号通过email到:1029765111@qq.com,并备注`申请加入 surging-cloud社区 即可。 如果您对surging.hero感兴趣并希望加入surging.hero的开发,也可以申请加入qq群:713943626。 如果大家对surging确实感兴趣,后期我有时间的话,可以写一些我使用surging的经验或是对源码的理解。]]></content>
      <tags>
        <tag>微服务</tag>
        <tag>Surging</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[条件测试操作与流程控制语句]]></title>
    <url>%2Fhexo-blog-deploy%2F2019%2F04%2F15%2F2019-04-linux-shell-flowcontrol%2F</url>
    <content type="text"><![CDATA[条件测试操作在编写Shell脚本时候，经常需要判断两个字符串是否相等，检查文件状态或者是数字的测试等。Shell提供了对字符串、文件、数值等内容的条件测试以及逻辑流程控制。程序中的流程控制是由比较和测试语句来处理的，bash具备多种与UNIX系统级特性相兼容的执行测试方法。 常用测试操作test命令，测试特定的表达式是否成立，当条件成立时，命令执行后的返回值为0，否则为其他数值。 1234# 格式1test 条件表达式# 格式2[ 条件表达式 ] 常见测试类型 测试文件状态 字符串的比较 整数值的比较 逻辑测试 测试文件格式1[ 操作符 文件或目录 ] 操作符 -d：测试是否为目录，是则为真（Directory） -e：测试目录或文件是否存在，存在则为真（Exist） -f：测试是否为文件，是则为真（file） -r：测试当前用户是否有权限读取，是则为真（read） -w：测试当前用户是否有权限写入，是这为真（write） -x：测试当前用户是否可执行该文件，可执行则为真（Excute） -L：测试是否为符号链接文件，是则为真（Link） -nt：file1 -nt file2 如果 file1 比 file2 新（修改时间），则为真 -ot：file1 -ot file2 如果 file1 比 file2 旧（修改时间），则为真 字符串比较格式123[ 字符串1 = 字符串2 ][ 字符串1 != 字符串2 ][ -z 字符串 ] 操作符 =：字符串内容相同则为真，就是说包含的文本一摸一样。 !=：字符串内容不同，则为真（!号表示相反的意思） -z：字符串内容为空（长度为零）则为真 -n：字符串内容非空（长度非零）则为真 &lt;：string1 &lt; string2 如果string1在本地的字典序列中排在string2之前，则为真 &gt;：string2 如果string1在本地的字典序列中排在string2之后，则为真 注意点： 字符串的 “等于” 比较，为了与POSIX一致，在[]中使用=，（尽管==也可以可以用的） 注意在=前后各有一个空格，如果没有空格就是赋值的关系，不是比较的关系。 字符串的&gt; &lt;比较运算符，一般放在[[ ]]之中，而不是test ([]) 字符串的&gt; &lt;比较的结果，与本地的locale有关，是按照其字典序列进行比较的 整数值比较格式1[ 整数1 操作符 整数2 ] 操作符 -eq：等于（equal） -ne：不等于（not equal） -gt：大于（Greater than） -lt：小于（lesser than） -le：小于等于（lesser or equal） -ge：大于等于（Greater or equal） 逻辑测试格式1[ 表达式1 ] 操作符 [ 表达式2 ] ... 操作符 -a 或 &amp;&amp; ：逻辑与，“而且”的意思，前后两个表达式都成立时整个测试结果才为真，否则为假 -o 或 || ： 逻辑或，“或者”的意思，操作符两边至少一个为真时，结果为真，否为为假 !：逻辑否，当制定条件不成立时，返回结果为真 流程控制语句Shell有一套自己的流程控制语句，其中包括条件语句、循环语句、选择语句等。 if条件语句if 单分支当“条件成立”时执行相应的操作。123if 条件测试操作 then 命令序列fi 例子12345678#!/bin/bash#当/boot分区的空间使用超过80%，就输出报警信息。use=`df -hT | grep "/boot" | awk '&#123;print $6&#125;' | cut -d "%" -f1`if [ $use -gt 80 ]; then echo "Warning!!/boot disk is full"fi if 双分支当“条件成立”、“条件不成立”时执行不同操作。1234if 条件测试命令 then 命令序列1 else 命令序列2fi 例子 123456789#!/bin/bash#判断iptables是否在运行，如果已经在运行提示信息，如果没有开启它。service iptables status &amp;&gt; /dev/nullif [ $? -eq 0 ]; then echo "iptables service is running" else service iptables restartfi if 多分支相当于if语句嵌套，针对多个条件执行不同操作12345678if 条件测试命令1 ; then 命令序列1elif 条件测试命令2 ; then 命令序列2elif ...else 命令序列nfi for循环语句根据标量的不同取值，重复执行一组命令操作。1234for 变量名 in 取值列表do 命令序列done for循环的几种应用形式最基本的for循环： （传统的形式，for var in …)123456#!/bin/bashfor x in one two three fourdo echo number $xdone # for循环总是接收in语句之后的某种类型的字列表。在本例中，指定了四个英语单词，但是字列表也可以引用磁盘上的文件，甚至文件通配符。 对目录中的文件做for循环1234567#!/bin/bashfor x in /var/log/*do #echo "$x is a file living in /var/log" echo $(basename $x) is a file living in /var/logdone # 这个$x获得的是绝对路径文件名，可以使用`basename`可执行程序来除去前面的路径信息。如果只引用当前工作目录中的文件（例如如果输入for x in *），则产生的文件列表将没有路径信息的前缀。 对位置参数做for循环12345#!/bin/bashfor thing in "$@"do echo you typed $&#123;thing&#125;.done for循环中用seq产生循环次数，加上C语言形式的for循环语句123456789101112#!/bin/bashecho "for: Traditional form: for var in ..."for j in $(seq 1 5)do echo $jdoneecho "for: C language form: for (( exp1; exp2; exp3 ))"for (( i=1; i&lt;=5; i++ ))do echo "i=$i"done # 对于固定次数的循环，可以通过seq命令来实现，就不需要变量的自增了 while循环语句重复测试指令的条件，只要条件为真则反复执行对应的命令操作，直到条件为假。如果使用true作为循环条件能够产生无限循环1234while 命令表达式do 命令列表done 示例12345678910#!/bin/bash#批量添加20个系统账户用户名依次为user1~20i=1while [ $i -le 20 ]do useradd user$1 echo "123456" | passwd --stdin user$i &amp;&gt; /dev/null i=`expr $i + 1`done# 只要特定条件为真，”while” 语句就会循环执行。 case多重分支语句根据变量的不通取值，分别执行不同的命令操作。123456789101112case 变量值 in 模式1) 命令序列1;; 模式2) 命令序列2;; ……*) 默认执行的命令序列;;esac 示例123456789101112#!/bin/bashcase $1 instart) echo "start mysql";;stop) echo "stop mysql";;*) echo "usage: $0 start|stop";;esac until循环语句根据条件执行重复操作，直到条件成立为止。Until语句提供了与while语句相反的功能：只要特定条件为假，它们就重复循环，直到条件为真。1234until 条件测试命令do 命令序列done 示例1234567#!/bin/bashmyvar=1until [ $myvar -gt 10 ]do echo $myvar myvar=$(( $myvar + 1 ))done shift迁移语句用于迁移位置变量，将$1~$9依次向左传递。 例如：若当前脚本程序获得的位置变量如下：1234567$1=file1、$2=file2、$3=file3、$4=file4# 执行一次shift命令后，各位置变量为：$2=file2、$3=file3、$4=file4# 在执行一次：$3=file3、$4=file4 示例12345678#!/bin/bashres=0while [ $# -gt 0 ]do res=`expr $res + $1` shiftdoneecho "the sum is:$res" 循环控制语句break语句：在for、while、until等循环语句中，用于跳出当前所在的循环体，执行循环体之后的语句。 在while中的示例：1234567891011121314while docommandscommands break--------+ |commands |commands | 跳出当前循环（通常在循环体中与条件语句一起使用） | done | |commands&lt;-----+commands continue语句：在for、while、until等循环语句中，用于跳过循环体内余下的语句，重新判断条件以便执行下一次循环。 在while中的示例：1234567891011121314while&lt;-------+ do | |commands | 跳回当前循环，重新开始下一次循环（通常在循环体中与条件语句一起使用）commands | | continue----+commandscommandscommands donecommandscommands]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>shell</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java基础知识之集合]]></title>
    <url>%2Fhexo-blog-deploy%2F2019%2F04%2F12%2F2019-04-java-collection%2F</url>
    <content type="text"><![CDATA[集合与数组数组:（可以存储基本数据类型）是用来存现对象的一种容器，但是数组的长度固定，不适合在对象数量未知的情况下使用。 集合:（只能存储对象，对象类型可以不一样）的长度可变，可在多数情况下使用。 集合中接口和类的关系层次图简单版 完整版 对比 Collection接口是集合类的根接口，Java中没有提供这个接口的直接的实现类。但是却让其被继承产生了两个接口，就是Set和List。 Set中不能包含重复的元素。 List是一个有序的集合，可以包含重复的元素，提供了按索引访问的方式。 Map是Java.util包中的另一个接口，它和Collection接口没有关系，是相互独立的，但是都属于集合类的一部分。Map包含了key-value对。Map不能包含重复的key，但是可以包含相同的value。 Iterator所有的集合类，都实现了Iterator接口，这是一个用于遍历集合中元素的接口，主要包含以下三种方法： hasNext()是否还有下一个元素。 next()返回下一个元素。 remove()删除当前元素。 接口 子接口 是否有序 是否允许元素重复 Collection List ArrayList 否 是 LinkedList 否 是 Vector 否 是 Set AbstractSet 否 否 HashSet 否 否 TreeSet 是（用二叉排序树） 否 Map AbstractMap 否 使用key-value来映射和存储数据，key必须唯一，value可以重复 HashMap 否 TreeMap 是（用二叉排序树） 使用key-value来映射和存储数据，key必须唯一，value可以重复 CollectionListList里存放的对象是有序的，同时也是可以重复的，List关注的是索引，拥有一系列和索引相关的方法，查询速度快。因为往list集合里插入或删除数据时，会伴随着后面数据的移动，所有插入删除数据速度慢。 ArrayListArrayList是基于数组的，在初始化ArrayList时，会构建空数组（Object[] elementData={}）。ArrayList是一个无序的，它是按照添加的先后顺序排列，当然，他也提供了sort方法，如果需要对ArrayList进行排序，只需要调用这个方法，提供Comparator比较器即可。 add操作： 如果是第一次添加元素，数组的长度被扩容到默认的capacity，也就是10. 当发觉同时添加一个或者是多个元素，数组长度不够时，就扩容，这里有两种情况： 只添加一个元素，例如：原来数组的capacity为10，size已经为10，不能再添加了。需要扩容，新的capacity=old capacity+old capacity&gt;&gt;1=10+10/2=15.即新的容量为15。 当同时添加多个元素时，原来数组的capacity为10，size为10，当同时添加6个元素时。它需要的min capacity为16，而按照capacity=old capacity+old capacity&gt;&gt;1=10+10/2=15。new capacity小于min capacity，则取min capacity。 对于添加，如果不指定下标，就直接添加到数组后面，不涉及元素的移动，如果要添加到某个特定的位置，那需要将这个位置开始的元素往后挪一个位置，然后再对这个位置设置。 Remove操作：Remove提供两种，按照下标和value。 remove(int index)：首先需要检查Index是否在合理的范围内。其次再调用System.arraycopy将index之后的元素向前移动。 remove(Object o)：首先遍历数组，获取第一个相同的元素，获取该元素的下标。其次再调用System.arraycopy将index之后的元素向前移动。 Get操作：这个比较简单，直接对数组进行操作即可。 LinkedListLinkedList是基于链表的，它是一个双向链表，每个节点维护了一个prev和next指针。同时对于这个链表，维护了first和last指针，first指向第一个元素，last指向最后一个元素。LinkedList是一个无序的链表，按照插入的先后顺序排序，不提供sort方法对内部元素排序。 Add元素： LinkedList提供了几个添加元素的方法：addFirst、addLast、addAll、add等，时间复杂度为O(1)。 Remove元素： LinkedList提供了几个移除元素的方法：removeFirst、removeLast、removeFirstOccurrence、remove等，时间复杂度为O(1)。 Get元素： 根据给定的下标index，判断它first节点、last直接距离，如果index&lt;size（数组元素个数)/2,就从first开始。如果大于，就从last开始。这个和我们平常思维不太一样，也许按照我们的习惯，从first开始。这也算是一点小心的优化吧。 遍历操作在类集中提供了以下四种的常见输出方式： Iterator：迭代输出，是使用最多的输出方式。 ListIterator：是Iterator的子接口，专门用于输出List中的内容。 foreach输出：JDK1.5之后提供的新功能，可以输出数组或集合。 for循环 代码操作 for的形式：1for（int i=0;i&lt;arr.size();i++）&#123;...&#125; foreach的形式：1for（int i：arr）&#123;...&#125; iterator的形式：12Iterator it = arr.iterator();while(it.hasNext())&#123; object o =it.next(); ...&#125; SetSet里存放的对象是无序，不能重复的，集合中的对象不按特定的方式排序，只是简单地把对象加入集合中。 HashSet HashSet是基于HashMap来实现的，操作很简单，更像是对HashMap做了一次“封装”，而且只使用了HashMap的key来实现各种特性，而HashMap的value始终都是PRESENT。 HashSet不允许重复（HashMap的key不允许重复，如果出现重复就覆盖），允许null值，非线程安全。 构造方法 HashSet() 构造一个新的空 set，其底层 HashMap 实例的默认初始容量是 16，加载因子是 0.75 HashSet(Collection&lt;? extends E&gt; c) 构造一个包含指定 collection 中的元素的新 set HashSet(int initialCapacity) 构造一个新的空 set ,其底层 HashMap 实例具有指定的初始容量和默认的加载因子（0.75）。 HashSet(int initialCapacity, float loadFactor) 构造一个新的空 set，其底层 HashMap 实例具有指定的初始容量和指定的加载因子。 方法 boolean add(E e) 如果此 set 中尚未包含指定元素，则添加指定元素。 void clear() 从此 set 中移除所有元素。 Object clone() 返回此 HashSet 实例的浅表副本：并没有复制这些元素本身。 boolean contains(Object o) 如果此 set 包含指定元素，则返回 true。 boolean isEmpty() 如果此 set 不包含任何元素，则返回 true。 Iterator iterator() 返回对此 set 中元素进行迭代的迭代器。 boolean remove(Object o) 如果指定元素存在于此 set 中，则将其移除。 int size() 返回此 set 中的元素的数量（set 的容量）。 TreeSet基于 TreeMap 的 NavigableSet 实现。使用元素的自然顺序对元素进行排序，或者根据创建 set 时提供的 Comparator进行排序，具体取决于使用的构造方法。 set的遍历同 list Queue队列是一种特殊的线性表，它只允许在表的前端进行删除操作，而在表的后端进行插入操作。LinkedList类实现了Queue接口，因此我们可以把LinkedList当成Queue来用。 MapMap集合中存储的是键值对，键不能重复，值可以重复。根据键得到值，对map集合遍历时先得到键的set集合，对set集合进行遍历，得到相应的值。 HashMap 数组方式存储key/value，线程非安全，允许null作为key和value，key不可以重复，value允许重复，不保证元素迭代顺序是按照插入时的顺序，key的hash值是先计算key的hashcode值，然后再进行计算，每次容量扩容会重新计算所以key的hash值，会消耗资源，要求key必须重写equals和hashcode方法 默认初始容量16，加载因子0.75，扩容为旧容量乘2，查找元素快，如果key一样则比较value，如果value不一样，则按照链表结构存储value，就是一个key后面有多个value； 方法 添加： V put(K key, V value) （可以相同的key值，但是添加的value值会覆盖前面的，返回值是前一个，如果没有就返回null） putAll(Map&lt;? extends K,? extends V&gt; m) 从指定映射中将所有映射关系复制到此映射中（可选操作）。 删除 remove() 删除关联对象，指定key对象 clear() 清空集合对象 获取 value get(key) 可以用于判断键是否存在的情况。当指定的键不存在的时候，返回的是null。 判断： boolean isEmpty() 长度为0返回true否则false boolean containsKey(Object key) 判断集合中是否包含指定的key boolean containsValue(Object value) 判断集合中是否包含指定的value 长度： Int size() HashtableHashtable与HashMap类似，是HashMap的线程安全版，它支持线程的同步，即任一时刻只有一个线程能写Hashtable，因此也导致了Hashtale在写入时会比较慢，它继承自Dictionary类，不同的是它不允许记录的键或者值为null，同时效率较低。 LinkedHashMapLinkedHashMap保存了记录的插入顺序，在用Iteraor遍历LinkedHashMap时，先得到的记录肯定是先插入的，在遍历的时候会比HashMap慢，有HashMap的全部特性。 TreeMap基于红黑二叉树的NavigableMap的实现，线程非安全，不允许null，key不可以重复，value允许重复，存入TreeMap的元素应当实现Comparable接口或者实现Comparator接口，会按照排序后的顺序迭代元素，两个相比较的key不得抛出classCastException。主要用于存入元素的时候对元素进行自动排序，迭代输出的时候就按排序顺序输出 Map遍历1. KeySet()将Map中所有的键存入到set集合中。因为set具备迭代器。所有可以迭代方式取出所有的键，再根据get方法。获取每一个键对应的值。keySet():迭代后只能通过get()取key 。取到的结果会乱序，是因为取得数据行主键的时候，使用了HashMap.keySet()方法，而这个方法返回的Set结果，里面的数据是乱序排放的。123456789101112Map map = new HashMap();map.put("key1","lisi1");map.put("key2","lisi2");map.put("key3","lisi3");map.put("key4","lisi4"); //先获取map集合的所有键的set集合，keyset（）Iterator it = map.keySet().iterator();//获取迭代器while(it.hasNext())&#123; Object key = it.next(); System.out.println(map.get(key));&#125; 2. values() 获取所有的值123456Collection&lt;String&gt; vs = map.values();Iterator&lt;String&gt; it = vs.iterator();while (it.hasNext()) &#123; String value = it.next(); System.out.println(" value=" + value);&#125; 3. entrySet()Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet() //返回此映射中包含的映射关系的 Set 视图。（一个关系就是一个键-值对），就是把(key-value)作为一个整体一对一对地存放到Set集合当中的。Map.Entry表示映射关系。entrySet()：迭代后可以e.getKey()，e.getValue()两种方法来取key和value。返回的是Entry接口。123456789101112// 返回的Map.Entry对象的Set集合 Map.Entry包含了key和value对象 Set&lt;Map.Entry&lt;Integer, String&gt;&gt; es = map.entrySet(); Iterator&lt;Map.Entry&lt;Integer, String&gt;&gt; it = es.iterator(); while (it.hasNext()) &#123; // 返回的是封装了key和value对象的Map.Entry对象 Map.Entry&lt;Integer, String&gt; en = it.next(); // 获取Map.Entry对象中封装的key和value对象 Integer key = en.getKey(); String value = en.getValue(); System.out.println("key=" + key + " value=" + value); &#125; Notes 推荐使用第三种方式，即entrySet()方法，效率较高。 对于keySet其实是遍历了2次，一次是转为iterator，一次就是从HashMap中取出key所对于的value。而entryset只是遍历了第一次，它把key和value都放到了entry中，所以快了。两种遍历的遍历时间相差还是很明显的。 总结Vector和ArrayList Vector是线程同步的，所以它也是线程安全的，而Arraylist是线程异步的，是不安全的。如果不考虑到线程的安全因素，一般用Arraylist效率比较高。 如果集合中的元素的数目大于目前集合数组的长度时，Vector增长率为目前数组长度的100%，而Arraylist增长率为目前数组长度的50%。如果在集合中使用数据量比较大的数据，用Vector有一定的优势。 如果查找一个指定位置的数据，Vector和Arraylist使用的时间是相同的，如果频繁的访问数据，这个时候使用Vector和Arraylist都可以。而如果移动一个指定位置会导致后面的元素都发生移动，这个时候就应该考虑到使用Linklist,因为它移动一个指定位置的数据时其它元素不移动。 ArrayList 和Vector是采用数组方式存储数据，此数组元素数大于实际存储的数据以便增加和插入元素，都允许直接序号索引元素，但是插入数据要涉及到数组元素移动等内存操作，所以索引数据快，插入数据慢，Vector由于使用了synchronized方法（线程安全）所以性能上比ArrayList要差，LinkedList使用双向链表实现存储，按序号索引数据需要进行向前或向后遍历，但是插入数据时只需要记录本项的前后项即可，所以插入数度较快。 Arraylist和Linkedlist ArrayList是实现了基于动态数组的数据结构，LinkedList基于链表的数据结构。 对于随机访问get和set，ArrayList觉得优于LinkedList，因为LinkedList要移动指针。 对于新增和删除操作add和remove，LinedList比较占优势，因为ArrayList要移动数据。 这一点要看实际情况的。若只对单条数据插入或删除，ArrayList的速度反而优于LinkedList。但若是批量随机的插入删除数据，LinkedList的速度大大优于ArrayList。 因为ArrayList每插入一条数据，要移动插入点及之后的所有数据。 HashMap与TreeMap HashMap通过hashcode对其内容进行快速查找，而TreeMap中所有的元素都保持着某种固定的顺序，如果你需要得到一个有序的结果你就应该使用TreeMap（HashMap中元素的排列顺序是不固定的）。 在Map 中插入、删除和定位元素，HashMap是最好的选择。但如果您要按自然顺序或自定义顺序遍历键，那么TreeMap会更好。使用HashMap要求添加的键类明确定义了hashCode()和 equals()的实现。 两个map中的元素一样，但顺序不一样，导致hashCode()不一样。 测试： 在HashMap中，同样的值的map,顺序不同，equals时，false; 而在TreeMap中，同样的值的map,顺序不同,equals时，true，说明，TreeMap在equals()时是整理了顺序了的。 HashTable与HashMap 同步性:Hashtable是线程安全的，也就是说是同步的，而HashMap是线程序不安全的，不是同步的。 HashMap允许存在一个为null的key，多个为null的value。 Hashtable的key和value都不允许为null。]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java基础知识</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Shell函数的定义、执行、传参和递归函数]]></title>
    <url>%2Fhexo-blog-deploy%2F2019%2F04%2F12%2F2019-04-linux-shell-function%2F</url>
    <content type="text"><![CDATA[简介Bash（Bourne Again shell）也跟其他编程语言一样也支持函数，一般在编写大型脚本中需要用到，它可以将shell脚本程序划分成一个个功能相对独立的代码块，使代码的模块化更好，结构更加清晰，并可以有效地减少程序的代码量。但是bash作为一种解释性语言，bash 在编程能力方面提供的支持并不像其他编译性的语言（例如 C 语言）那样完善，执行效率也会低很多。 shell函数的定义、执行与传参函数的定义可以带function name()定义，也可以直接name()定义，不带任何参数。 格式1123function name() &#123; command sequence(命令序列);&#125; 格式2123name() &#123; Command sequence(命令序列);&#125; 函数的执行12name;# 直接使用函数名称即可调用某个函数。 传递参数12345678910111213#!/bin/bashaa="this is aa"bb="this is bb"function name() &#123; #定义函数name local cc="this is cc" #定义局部变量$cc local dd="this is dd" #定义局部变量$dd echo $aa, $bb #访问参数1和参数2 echo $cc #打印局部变量 return 0 #shell函数返回值是整形，并且在0~257之间。&#125;echo $dd #这里将会打印不生效，因为dd是局部变量。name #使用函数name aa 和 bb 定义的是全局变量。 cc 和 dd 定义的是局部变量，只能在函数 name 中使用。 $aa是第一个参数$1，$bb是第一个参数$2，以此类推$n是第n个参数$n。 return 0参数返回，可以显示加：return 返回，如果不加，将以最后一条命令运行结果作为返回值。 递归函数bash也支持递归函数（能够调用自身的函数）例如：123456789#!/bin/bashfunction name() &#123; echo $1 name hello sleep 1&#125;name# 运行此脚本后不断打印出hello，按Ctrl+C结束。 案例:递归经典–fork 炸弹可能很多人都曾经听说过 fork 炸弹，它实际上只是一个非常简单的递归程序，程序所做的事情只有一样：这个递归函数能够调用自身，不算的生成新的进程，这会导致这个简单的程序迅速耗尽系统里面的所有资源，造成拒绝服务攻击。123456.()&#123;.|.&amp;&#125;;. 第 1 行说明下面要定义一个函数，函数名为小数点，没有可选参数。 第 2 行表示函数体开始。 第 3 行是函数体真正要做的事情，首先它递归调用本函数，然后利用管道调用一个新进程（它要做的事情也是递归调用本函数），并将其放到后台执行。 第 4 行表示函数体结束。 第 5 行并不会执行什么操作，在命令行中用来分隔两个命令用。从总体来看，它表明这段程序包含两个部分，首先定义了一个函数，然后调用这个函数。 第 6 行表示调用本函数。]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>shell</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[文件的描述符和重定向]]></title>
    <url>%2Fhexo-blog-deploy%2F2019%2F04%2F10%2F2019-04-linux-shell-fileredirect%2F</url>
    <content type="text"><![CDATA[简介文件描述符是和文件的输入、输出相关联的非负整数，Linux内核（kernel）利用文件描述符（file descriptor）来访问文件。打开现存文件或新建文件时，内核会返回一个文件描述符。读写文件也需要使用文件描述符来指定待读写的文件。常见的文件描述符是stdin、stdout和stderr。 系统预留文件描述符 0 —— stdin（标准输入） 1 —— stdout（标准输出） 2 —— stderr（标准错误） 重定向将输入文本通过截取模式保存到文件：12echo "this is a text line one" &gt; test.txt# 写入到文件之前，文件内容首先会被清空。 重定向将输入文本通过追加模式保存到文件：12echo "this is a text line one" &gt;&gt; test.txt# 写入到文件之后，会追加到文件结尾。 标准错误输出：12[root@localhost text]# cat linuxde.netcat: linuxde.net: No such file or directory 标准错误输出的重定向方法：123456# 方法一：[root@localhost text]# cat linuxde.net 2&gt; out.txt //没有任何错误提示，正常运行。# 方法二：[root@localhost text]# cat linuxde.net &amp;&gt; out.txt# 因为错误信息被保存到了out.txt文件中。 将错误输出丢弃到/dev/null中，/dev/null是一个特殊的设备文件，这个文件接受到任何数据都会被丢系，通常被称为位桶、黑洞。 1[root@localhost text]# cat linuxde.net 2&gt; /dev/null tee命令tee命令可以将数据重定向到文件，另一方面还可以提供一份重定向数据的副本作为后续命令的stdin。 例子在终端打印stdout同时重定向到文件中：12345678910111213141516171819202122232425ls | tee out.txt1.sh1.txt2.txteee.tstEEE.tstoneout.txtstring2www.pdfWWW.pdfWWW.pef# 显示行号[root@localhost text]# ls | tee out.txt | cat -n 1 1.sh 2 1.txt 3 2.txt 4 eee.tst 5 EEE.tst 6 one 7 out.txt 8 string2 9 www.pdf10 WWW.pdf11 WWW.pef 重定向脚本内的文本片段（多行文本）123456#!/bin/bashcat &lt;&lt;EOF&gt;text.logthis is a text line1this is a text line2this is a text line3EOF 在cat &lt;&lt;EOF&gt;text.log与下一个EOF行之间的所有文本都会当作stdin数据输入到text.log中。 自定义文件描述符除了0、1和2分别是stdin、stdout和stderr的系统预留描述符，我们还可以使用exec命令创建自定义文件描述符，文件的的打开模式有只读模式、截断模式和追加模式。 &lt; 操作符用于从文件中读取至stdin：1234567echo this is a test line &gt; input.txtexec 3&lt;input.txt //自定义文件描述符3打开并读取文件# 在命令中使用文件描述符3：cat &lt;&amp;3this is a test line# 这里需要注意只能读取一次，如果再次使用需要重新创建文件描述符。 &gt; 操作符用于截断模式的文件写入（数据在文件内容被截断之后写入）：1234exec 4&gt;output.txtecho this is a new line &gt;&amp;4cat output.txtthis is a new line &gt;&gt; 操作符用于追加模式的文件写入（添加数据到文件中，原有数据不会丢失）：12345exec 5&gt;&gt;output.txtecho this is a appended line &gt;&amp;5cat output.txtthis is a new linethis is a appended lin]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>shell</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[终端打印、算术运算、常用变量]]></title>
    <url>%2Fhexo-blog-deploy%2F2019%2F04%2F09%2F2019-04-linux-shell-terminalprint-and-operation-and-variable%2F</url>
    <content type="text"><![CDATA[终端打印echo123echo hello worldecho 'hello world' # bash不会对单引号内变量（如$var）求值。echo "hello world" printf 更为强大打印命令支持格式替换符123456#!/bin/bashprintf "%-5s %-10s %-4s\n" NO Name Markprintf "%-5s %-10s %-4.2f\n" 01 Tom 90.3456printf "%-5s %-10s %-4.2f\n" 02 Jack 89.2345printf "%-5s %-10s %-4.2f\n" 03 Jeff 98.4323 格式替代符 %b 相对应的参数被视为含有要被处理的转义序列之字符串。 %c ASCII字符。显示相对应参数的第一个字符 %d, %i 十进制整数 %e, %E, %f 浮点格式 %g %e或%f转换，看哪一个较短，则删除结尾的零 %G %E或%f转换，看哪一个较短，则删除结尾的零 %o 不带正负号的八进制值 %s 字符串 %u 不带正负号的十进制值 %x 不带正负号的十六进制值，使用a至f表示10至15 %X 不带正负号的十六进制值，使用A至F表示10至15 %% 字面意义的% 转义序列 \a 警告字符，通常为ASCII的BEL字符 \b 后退 \c 抑制（不显示）输出结果中任何结尾的换行字符（只在%b格式指示符控制下的参数字符串中有效），而且，任何留在参数里的字符、任何接下来的参数以及任何留在格式字符串中的字符，- 都被忽略 \f 换页（formfeed） \n 换行 \r 回车（Carriage return） \t 水平制表符 \v 垂直制表符 \\ 一个字面上的反斜杠字符 \ddd 表示1到3位数八进制值的字符，仅在格式字符串中有效 \0ddd 表示1到3位的八进制值字符 算术运算整数运算1. let运算命令12345#!/bin/bashno1=2;no2=3;let result=no1+no2echo $result 自加操作let no++ 自减操作let no-- 简写形式let no+=10 let no-=20分别等同于let no=no+10 let no=no-20 2. 操作符[]运算方法12345#!/bin/bashno1=2;no2=3;result=$[$no1+no2]echo $result 使用方法和let相似，在[]中可以使$前缀。 3. (())运算方法12345#!/bin/bashno1=2;no2=3;result=$((no1+no2))echo $result 4. expr运算方法12result=`expr 2 + 3`result=$(expr $no1 + 5) expr的常用运算符 加法运算：+ 减法运算：- 乘法运算：\* 除法运算：/ 求摸（取余）运算：% 精密计算算术操作高级运算工具：bc，它可以执行浮点运算和一些高级函数 例如: 12echo "1.212*3" | bc 3.636 设定小数精度（数值范围）12echo "scale=2;3/8" | bc # 参数scale=2是将bc输出结果的小数位设置为2位0.37 进制转换123456789#!/bin/bashabc=192echo "obase=2;$abc" | bc# 执行结果为：11000000，这是用bc将十进制转换成二进制。#!/bin/bashabc=11000000echo "obase=10;ibase=2;$abc" | bc# 执行结果为：192，这是用bc将二进制转换为十进制。 计算平方和平方根12echo "10^10" | bcecho "sqrt(100)" | bc 常用变量结合不同的引导为变量赋值 双引号 &quot;&quot; ：允许通过$符号引用其他变量值 单引号 &#39;&#39; ：禁止引用其他变量值，$视为普通字符 反撇号 ：将命令执行的结果输出给变量 用户自定义变量设置变量的作用范围格式：12export 变量名...export 变量名=变量值 [...变量名n=变量值n] 清除用户自定义变量格式：1unset 变量名 环境变量环境变量配置文件 全局配置文件：/etc/profile 用户配置文件：~/.bash_profile 查看环境变量set命令可以查看所有的shell变量，其中包括环境变量 常见的环境变量 $USER 查看账户信息 $logname 登录相关信息 $UID $Shell $HOME 家目录 $pwd $PATH 用户所输入的命令是在哪些目录中查找 $PS1 $PS2 $RANDOM 随机数 位置变量表示为：$n （n为1~9之间的数字）1#./test.sh one two three four five six $0 表示文件名本身 one就是：$1 two就是：$2 预定义变量 $#：命令行中位置参数的个数 $*：所有位置参数的内容 $?：上一条命令执行后返回的状态，当返回状态值为0时表示执行正常，非0表示执行异常或出错 $$：当前所在进程的进程号 $!：后台运行的最后一个进程号 $0：当前执行的进程/程序名]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>shell</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[优秀的开源项目]]></title>
    <url>%2Fhexo-blog-deploy%2F2019%2F04%2F04%2F2019-04-awesome-open-source-project%2F</url>
    <content type="text"><![CDATA[Java spring-boot netty dotnet &amp; Csharp Abp framework Abp vNext Surging eShopOnContainers eNode Linux]]></content>
      <categories>
        <category>博客</category>
      </categories>
      <tags>
        <tag>blog</tag>
        <tag>opensource</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[优秀博客积累]]></title>
    <url>%2Fhexo-blog-deploy%2F2019%2F04%2F04%2F2019-04-awesome-blogs%2F</url>
    <content type="text"><![CDATA[个人博客 阮一峰的网络日志 Javajava基础JVM jvm内存模型和内存分配 JVM内存模型总结 Java集合 java集合（list,set,map) Java 集合系列目录(Category) 常用的几种java集合类总结 反射IO网络编程JPAMybatis异常处理身份认证与授权 Spring Security教程 Spring Cloud下微服务权限方案 Java常用包/工具 lombok使用教程 Maven Maven常用插件 spring全家桶spring frameworkspring bootspring clouddotnet &amp; CSharp 编写高质量代码改善C#程序的157个建议 Docker &amp; k8sMicro services Java 微服务框架选型(Dubbo 和 Spring Cloud？) 微服务分布式事务 LinuxInternetwork CommunicationDevOpsDDD(领域驱动设计) 领域驱动设计参考 领域服务与应用服务的区别 数据库知识]]></content>
      <categories>
        <category>博客</category>
      </categories>
      <tags>
        <tag>优秀博客</tag>
        <tag>blog</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[k8s本地集群环境搭建]]></title>
    <url>%2Fhexo-blog-deploy%2F2019%2F04%2F03%2F2019-04-k8s-install%2F</url>
    <content type="text"><![CDATA[环境准备安装kubeadm、kubectl、kubelet初始化master节点将node加点加入到k8s集群中安装cni插件安装LoadBalancer-Provider组件安装ingress边界路由组件验证k8s集群]]></content>
      <categories>
        <category>k8s</category>
      </categories>
      <tags>
        <tag>微服务</tag>
        <tag>k8s</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[find命令]]></title>
    <url>%2Fhexo-blog-deploy%2F2019%2F04%2F03%2F2019-04-linux-cmd-find%2F</url>
    <content type="text"><![CDATA[简介find命令用来在指定目录下查找文件。任何位于参数之前的字符串都将被视为欲查找的目录名。如果使用该命令时，不设置任何参数，则find命令将在当前目录下查找子目录与文件。并且将查找到的子目录和文件全部进行显示。 语法1find(选项)(参数) 选项12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455amin&lt;分钟&gt;：查找在指定时间曾被存取过的文件或目录，单位以分钟计算；-anewer&lt;参考文件或目录&gt;：查找其存取时间较指定文件或目录的存取时间更接近现在的文件或目录；-atime&lt;24小时数&gt;：查找在指定时间曾被存取过的文件或目录，单位以24小时计算；-cmin&lt;分钟&gt;：查找在指定时间之时被更改过的文件或目录；-cnewer&lt;参考文件或目录&gt;查找其更改时间较指定文件或目录的更改时间更接近现在的文件或目录；-ctime&lt;24小时数&gt;：查找在指定时间之时被更改的文件或目录，单位以24小时计算；-daystart：从本日开始计算时间；-depth：从指定目录下最深层的子目录开始查找；-expty：寻找文件大小为0 Byte的文件，或目录下没有任何子目录或文件的空目录；-exec&lt;执行指令&gt;：假设find指令的回传值为True，就执行该指令；-false：将find指令的回传值皆设为False；-fls&lt;列表文件&gt;：此参数的效果和指定“-ls”参数类似，但会把结果保存为指定的列表文件；-follow：排除符号连接；-fprint&lt;列表文件&gt;：此参数的效果和指定“-print”参数类似，但会把结果保存成指定的列表文件；-fprint0&lt;列表文件&gt;：此参数的效果和指定“-print0”参数类似，但会把结果保存成指定的列表文件；-fprintf&lt;列表文件&gt;&lt;输出格式&gt;：此参数的效果和指定“-printf”参数类似，但会把结果保存成指定的列表文件；-fstype&lt;文件系统类型&gt;：只寻找该文件系统类型下的文件或目录；-gid&lt;群组识别码&gt;：查找符合指定之群组识别码的文件或目录；-group&lt;群组名称&gt;：查找符合指定之群组名称的文件或目录；-help或——help：在线帮助；-ilname&lt;范本样式&gt;：此参数的效果和指定“-lname”参数类似，但忽略字符大小写的差别；-iname&lt;范本样式&gt;：此参数的效果和指定“-name”参数类似，但忽略字符大小写的差别；-inum&lt;inode编号&gt;：查找符合指定的inode编号的文件或目录；-ipath&lt;范本样式&gt;：此参数的效果和指定“-path”参数类似，但忽略字符大小写的差别；-iregex&lt;范本样式&gt;：此参数的效果和指定“-regexe”参数类似，但忽略字符大小写的差别；-links&lt;连接数目&gt;：查找符合指定的硬连接数目的文件或目录；-iname&lt;范本样式&gt;：指定字符串作为寻找符号连接的范本样式；-ls：假设find指令的回传值为Ture，就将文件或目录名称列出到标准输出；-maxdepth&lt;目录层级&gt;：设置最大目录层级；-mindepth&lt;目录层级&gt;：设置最小目录层级；-mmin&lt;分钟&gt;：查找在指定时间曾被更改过的文件或目录，单位以分钟计算；-mount：此参数的效果和指定“-xdev”相同；-mtime&lt;24小时数&gt;：查找在指定时间曾被更改过的文件或目录，单位以24小时计算；-name&lt;范本样式&gt;：指定字符串作为寻找文件或目录的范本样式；-newer&lt;参考文件或目录&gt;：查找其更改时间较指定文件或目录的更改时间更接近现在的文件或目录；-nogroup：找出不属于本地主机群组识别码的文件或目录；-noleaf：不去考虑目录至少需拥有两个硬连接存在；-nouser：找出不属于本地主机用户识别码的文件或目录；-ok&lt;执行指令&gt;：此参数的效果和指定“-exec”类似，但在执行指令之前会先询问用户，若回答“y”或“Y”，则放弃执行命令；-path&lt;范本样式&gt;：指定字符串作为寻找目录的范本样式；-perm&lt;权限数值&gt;：查找符合指定的权限数值的文件或目录；-print：假设find指令的回传值为Ture，就将文件或目录名称列出到标准输出。格式为每列一个名称，每个名称前皆有“./”字符串；-print0：假设find指令的回传值为Ture，就将文件或目录名称列出到标准输出。格式为全部的名称皆在同一行；-printf&lt;输出格式&gt;：假设find指令的回传值为Ture，就将文件或目录名称列出到标准输出。格式可以自行指定；-prune：不寻找字符串作为寻找文件或目录的范本样式;-regex&lt;范本样式&gt;：指定字符串作为寻找文件或目录的范本样式；-size&lt;文件大小&gt;：查找符合指定的文件大小的文件；-true：将find指令的回传值皆设为True；-typ&lt;文件类型&gt;：只寻找符合指定的文件类型的文件；-uid&lt;用户识别码&gt;：查找符合指定的用户识别码的文件或目录；-used&lt;日数&gt;：查找文件或目录被更改之后在指定时间曾被存取过的文件或目录，单位以日计算；-user&lt;拥有者名称&gt;：查找符和指定的拥有者名称的文件或目录；-version或——version：显示版本信息；-xdev：将范围局限在先行的文件系统中；-xtype&lt;文件类型&gt;：此参数的效果和指定“-type”参数类似，差别在于它针对符号连接检查。 参数起始目录：查找文件的起始目录。 实例根据文件或者正则表达式进行匹配列出当前目录及子目录下所有文件和文件夹 1find . 在/home目录下查找以.txt结尾的文件名1find /home -name "*.txt" 同上，但忽略大小写1find /home -iname &quot;*.txt&quot; 当前目录及子目录下查找所有以.txt和.pdf结尾的文件12345find . \( -name &quot;*.txt&quot; -o -name &quot;*.pdf&quot; \)# 或find . -name &quot;*.txt&quot; -o -name &quot;*.pdf&quot; 匹配文件路径或者文件1find /usr/ -path &quot;*local*&quot; 基于正则表达式匹配文件路径1find . -regex &quot;.*\(\.txt\|\.pdf\)$&quot; 同上，但忽略大小写1find . -iregex &quot;.*\(\.txt\|\.pdf\)$&quot; 否定参数找出/home下不是以.txt结尾的文件1find /home ! -name &quot;*.txt&quot; 根据文件类型进行搜索1find . -type 类型参数 类型参数列表： f 普通文件 l 符号连接 d 目录 c 字符设备 b 块设备 s 套接字 p Fifo 基于目录深度搜索向下最大深度限制为31find . -maxdepth 3 -type f 搜索出深度距离当前目录至少2个子目录的所有文件1find . -mindepth 2 -type f 根据文件时间戳进行搜索1find . -type f 时间戳 UNIX/Linux文件系统每个文件都有三种时间戳： 访问时间（-atime/天，-amin/分钟）：用户最近一次访问时间。 修改时间（-mtime/天，-mmin/分钟）：文件最后一次修改时间。 变化时间（-ctime/天，-cmin/分钟）：文件数据元（例如权限等）最后一次修改时间。 搜索最近七天内被访问过的所有文件1find . -type f -atime -7 搜索恰好在七天前被访问过的所有文件1find . -type f -atime 7 搜索超过七天内被访问过的所有文件1find . -type f -atime +7 搜索访问时间超过10分钟的所有文件1find . -type f -amin +10 找出比file.log修改时间更长的所有文件1find . -type f -newer file.log 根据文件大小进行匹配1find . -type f -size 文件大小单元 文件大小单元： b —— 块（512字节） c —— 字节 w —— 字（2字节） k —— 千字节 M —— 兆字节 G —— 吉字节 搜索大于10KB的文件1find . -type f -size +10k 搜索小于10KB的文件1find . -type f -size -10k 搜索等于10KB的文件1find . -type f -size 10k 删除匹配文件删除当前目录下所有.txt文件1find . -type f -name &quot;*.txt&quot; -delete 根据文件权限/所有权进行匹配当前目录下搜索出权限为777的文件1find . -type f -perm 777 找出当前目录下权限不是644的php文件1find . -type f -name &quot;*.php&quot; ! -perm 644 找出当前目录用户tom拥有的所有文件1find . -type f -user tom 找出当前目录用户组sunk拥有的所有文件1find . -type f -group sunk 借助-exec选项与其他命令结合使用找出当前目录下所有root的文件，并把所有权更改为用户tom1find .-type f -user root -exec chown tom &#123;&#125; \; 上例中，{} 用于与-exec选项结合使用来匹配所有文件，然后会被替换为相应的文件名。 找出自己家目录下所有的.txt文件并删除1find $HOME/. -name &quot;*.txt&quot; -ok rm &#123;&#125; \; 上例中，-ok和-exec行为一样，不过它会给出提示，是否执行相应的操作。 查找当前目录下所有.txt文件并把他们拼接起来写入到all.txt文件中1find . -type f -name &quot;*.txt&quot; -exec cat &#123;&#125; \;&gt; all.txt 将30天前的.log文件移动到old目录中1find . -type f -mtime +30 -name &quot;*.log&quot; -exec cp &#123;&#125; old \; 找出当前目录下所有.txt文件并以“File:文件名”的形式打印出来1find . -type f -name &quot;*.txt&quot; -exec printf &quot;File: %s\n&quot; &#123;&#125; \; 因为单行命令中-exec参数中无法使用多个命令，以下方法可以实现在-exec之后接受多条命令1-exec ./text.sh &#123;&#125; \; 搜索但跳出指定的目录查找当前目录或者子目录下所有.txt文件，但是跳过子目录sk1find . -path &quot;./sk&quot; -prune -o -name &quot;*.txt&quot; -print find其他技巧收集要列出所有长度为零的文件 1find . -empty]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux命令</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[grep命令]]></title>
    <url>%2Fhexo-blog-deploy%2F2019%2F04%2F03%2F2019-04-linux-cmd-grep%2F</url>
    <content type="text"><![CDATA[简介grep（global search regular expression(RE) and print out the line，全面搜索正则表达式并把行打印出来）是一种强大的文本搜索工具，它能使用正则表达式搜索文本，并把匹配的行打印出来。 选项12345678910111213141516171819202122232425-a 不要忽略二进制数据。-A&lt;显示列数&gt; 除了显示符合范本样式的那一行之外，并显示该行之后的内容。-b 在显示符合范本样式的那一行之外，并显示该行之前的内容。-c 计算符合范本样式的列数。-C&lt;显示列数&gt;或-&lt;显示列数&gt; 除了显示符合范本样式的那一列之外，并显示该列之前后的内容。-d&lt;进行动作&gt; 当指定要查找的是目录而非文件时，必须使用这项参数，否则grep命令将回报信息并停止动作。-e&lt;范本样式&gt; 指定字符串作为查找文件内容的范本样式。-E 将范本样式为延伸的普通表示法来使用，意味着使用能使用扩展正则表达式。-f&lt;范本文件&gt; 指定范本文件，其内容有一个或多个范本样式，让grep查找符合范本条件的文件内容，格式为每一列的范本样式。-F 将范本样式视为固定字符串的列表。-G 将范本样式视为普通的表示法来使用。-h 在显示符合范本样式的那一列之前，不标示该列所属的文件名称。-H 在显示符合范本样式的那一列之前，标示该列的文件名称。-i 忽略字符大小写的差别。-l 列出文件内容符合指定的范本样式的文件名称。-L 列出文件内容不符合指定的范本样式的文件名称。-n 在显示符合范本样式的那一列之前，标示出该列的编号。-q 不显示任何信息。-R/-r 此参数的效果和指定“-d recurse”参数相同。-s 不显示错误信息。-v 反转查找。-w 只显示全字符合的列。-x 只显示全列符合的列。-y 此参数效果跟“-i”相同。-o 只输出文件中匹配到的部分。 实例grep命令常见用法 在文件中搜索一个单词，命令会返回一个包含“match_pattern”的文本行： 12grep match_pattern file_namegrep "match_pattern" file_name 在多个文件中查找： 1grep "match_pattern" file_1 file_2 file_3 ... 输出除之外的所有行 -v 选项： 1grep -v "match_pattern" file_name 标记匹配颜色 –color=auto 选项： 1grep "match_pattern" file_name --color=auto 使用正则表达式 -E 选项 123grep -E "[1-9]+"或egrep "[1-9]+" 只输出文件中匹配到的部分 -o 选项： 12345echo this is a test line. | grep -o -E "[a-z]+\."line.echo this is a test line. | egrep -o "[a-z]+\."line. 统计文件或者文本中包含匹配字符串的行数 -c 选项： 1grep -c "text" file_name 输出包含匹配字符串的行数 -n 选项： 123456grep "text" -n file_name或cat file_name | grep "text" -n#多个文件grep "text" -n file_1 file_2 打印样式匹配所位于的字符或字节偏移 1234echo gun is not unix | grep -b -o "not"7:not#一行中字符串的字符便宜是从该行的第一个字符开始计算，起始值为0。选项 -b -o 一般总是配合使用。 搜索多个文件并查找匹配文本在哪些文件中： 1grep -l "text" file1 file2 file3... grep递归搜索文件 在多级目录中对文本进行递归搜索： 12grep "text" . -r -n# .表示当前目录。 忽略匹配样式中的字符大小写： 12echo "hello world" | grep -i "HELLO"hello 选项 -e 制动多个匹配样式： 12345678910echo this is a text line | grep -e "is" -e "line" -oisline#也可以使用-f选项来匹配多个样式，在样式文件中逐行写出需要匹配的字符。cat patfileaaabbbecho aaa bbb ccc ddd eee | grep -f patfile -o 在grep搜索结果中包括或者排除指定文件： 12345678910111213141516171819202122#只在目录中所有的.php和.html文件中递归搜索字符"main()"grep "main()" . -r --include *.&#123;php,html&#125;#在搜索结果中排除所有README文件grep "main()" . -r --exclude "README"#在搜索结果中排除filelist文件列表里的文件grep "main()" . -r --exclude-from filelist使用0值字节后缀的grep与xargs：#测试文件：echo "aaa" &gt; file1echo "bbb" &gt; file2echo "aaa" &gt; file3grep "aaa" file* -lZ | xargs -0 rm#执行后会删除file1和file3，grep输出用-Z选项来指定以0值字节作为终结符文件名（\0），xargs -0 读取输入并用0值字节终结符分隔文件名，然后删除匹配文件，-Z通常和-l结合使用。grep静默输出：grep -q "test" filename#不会输出任何信息，如果命令运行成功返回0，失败则返回非0值。一般用于条件测试。 打印出匹配文本之前或者之后的行： 12345678910111213141516171819202122232425262728293031#显示匹配某个结果之后的3行，使用 -A 选项：seq 10 | grep "5" -A 35678#显示匹配某个结果之前的3行，使用 -B 选项：seq 10 | grep "5" -B 32345#显示匹配某个结果的前三行和后三行，使用 -C 选项：seq 10 | grep "5" -C 32345678#如果匹配结果有多个，会用“--”作为各匹配结果之间的分隔符：echo -e "a\nb\nc\na\nb\nc" | grep a -A 1ab--ab]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux命令</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[tar命令]]></title>
    <url>%2Fhexo-blog-deploy%2F2019%2F04%2F02%2F2019-04-linux-cmd-tar%2F</url>
    <content type="text"><![CDATA[简介tar命令可以为linux的文件和目录创建档案。利用tar，可以为某一特定文件创建档案（备份文件），也可以在档案中改变文件，或者向档案中加入新的文件。tar最初被用来在磁带上创建档案，现在，用户可以在任何设备上创建档案。利用tar命令，可以把一大堆的文件和目录全部打包成一个文件，这对于备份文件或将几个文件组合成为一个文件以便于网络传输是非常有用的。 首先要弄清两个概念：打包和压缩。 打包 是指将一大堆文件或目录变成一个总的文件； 压缩 则是将一个大的文件通过一些压缩算法变成一个小文件。 为什么要区分这两个概念呢？这源于Linux中很多压缩程序只能针对一个文件进行压缩，这样当你想要压缩一大堆文件时，你得先将这一大堆文件先打成一个包（tar命令），然后再用压缩程序进行压缩（gzip bzip2命令）。 语法1tar(选项)(参数) 选项1234567891011121314151617181920212223-A或--catenate：新增文件到以存在的备份文件；-B：设置区块大小；-c或--create：建立新的备份文件；-C &lt;目录&gt;：这个选项用在解压缩，若要在特定目录解压缩，可以使用这个选项。-d：记录文件的差别；-x或--extract或--get：从备份文件中还原文件；-t或--list：列出备份文件的内容；-z或--gzip或--ungzip：通过gzip指令处理备份文件；-Z或--compress或--uncompress：通过compress指令处理备份文件；-f&lt;备份文件&gt;或--file=&lt;备份文件&gt;：指定备份文件；-v或--verbose：显示指令执行过程；-r：添加文件到已经压缩的文件；-u：添加改变了和现有的文件到已经存在的压缩文件；-j：支持bzip2解压文件；-v：显示操作过程；-l：文件系统边界设置；-k：保留原有文件不覆盖；-m：保留文件不被覆盖；-w：确认压缩文件的正确性；-p或--same-permissions：用原来的文件权限还原文件；-P或--absolute-names：文件名使用绝对名称，不移除文件名称前的“/”号；-N &lt;日期格式&gt; 或 --newer=&lt;日期时间&gt;：只将较指定日期更新的文件保存到备份文件里；--exclude=&lt;范本样式&gt;：排除符合范本样式的文件。 参数文件或目录：指定要打包的文件或目录列表。 实例 将文件全部打包成tar包： 123tar -cvf log.tar log2012.log 仅打包，不压缩！ tar -zcvf log.tar.gz log2012.log 打包后，以 gzip 压缩 tar -jcvf log.tar.bz2 log2012.log 打包后，以 bzip2 压缩 在选项f之后的文件档名是自己取的，我们习惯上都用 .tar来作为辨识。 如果加z选项，则以.tar.gz或.tgz来代表gzip压缩过的tar包； 如果加j选项，则以.tar.bz2来作为tar包名。 查阅上述tar包内有哪些文件：1tar -ztvf log.tar.gz 由于我们使用 gzip 压缩的log.tar.gz，所以要查阅log.tar.gz包内的文件时，就得要加上z这个选项了。 将tar包解压缩：1tar -zxvf /opt/soft/test/log.tar.gz 在预设的情况下，我们可以将压缩档在任何地方解开的 只将tar内的部分文件解压出来：1tar -zxvf /opt/soft/test/log30.tar.gz log2013.log 我可以透过tar -ztvf来查阅 tar 包内的文件名称，如果单只要一个文件，就可以透过这个方式来解压部分文件！ 文件备份下来，并且保存其权限：1tar -zcvpf log31.tar.gz log2014.log log2015.log log2016.log 这个-p的属性是很重要的，尤其是当您要保留原本文件的属性时。 在文件夹当中，比某个日期新的文件才备份： 1tar -N "2012/11/13" -zcvf log17.tar.gz test 备份文件夹内容是排除部分文件： 1tar --exclude scf/service -zcvf scf.tar.gz scf/* 其实最简单的使用 tar 就只要记忆底下的方式即可： 123压 缩：tar -jcv -f filename.tar.bz2 要被压缩的文件或目录名称查 询：tar -jtv -f filename.tar.bz2解压缩：tar -jxv -f filename.tar.bz2 -C 欲解压缩的目录]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux命令</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[file命令]]></title>
    <url>%2Fhexo-blog-deploy%2F2019%2F04%2F02%2F2019-04-linux-cmd-file%2F</url>
    <content type="text"><![CDATA[简介file命令用来探测给定文件的类型。file命令对文件的检查分为文件系统、魔法幻数检查和语言检查3个过程。 语法1file(选项)(参数) 选项1234567-b：列出辨识结果时，不显示文件名称；-c：详细显示指令执行过程，便于排错或分析程序执行的情形；-f&lt;名称文件&gt;：指定名称文件，其内容有一个或多个文件名称时，让file依序辨识这些文件，格式为每列一个文件名称；-L：直接显示符号连接所指向的文件类别；-m&lt;魔法数字文件&gt;：指定魔法数字文件；-v：显示版本信息；-z：尝试去解读压缩文件的内容。 参数文件：要确定类型的文件列表，多个文件之间使用空格分开，可以使用shell通配符匹配多个文件。 实例 显示文件类型 1234567891011[root@localhost ~]# file install.loginstall.log: UTF-8 Unicode text[root@localhost ~]# file -b install.log &lt;== 不显示文件名称UTF-8 Unicode text[root@localhost ~]# file -i install.log &lt;== 显示MIME类别。install.log: text/plain; charset=utf-8[root@localhost ~]# file -b -i install.logtext/plain; charset=utf-8 显示符号链接的文件类型 1234567891011121314[root@localhost ~]# ls -l /var/maillrwxrwxrwx 1 root root 10 08-13 00:11 /var/mail -&gt; spool/mail[root@localhost ~]# file /var/mail/var/mail: symbolic link to 'spool/mail'[root@localhost ~]# file -L /var/mail/var/mail: directory[root@localhost ~]# file /var/spool/mail/var/spool/mail: directory[root@localhost ~]# file -L /var/spool/mail/var/spool/mail: directory]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux命令</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[dd命令]]></title>
    <url>%2Fhexo-blog-deploy%2F2019%2F04%2F02%2F2019-04-linux-cmd-dd%2F</url>
    <content type="text"><![CDATA[简介dd命令用于复制文件并对原文件的内容进行转换和格式化处理。dd命令功能很强大的，对于一些比较底层的问题，使用dd命令往往可以得到出人意料的效果。用的比较多的还是用dd来备份裸设备。但是不推荐 ，如果需要备份oracle裸设备，可以使用rman备份，或使用第三方软件备份，使用dd的话，管理起来不太方便。 建议在有需要的时候使用dd 对物理磁盘操作，如果是文件系统的话还是使用tar backup cpio等其他命令更加方便。另外，使用dd对磁盘操作时，最好使用块设备文件。 语法1dd(选项) 选项1234567891011bs=&lt;字节数&gt;：将ibs（输入）与欧巴桑（输出）设成指定的字节数；cbs=&lt;字节数&gt;：转换时，每次只转换指定的字节数；conv=&lt;关键字&gt;：指定文件转换的方式；count=&lt;区块数&gt;：仅读取指定的区块数；ibs=&lt;字节数&gt;：每次读取的字节数；obs=&lt;字节数&gt;：每次输出的字节数；of=&lt;文件&gt;：输出到文件；seek=&lt;区块数&gt;：一开始输出时，跳过指定的区块数；skip=&lt;区块数&gt;：一开始读取时，跳过指定的区块数；--help：帮助；--version：显示版本信息。 实例1234567[root@localhost text]# dd if=/dev/zero of=sun.txt bs=1M count=11+0 records in1+0 records out1048576 bytes (1.0 MB) copied, 0.006107 seconds, 172 MB/s[root@localhost text]# du -sh sun.txt 1.1M sun.txt 以上命令可以看出dd命令来测试内存操作速度。 该命令创建了一个1M大小的文件sun.txt，其中参数解释： if 代表输入文件。如果不指定if，默认就会从stdin中读取输入。 of 代表输出文件。如果不指定of，默认就会将stdout作为默认输出。 bs 代表字节为单位的块大小。 count 代表被复制的块数。 /dev/zero 是一个字符设备，会不断返回0值字节（\0）。 块大小可以使用的计量单位表: 单元大小 代码 字节（1B） c 字节（2B） w 块（512B） b 千字节（1024B） k 兆字节（1024KB） M 吉字节（1024MB） G]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux命令</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[learn-java-path]]></title>
    <url>%2Fhexo-blog-deploy%2F2019%2F03%2F21%2F2019-03-learn-java-path%2F</url>
    <content type="text"><![CDATA[java编程语法 java编程思想学习笔记 基础语法 深入理解jvm 常用包、类、包 java数组 异常处理 反射 java集合 java 多线程 java IO操作 jdbc Maven权限管理 Shiro spring全家桶 spring framework spring boot spring cloud 整合docker 整合k8s]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[rm命令]]></title>
    <url>%2Fhexo-blog-deploy%2F2019%2F03%2F21%2F2019-03-linux-cmd-rm%2F</url>
    <content type="text"><![CDATA[简介rm命令可以删除一个目录中的一个或多个文件或目录，也可以将某个目录及其下属的所有文件及其子目录均删除掉。对于链接文件，只是删除整个链接文件，而原有文件保持不变。 注意：使用rm命令要格外小心。因为一旦删除了一个文件，就无法再恢复它。所以，在删除文件之前，最好再看一下文件的内容，确定是否真要删除。rm命令可以用-i选项，这个选项在使用文件扩展名字符删除多个文件时特别有用。使用这个选项，系统会要求你逐一确定是否要删除。这时，必须输入y并按Enter键，才能删除文件。如果仅按Enter键或其他字符，文件不会被删除。 语法1rm (选项)(参数) 选项123456-d：直接把欲删除的目录的硬连接数据删除成0，删除该目录；-f：强制删除文件或目录；-i：删除已有文件或目录之前先询问用户；-r或-R：递归处理，将指定目录下的所有文件与子目录一并处理；--preserve-root：不对根目录进行递归操作；-v：显示指令的详细执行过程。 参数文件：指定被删除的文件列表，如果参数中含有目录，则必须加上-r或者-R选项。 实例交互式删除当前目录下的文件test和example123rm -i test exampleRemove test ?n（不删除文件test)Remove example ?y（删除文件example) 删除当前目录下除隐含文件外的所有文件和子目录12$ rm -r * #应注意，这样做是非常危险的!]]></content>
  </entry>
  <entry>
    <title><![CDATA[mv命令]]></title>
    <url>%2Fhexo-blog-deploy%2F2019%2F03%2F21%2F2019-03-linux-cmd-mv%2F</url>
    <content type="text"><![CDATA[简介mv命令的作用: 对文件或目录重新命名 将文件从一个目录移到另一个目录中。source表示源文件或目录，target表示目标文件或目录。如果将一个文件移到一个已经存在的目标文件中，则目标文件的内容将被覆盖。 mv命令可以用来将源文件移至一个目标文件中，或将一组文件移至一个目标目录中。源文件被移至目标文件有两种不同的结果： 如果目标文件是到某一目录文件的路径，源文件会被移到此目录下，且文件名不变。 如果目标文件不是目录文件，则源文件名（只能有一个）会变为此目标文件名，并覆盖己存在的同名文件。如果源文件和目标文件在同一个目录下，mv的作用就是改文件名。当目标文件是目录文件时，源文件或目录参数可以有多个，则所有的源文件都会被移至目标文件中。所有移到该目录下的文件都将保留以前的文件名。 语法1mv(选项)(参数) 选项12345678--backup=&lt;备份模式&gt;：若需覆盖文件，则覆盖前先行备份；-b：当文件存在时，覆盖前，为其创建一个备份；-f：若目标文件或目录与现有的文件或目录重复，则直接覆盖现有的文件或目录；-i：交互式操作，覆盖前先行询问用户，如果源文件与目标文件或目标目录中的文件同名，则询问用户是否覆盖目标文件。用户输入”y”，表示将覆盖目标文件；输入”n”，表示取消对源文件的移动。这样可以避免误将文件覆盖。--strip-trailing-slashes：删除源文件中的斜杠“/”；-S&lt;后缀&gt;：为备份文件指定后缀，而不使用默认的后缀；--target-directory=&lt;目录&gt;：指定源文件要移动到目标目录；-u：当源文件比目标文件新或者目标文件不存在时，才执行移动操作。 参数 源文件：源文件列表。 目标文件：如果目标文件是文件名则在移动文件的同时，将其改名为目标文件；如果目标文件是目录名则将源文件移动到目标文件下。 实例将文件ex3改名为new11mv ex3 new1 将目录/usr/men中的所有文件移到当前目录（用.表示）中：1mv /usr/men/* .]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux命令</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java编程思想学习笔记七：访问权限控制]]></title>
    <url>%2Fhexo-blog-deploy%2F2019%2F03%2F21%2F2019-03-think-in-java-7%2F</url>
    <content type="text"><![CDATA[访问权限控简介在重构修改的过程中，如果是一个类库编写人员，那么怎么样保证自己修改的部分不会影响到客户端编写人员（即使用这个类库的程序员）呢？同时也要避免他们对自己类库内部的程序进行改动。Java中提供了访问权限控制的概念，提供了三种不同级别的访问控制，访问开放程度由高到低依次为public、protected、private，这样就能区分哪些内容是可用的，哪些内容是不可用的，从而将变动的事物与不变的事物区分开来。 那么如何将所有的构建捆绑到一个内聚的类库单元中呢？Java提供了package加以控制，而访问权限控制的作用会因为类库是否在一个相同的package还是不同的package受到影响。 包：库单元包内包含一组类，它们在单一的名字空间下被组织在了一起。声明一个类所属的包使用package关键字，同时在另一个包中的类要访问其它包中的类使用import关键字导入要使用的包。这种方式可以在一定程度上避免重名的问题，因为包的名字要避免重名，而不同包内的类是可以根据具体的需求命相同的名字。包有效的将不同类的内容进行了隔离，同时也可以相互联系。 不同包的两个同名类，同时导入一个类是报错，怎么办?导入一个，另外一个用全路径访问。 Java访问权限修饰词 public：所有可见，被public修饰的内容在同一个包中的所有类都可见。同时Java提供默认的访问权限，即不被任何修饰符修饰的内容默认为public权限。 private：私有可见，只有该类可见，该类的对象都不可见。如果一个类的构造函数被声明为private，那么就不能通过这个类的构造函数来进行初始化对象。 protected:受保护的可见，与private不同，除了只有自己的类可见之外，该类的继承者也可见被修饰的域。除此之外还可以被当前包的类访问，但是其它包的类不可以访问，即便是使用了import的关键字。 访问权限控制对程序结构控制的重要手段。 接口和实现一般的类开发者，为了方便他人使用，会在具体方法实现外部建立一层接口，只提供接口给外部开发人员调用，而不提供具体实现的方法。 类的访问权限在Java中，访问权限控制也可以确定包中的哪些类可以被访问，也就是说可以用来修饰类，一个文件中最多只能有一个使用 public修饰的类。如果希望客户端程序员使用该类，并可以创建对象，那么就可以将该类修饰为public。并且被修饰为public的类必须要与该文件的名字完全相同。 总结本章主要学习的是Java中的三种访问权限，熟练的掌握public、private和protected三种类型的概念以及应用场景将能更好的提高程序的健壮性和稳定性]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>java编程思想</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring中@Component与@Bean的区别]]></title>
    <url>%2Fhexo-blog-deploy%2F2019%2F03%2F21%2F2019-03-spring-component-and-bean-distinction%2F</url>
    <content type="text"><![CDATA[作用@Component注解表明一个类会作为组件类，并告知Spring要为这个类创建bean。 @Bean注解告诉Spring这个方法将会返回一个对象，这个对象要注册为Spring应用上下文中的bean。通常方法体中包含了最终产生bean实例的逻辑。 @Bean@Bean与配置类（使用@Configuration）一起工作，因此使用在基于配置中。也可用在配置类的方法中。告诉Spring将方法返回的任何内容添加到Spring Context中。 默认情况下，它将使用方法的名称作为bean的id / name（类似XML配置：bean id=xxxx）。另一种方法是，您可以在@Bean注释中指定它。 我们明确声明了bean。 @Component@Component用于我们的类，它只有在我们的SpringBoot应用程序启用了组件扫描并且包含了我们的类时才有效。 通过组件扫描，Spring将扫描整个类路径，并将所有@Component注释类添加到Spring Context（具有可调整的Filtering）。 我们让Spring发现了bean 区别两个注释的结果是相同的，bean都会被添加到Spring上下文中。但是，有一些问题需要注意。 假设我们有一个需要在多个应用程序中共享的模块，这个模块包含了一些服务，但并非所有应用都需要这些服务。 如果在这些服务类上使用@Component并在应用程序中使用组件扫描，我们最终可能会检测到超过必要的bean数量，不需要的Bean也扫描加载了。这时候必须调整组件扫描的过滤或提供即使未使用的bean也可以运行的配置，否则，Spring应用程序上下文将无法启动。 在这种情况下，最好使用@Bean注释并仅实例化那些在每个应用程序中单独需要的bean。]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>spring framework</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[cp命令]]></title>
    <url>%2Fhexo-blog-deploy%2F2019%2F03%2F19%2F2019-03-linux-cmd-cp%2F</url>
    <content type="text"><![CDATA[简介cp命令用来将一个或多个源文件或者目录复制到指定的目的文件或目录。它可以将单个源文件复制成一个指定文件名的具体的文件或一个已经存在的目录下。cp命令还支持同时复制多个文件，当一次复制多个文件时，目标文件参数必须是一个已经存在的目录，否则将出现错误。 语法1cp(选项)(参数) 选项123456789101112-a：此参数的效果和同时指定"-dpR"参数相同；-d：当复制符号连接时，把目标文件或目录也建立为符号连接，并指向与源文件或目录连接的原始文件或目录；-f：强行复制文件或目录，不论目标文件或目录是否已存在；-i：覆盖既有文件之前先询问用户；-l：对源文件建立硬连接，而非复制文件；-p：保留源文件或目录的属性；-R/r：递归处理，将指定目录下的所有文件与子目录一并处理；-s：对源文件建立符号连接，而非复制文件；-u：使用这项参数后只会在源文件的更改时间较目标文件更新时或是名称相互对应的目标文件并不存在时，才复制文件；-S：在备份文件时，用指定的后缀“SUFFIX”代替文件的默认后缀；-b：覆盖已存在的文件目标前将目标文件备份；-v：详细显示命令执行的操作。 参数 源文件：制定源文件列表。默认情况下，cp命令不能复制目录，如果要复制目录，则必须使用-R选项； 目标文件：指定目标文件。当“源文件”为多个文件时，要求“目标文件”为指定的目录。 实例如果把一个文件复制到一个目标文件中，而目标文件已经存在，那么，该目标文件的内容将被破坏。此命令中所有参数既可以是绝对路径名，也可以是相对路径名。通常会用到点.或点点..的形式。例如，下面的命令将指定文件复制到当前目录下： 1cp ../mary/homework/assign . 所有目标文件指定的目录必须是己经存在的，cp命令不能创建目录。如果没有文件复制的权限，则系统会显示出错信息。 将文件file复制到目录/usr/men/tmp下，并改名为file11cp file /usr/men/tmp/file1 将目录/usr/men下的所有文件及其子目录复制到目录/usr/zh中1cp -r /usr/men /usr/zh 交互式地将目录/usr/men中的以m打头的所有.c文件复制到目录/usr/zh中1cp -i /usr/men m*.c /usr/zh 我们在Linux下使用cp命令复制文件时候，有时候会需要覆盖一些同名文件，覆盖文件的时候都会有提示：需要不停的按Y来确定执行覆盖。文件数量不多还好，但是要是几百个估计按Y都要吐血了，于是折腾来半天总结了一个方法：1cp aaa/* /bbb 复制目录aaa下所有到/bbb目录下，这时如果/bbb目录下有和aaa同名的文件，需要按Y来确认并且会略过aaa目录下的子目录。1cp -r aaa/* /bbb 这次依然需要按Y来确认操作，但是没有忽略子目录。1cp -r -a aaa/* /bbb 依然需要按Y来确认操作，并且把aaa目录以及子目录和文件属性也传递到了/bbb。1\cp -r -a aaa/* /bbb 成功，没有提示按Y、传递了目录属性、没有略过目录。]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux命令</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[mkdir命令]]></title>
    <url>%2Fhexo-blog-deploy%2F2019%2F03%2F17%2F2019-03-linux-cmd-mkdir%2F</url>
    <content type="text"><![CDATA[简介mkdir命令用来创建目录。该命令创建由dirname命名的目录。如果在目录名的前面没有加任何路径名，则在当前目录下创建由dirname指定的目录；如果给出了一个已经存在的路径，将会在该目录下创建一个指定的目录。在创建目录时，应保证新建的目录与它所在目录下的文件没有重名。 注意在创建文件时，不要把所有的文件都存放在主目录中，可以创建子目录，通过它们来更有效地组织文件。最好采用前后一致的命名方式来区分文件和目录。例如，目录名可以以大写字母开头，这样，在目录列表中目录名就出现在前面。 在一个子目录中应包含类型相似或用途相近的文件。例如，应建立一个子目录，它包含所有的数据库文件，另有一个子目录应包含电子表格文件，还有一个子目录应包含文字处理文档，等等。目录也是文件，它们和普通文件一样遵循相同的命名规则，并且利用全路径可以唯一地指定一个目录。 语法1mkdir (选项)(参数) 选项1234-Z：设置安全上下文，当使用SELinux时有效；-m&lt;目标属性&gt;或--mode&lt;目标属性&gt;建立目录的同时设置目录的权限；-p或--parents 若所要建立目录的上层目录目前尚未建立，则会一并建立上层目录；--version 显示版本信息。 参数目录：指定要创建的目录列表，多个目录之间用空格隔开。 实例在目录/usr/meng下建立子目录test，并且只有文件主有读、写和执行权限，其他人无权访问1mkdir -m 700 /usr/meng/test 在当前目录中建立bin和bin下的os_1目录，权限设置为文件主可读、写、执行，同组用户可读和执行，其他用户无权访问1mkdir -p-m 750 bin/os_1]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux命令</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[touch命令]]></title>
    <url>%2Fhexo-blog-deploy%2F2019%2F03%2F17%2F2019-03-linux-cmd-touch%2F</url>
    <content type="text"><![CDATA[简介touch命令有两个功能： 用于把已存在文件的时间标签更新为系统当前的时间（默认方式），它们的数据将原封不动地保留下来； 用来创建新的空文件。 语法1touch(选项)(参数) 选项123456789-a：或--time=atime或--time=access或--time=use 只更改存取时间；-c：或--no-create 不建立任何文件；-d：&lt;时间日期&gt; 使用指定的日期时间，而非现在的时间；-f：此参数将忽略不予处理，仅负责解决BSD版本touch指令的兼容性问题；-m：或--time=mtime或--time=modify 只更该变动时间；-r：&lt;参考文件或目录&gt; 把指定文件或目录的日期时间，统统设成和参考文件或目录的日期时间相同；-t：&lt;日期时间&gt; 使用指定的日期时间，而非现在的时间；--help：在线帮助；--version：显示版本信息。 参数文件：指定要设置时间属性的文件列表。 实例1touch ex2 在当前目录下建立一个空文件ex2，然后，利用ls -l命令可以发现文件ex2的大小为0，表示它是空文件。]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux命令</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java编程思想学习笔记：初始化与清理]]></title>
    <url>%2Fhexo-blog-deploy%2F2019%2F03%2F17%2F2019-03-think-in-java-6%2F</url>
    <content type="text"><![CDATA[使用构造器确保初始化Java中通过提供构造器，确保每个类的对象都可以得到初始化，构造器的形式为： 在类的内部定义的一个与类名相同的方法，该方法没有返回值，没有返回值并不是返回void，而是真正的无返回值。该方法在对象创建时会自动执行。 123className（）&#123; //---&#125; 案例: 案例11234567891011package com.chenxyt.java.practice;public class ConstructorTest&#123; ConstructorTest()&#123; System.out.println("Constructor Begin"); &#125; public static void main(String[] args) &#123; for(int i=0;i&lt;5;i++)&#123; ConstructorTest ct = new ConstructorTest(); &#125; &#125;&#125; 可以显示的编写有参的构造方法，给类的成员变量赋值1234567891011121314package com.chenxyt.java.practice;public class ConstructorTest&#123; private int age; ConstructorTest(int i)&#123; age=i; &#125; public static void main(String[] args) &#123; for(int i=0;i&lt;5;i++)&#123; ConstructorTest ct = new ConstructorTest(i); System.out.println("Age=" + ct.age); &#125; &#125;&#125; Notes如果类中只有唯一的一个带参数的构造器，那么默认的无参构造器将不可用。 方法重载假如我们有多种多样的需求，想要初始化不同形态的对象，这时候我们可能需要多个构造器才能满足需求。而构造器的名字又是固定的，所以这个时候变化的就是参数类型或者是参数个数。我们把这种方法名不变，只改变参数类型或者参数个数的操作叫做方法重载。方法重载不仅支持构造器方法重载，也支持普通方法的重载。 12345678910111213141516171819202122232425262728293031323334353637package com.chenxyt.java.practice;public class ConstructorTest&#123; private int age; private String name; ConstructorTest()&#123; &#125; ConstructorTest(int i)&#123; age=i; &#125; ConstructorTest(String j)&#123; name=j; &#125; ConstructorTest(int i,String j)&#123; age=i; name=j; &#125; public static void main(String[] args) &#123; ConstructorTest ct1 = new ConstructorTest(); ConstructorTest ct2 = new ConstructorTest(22); ConstructorTest ct3 = new ConstructorTest("张三"); ConstructorTest ct4 = new ConstructorTest(23,"李四"); System.out.println("ct1 age=" + ct1.age + "---name=" + ct1.name); System.out.println("ct2 age=" + ct2.age + "---name=" + ct2.name); System.out.println("ct3 age=" + ct3.age + "---name=" + ct3.name); System.out.println("ct4 age=" + ct4.age + "---name=" + ct4.name); &#125;&#125;//输出// ct1 age=0---name=null// ct2 age=22---name=null// ct3 age=0---name=张三// ct4 age=23---name=李四//说明//四个不同的构造函数初始化了四个不同的对象，可以从打印结果看出，没有初始化的值int类型为0，String类型为null。 缺省构造器如前文所述，默认的构造器，就是没有形参的构造器，作为一个类的缺省构造器。如果程序员没有显示的在代码中创建一个构造器，那么Java会自动帮你创建一个无参构造器来完成初始化。当然如果程序员显示的创建了构造函数，那么Java就不会给你创建缺省构造器了。 this关键字表示类的当前对象的引用12345678package com.chenxyt.java.practice;public class ThisTest&#123; public ThisTest doFunc()&#123; return this; &#125; public static void main(String[] args) &#123; ThisTest tt = new ThisTest().doFunc(); &#125; 表示类的成员变量12345678910111213package com.chenxyt.java.practice;public class ThisTest&#123; private String arg; ThisTest(String arg)&#123; this.arg = arg; //此处this.arg表明了这个变量是成员变量，与构造方法的形参做了区分。 &#125; public static void main(String[] args) &#123; ThisTest tt = new ThisTest("嘻嘻"); System.out.println(tt.arg); &#125;&#125;// 输出// 嘻嘻 在构造器中调用另一个构造器，使用this带参数代替构造器的方法名1234567891011121314151617package com.chenxyt.java.practice;public class ThisTest&#123; ThisTest(int i,String j)&#123; this(j); System.out.println("我是构造器1"); &#125; ThisTest(String arg)&#123; System.out.println("我是构造器2"); &#125; public static void main(String[] args) &#123; ThisTest tt = new ThisTest(2,"嘻嘻"); &#125;&#125;//输出// 我是构造器2// 我是构造器1 清理：终结处理和垃圾回收Java中的内存清理使用的是Java自带的垃圾回收机制，但是不管怎么来说，这种方式都不是绝对安全的。Java的垃圾回收机制清理的是通过new创建的对象，而在某些特殊情况下，可能有些对象不是通过new创建的，这些对象如果不使用的时候，垃圾回收器是不能准确的清理他们的从而造成了这块特殊的内存区域一直得不到释放。 Java中提供了finalize()方法来处理这一部分特殊的内存区域。它的处理流程是这样的，在Java垃圾回收器启用之前，会先调用这个方法进行一些必要的回收操作。但是针对这一块特殊的区域，或者是new创建的需要被回收的对象，一般情况下只有当Java虚拟机内存快要消耗殆尽的时候，垃圾回收器才会启动，毕竟启动垃圾回收器也是需要消耗资源的，所以不可能说实时存在。所说的特殊的创建对象方式，一般是指“本地方法”使用时，也就是在Java中调用非Java代码的时候发生的。所以一般情况下是不需要使用finalize()方法的。 finalize() 通常还有另一个用法，由于它是在Java垃圾回收器启动之前执行的，所以可以用它来判断终结状态，即判断一个对象是否满足回收条件。 成员初始化Java尽量保证每个变量在使用之前都进行了初始化操作，变量分为局部变量和成员变量，局部变量如果没有显示的初始化，在使用它的时候会报错，而成员变量不会，如果没有显示的初始化一个成员变量，那么它会被默认的分配一个指定的值。 构造器初始化如前边对构造器的阐述，可以使用构造器来初始化类的成员变量，当对象被实例化之后，对象的成员变量会被初始化。静态成员变量只有在第一次使用它是才会被初始化，后边再次用到时不会被初始化。初始化顺序为创建对象时，先初始化这个类的静态变量，然后在堆上为这个对象分配内存，最后执行构造函数。 数组初始化数据是一系列相同数据类型封装起来的序列，它的初始化可以发生在任何时候，int[] a1表示一个int类型的数组，这个数组内部所有的值都是int类型，a1只是这个数组的一个引用，可以显示的通过如int[] a1={1，2，3};的形式进行初始化。如果不能确定数组的内容或者是长度，则可以通过new的形式来创建一个数组。int[] a = new int[20];这种创建也只是创建了一个引用数组，直到数组中的每一个字段都有确切的值了，初始化才真正的完成。如a[1]=3; 使用数组我们可以构建一个变参的函数，就是当方法的参数类型和个数都不确定的时候，我们可以使用一个数组作为形参。因为Object类是所有类型的父类，所以这个形参数组的类型就是Obejct类，对于基本数据类型，因为都有对应的包装类，所以也可以转换成Obejct类进行使用。 1234567891011121314151617181920212223242526package com.chenxyt.java.practice;public class DifArgTest&#123; public static void printArray(Object[] args)&#123; for(Object obj:args)&#123; System.out.print(obj + ""); &#125; &#125; public static void main(String[] args) &#123; DifArgTest.printArray(new Object[]&#123;"我今年",new Integer(24),"岁！"&#125;); &#125;&#125;// 输出// 我今年24岁package com.chenxyt.java.practice;public class DifArgTest&#123; public static void printArray(Object...args)&#123; for(Object obj:args)&#123; System.out.print(obj + ""); &#125; &#125; public static void main(String[] args) &#123; DifArgTest.printArray("我","今年",24,"岁"); &#125;&#125; 枚举类型1234567891011package com.chenxyt.java.practice;public class EnumTest&#123; public enum EnumSet&#123; FIRST,SECOND,THIRD &#125; public static void main(String[] args) &#123; EnumSet es = EnumSet.FIRST; System.out.println(es); &#125; &#125;// 创建一个枚举类型，类型内部的实例值是常量，因此按照通用的命名规范进行大写。同时需要使用枚举时，可以初始化一个引用然后进行赋值 当我们创建枚举的时候编译器会自动为我们添加一些有用的特性，我觉得这是与其它语言相比更加完备的地方，比如它会创建一个toString()方法，这也就是为什么我们上边可以使用syso打印出来。编译器还会创建ordinal()方法，用来表示特定enum常量的声明顺序，以及一个static values()方法，该方法是一个静态的方法可以通过enum名字进行访问，方法的作用是按照enmu的声明顺序，产生一个由enum常量值组成的数组。 123456789101112131415package com.chenxyt.java.practice;public class EnumTest&#123; public enum EnumSet&#123; FIRST,SECOND,THIRD &#125; public static void main(String[] args) &#123; for(EnumSet et:EnumSet.values())&#123; System.out.println("value is:" + et + "---ordinal is:" + et.ordinal()); &#125; &#125; &#125;//输出// value is:FIRST---ordinal is:0"// value is:SECOND---ordinal is:1"// value is:THIRD---ordinal is:2" enum看起来像是一种新的数据类型，但是实际上enum是一个类，并且具有自己的方法。除了上边的特性之外，enum还有个更加实用的特性，由于它是一个常量集，因此可以和switch语句完美匹配。 总结本章在Java中占有了至关重要的作用，也可以说初始化比较重要。总的来说要掌握如何进行初始化，方法的重载，重载不仅发生在构造方法中，也可以发生在普通方法。this关键的使用可以说很重要，但是便于理解。垃圾回收以及枚举只是初步的了解了一下，后续还会单独进行学习。]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>java编程思想</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[diff命令]]></title>
    <url>%2Fhexo-blog-deploy%2F2019%2F03%2F16%2F2019-03-linux-cmd-diff%2F</url>
    <content type="text"><![CDATA[简介diff命令在最简单的情况下，比较给定的两个文件的不同。如果使用-代替文件参数，则要比较的内容将来自标准输入。diff命令是以逐行的方式，比较文本文件的异同处。如果该命令指定进行目录的比较，则将会比较该目录中具有相同文件名的文件，而不会对其子目录文件进行任何比较操作。 语法1diff(选项)(参数) 选项12345678910111213141516171819202122232425262728293031323334-&lt;行数&gt;：指定要显示多少行的文本。此参数必须与-c或-u参数一并使用；-a或——text：diff预设只会逐行比较文本文件；-b或--ignore-space-change：不检查空格字符的不同；-B或--ignore-blank-lines：不检查空白行；-c：显示全部内容，并标出不同之处；-C&lt;行数&gt;或--context&lt;行数&gt;：与执行“-c-&lt;行数&gt;”指令相同；-d或——minimal：使用不同的演算法，以小的单位来做比较；-D&lt;巨集名称&gt;或ifdef&lt;巨集名称&gt;：此参数的输出格式可用于前置处理器巨集；-e或——ed：此参数的输出格式可用于ed的script文件；-f或-forward-ed：输出的格式类似ed的script文件，但按照原来文件的顺序来显示不同处；-H或--speed-large-files：比较大文件时，可加快速度；-l&lt;字符或字符串&gt;或--ignore-matching-lines&lt;字符或字符串&gt;：若两个文件在某几行有所不同，而之际航同时都包含了选项中指定的字符或字符串，则不显示这两个文件的差异；-i或--ignore-case：不检查大小写的不同；-l或——paginate：将结果交由pr程序来分页；-n或——rcs：将比较结果以RCS的格式来显示；-N或--new-file：在比较目录时，若文件A仅出现在某个目录中，预设会显示：Only in目录，文件A 若使用-N参数，则diff会将文件A 与一个空白的文件比较；-p：若比较的文件为C语言的程序码文件时，显示差异所在的函数名称；-P或--unidirectional-new-file：与-N类似，但只有当第二个目录包含了第一个目录所没有的文件时，才会将这个文件与空白的文件做比较；-q或--brief：仅显示有无差异，不显示详细的信息；-r或——recursive：比较子目录中的文件；-s或--report-identical-files：若没有发现任何差异，仍然显示信息；-S&lt;文件&gt;或--starting-file&lt;文件&gt;：在比较目录时，从指定的文件开始比较；-t或--expand-tabs：在输出时，将tab字符展开；-T或--initial-tab：在每行前面加上tab字符以便对齐；-u，-U&lt;列数&gt;或--unified=&lt;列数&gt;：以合并的方式来显示文件内容的不同；-v或——version：显示版本信息；-w或--ignore-all-space：忽略全部的空格字符；-W&lt;宽度&gt;或--width&lt;宽度&gt;：在使用-y参数时，指定栏宽；-x&lt;文件名或目录&gt;或--exclude&lt;文件名或目录&gt;：不比较选项中所指定的文件或目录；-X&lt;文件&gt;或--exclude-from&lt;文件&gt;；您可以将文件或目录类型存成文本文件，然后在=&lt;文件&gt;中指定此文本文件；-y或--side-by-side：以并列的方式显示文件的异同之处；--help：显示帮助；--left-column：在使用-y参数时，若两个文件某一行内容相同，则仅在左侧的栏位显示该行内容；--suppress-common-lines：在使用-y参数时，仅显示不同之处。 参数 文件1：指定要比较的第一个文件； 文件2：指定要比较的第二个文件 实例将目录/usr/li下的文件”test.txt”与当前目录下的文件”test.txt”进行比较，输入如下命令：12345diff /usr/li test.txt #使用diff指令对文件进行比较# 上面的命令执行后，会将比较后的不同之处以指定的形式列出，如下所示：n1 a n3,n4 n1,n2 d n3 n1,n2 c n3,n4 其中，字母”a”、”d”、”c”分别表示添加、删除及修改操作。而”n1”、”n2”表示在文件1中的行号，”n3”、”n4”表示在文件2中的行号。 Notes以上说明指定了两个文件中不同处的行号及其相应的操作。在输出形式中，每一行后面将跟随受到影响的若干行。其中，以&lt;开始的行属于文件1，以&gt;开始的行属于文件2。]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux命令</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java编程思想学习笔记五：控制执行流程]]></title>
    <url>%2Fhexo-blog-deploy%2F2019%2F03%2F16%2F2019-03-think-in-java-5%2F</url>
    <content type="text"><![CDATA[true和false关系操作符构造的条件语句如==的返回值是true和false，Java中不允许将一个数字作为布尔值使用。 if-elseif else语句与其它语言的相同，其中else是可选的。if else用来实现多种条件下的执行。 迭代while、do-while、for用来控制循环，有时候将他们称为迭代语句。语句会重复执行，直到起控制作用的布尔值得到“假”的结果时停止。 for-eachfor-each是一种更加简洁的for语句，语法如下：1234for(int i:x) &#123; //---&#125;// x是要被访问的循环体，i是一个变量，类型int只是一种，具体的类型要与x内部的值的类型相同，这个语句的意思就是循环取x内部的值赋值给i returnreturn关键字有两个用途: 一方面指定一个方法返回什么值 另一方面它会强制结束当前方法，并返回那个值。 break和continue 在任何迭代语句的主体部分，都可以用break和continue控制循环的流程，其中break用于强制退出循环，不执行循环剩余的语句，比如一共五组数据循环到第三组break，那么后面两组不管了继续执行下边的数据。continue是停止当前的迭代，退到循环开始执行下一次迭代，比如一共五组数据执行到第三组开始的时候continue，那么这个循环体主体剩余的部分不执行，继续从第四组开始执行。 臭名昭著的go-togo-to语句会破坏代码的逻辑结构，降低代码的可读性。因此不建议使用。 switchswitch也被划为一种选择语句，根据整数表达式的值，从一系列语句中选择一组执行。语法如下：12345678910switch(a)&#123; case value1: //---; break; case value2: //---; break; default: //---;&#125; 总结文中多数控制语句在其它语言中都通用，注意for-each语句的使用。]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>java编程思想</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[cut命令]]></title>
    <url>%2Fhexo-blog-deploy%2F2019%2F03%2F15%2F2019-03-linux-cmd-cut%2F</url>
    <content type="text"><![CDATA[简介cut命令用来显示行中的指定部分，删除文件中指定字段。cut经常用来显示文件的内容，类似于下的type命令。 说明：该命令有两项功能，其一是用来显示文件的内容，它依次读取由参数file所指 明的文件，将它们的内容输出到标准输出上；其二是连接两个或多个文件，如cut fl f2 &gt; f3将把文件fl和几的内容合并起来，然后通过输出重定向符&gt;的作用，将它们放入文件f3中。 当文件较大时，文本在屏幕上迅速闪过（滚屏），用户往往看不清所显示的内容。因此，一般用more等命令分屏显示。为了控制滚屏，可以按Ctrl+S键，停止滚屏；按Ctrl+Q键可以恢复滚屏。按Ctrl+C（中断）键可以终止该命令的执行，并且返回Shell提示符状态。 语法1cut(选项)(参数) 选项123456789-b：仅显示行中指定直接范围的内容；-c：仅显示行中指定范围的字符；-d：指定字段的分隔符，默认的字段分隔符为“TAB”；-f：显示指定字段的内容；-n：与“-b”选项连用，不分割多字节字符；--complement：补足被选择的字节、字符或字段；--out-delimiter=&lt;字段分隔符&gt;：指定输出内容是的字段分割符；--help：显示指令的帮助信息；--version：显示指令的版本信息。 参数文件：指定要进行内容过滤的文件。 实例123456# 存在如下test.txt文本[root@localhost text]# cat test.txt No Name Mark Percent01 tom 69 9102 jack 71 8703 alex 68 98 使用 -f 选项提取指定字段：1234567891011[root@localhost text]# cut -f 1 test.txt No010203[root@localhost text]# cut -f2,3 test.txt Name Marktom 69jack 71alex 68 –complement 选项提取指定字段之外的列（打印除了第二列之外的列）：12345[root@localhost text]# cut -f2 --complement test.txt No Mark Percent01 69 9102 71 8703 68 98 使用 -d 选项指定字段分隔符：123456# 存在test2.txt文本[root@localhost text]# cat test2.txt No;Name;Mark;Percent01;tom;69;9102;jack;71;8703;alex;68;98 12345[root@localhost text]# cut -f2 -d";" test2.txt Nametomjackalex 指定字段的字符或者字节范围cut命令可以将一串字符作为列来显示，字符字段的记法： N-：从第N个字节、字符、字段到结尾； N-M：从第N个字节、字符、字段到第M个（包括M在内）字节、字符、字段； -M：从第1个字节、字符、字段到第M个（包括M在内）字节、字符、字段。 上面是记法，结合下面选项将摸个范围的字节、字符指定为字段： -b 表示字节； -c 表示字符； -f 表示定义字段。 示例123456[root@localhost text]# cat test.txt abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz 打印第1个到第3个字符：123456[root@localhost text]# cut -c1-3 test.txt abcabcabcabcabc 打印前2个字符：123456[root@localhost text]# cut -c-2 test.txt ababababab 打印从第5个字符开始到结尾：123456[root@localhost text]# cut -c5- test.txt efghijklmnopqrstuvwxyzefghijklmnopqrstuvwxyzefghijklmnopqrstuvwxyzefghijklmnopqrstuvwxyzefghijklmnopqrstuvwxyz]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux命令</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[stat命令]]></title>
    <url>%2Fhexo-blog-deploy%2F2019%2F03%2F15%2F2019-03-linux-cmd-stat%2F</url>
    <content type="text"><![CDATA[简介stat命令用于显示文件的状态信息。stat命令的输出信息比ls命令的输出信息要更详细。 语法1stat(选项)(参数) 选项12345-L：支持符号连接；-f：显示文件系统状态而非文件状态；-t：以简洁方式输出信息；--help：显示指令的帮助信息；--version：显示指令的版本信息。 参数文件：指定要显示信息的普通文件或者文件系统对应的设备文件名。 实例123456789101112131415161718192021[root@localhost ~]# ls -l myfile-rw-r--r-- 1 root root 0 2010-10-09 myfile[root@localhost ~]# stat myfilefile: “myfile”Size: 0 Blocks: 8 IO Block: 4096 一般空文件Device: fd00h/64768d Inode: 194805815 Links: 1Access: (0644/-rw-r--r--) Uid: ( 0/ root) Gid: ( 0/ root)Access: 2010-12-12 12:22:35.000000000 +0800Modify: 2010-10-09 20:44:21.000000000 +0800Change: 2010-10-09 20:44:21.000000000 +0800[root@localhost ~]# stat -f myfileFile: "myfile"id: 0 Namelen: 255 type: ext2/ext3Block size: 4096 Fundamental block size: 4096Blocks: Total: 241555461 free: 232910771 Available: 220442547Inodes: Total: 249364480 Free: 249139691[root@localhost ~]# stat -t myfilemyfile 0 8 81a4 0 0 fd00 194805815 1 0 0 1292127755 1286628261 1286628261 4096]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux命令</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java编程思想学习笔记四:操作符]]></title>
    <url>%2Fhexo-blog-deploy%2F2019%2F03%2F15%2F2019-03-think-in-java-4%2F</url>
    <content type="text"><![CDATA[实现更新简单的打印语句12//打印语句System.out.println("Hello World"); 结合上一篇学习static的文章可知，打印语句如果在一个类中多次调用的时候，我们可以把这个语句抽出来写成静态方法，然后通过导入静态包的方式调用这个打印方法。 test包下的Printer类： 123456789101112131415package com.chenxyt.java.test;public class Printer &#123; public static void print(String msg)&#123; System.out.println(msg); &#125;&#125;//practice包下的TestStatic类：package com.chenxyt.java.practice;import static com.chenxyt.java.test.Printer.*;public class TestStatic&#123; public static void main(String[] args) &#123; print("This is TestStatic"); &#125;&#125; java操作符Java与其他语言一样，支持加号，正号，减号，负号，乘除号等操作符，同时=，==和！=不光可以操作基本操作类型，还可以操作所有的对象。此外，String类支持+和+=。 优先级当一个表达式中存在多个操作符时，操作符的优先级就尤为重要了，它决定了程序运算操作执行的先后顺序。Java中的计算顺序与其它语言的基本相同，先计算乘除，再计算加减，有括号的先计算括号里边的。System.out.println()语句中包含+的操作符号，简单的只是进行字符串的连接，复杂一点的就是当编译器发现+前边是一个String类型，会尝试将+后面的内容转换成String类型。 赋值赋值操作使用的是=操作符，将=右边的值赋给左边，右值可以是任意的常数、变量或者是表达式，只有它能生成一个值即可，而左值必须是一个明确的已命名的变量，就是必须要有个物理空间来进行存储。比如，可以将一个常数赋给变量。 123a=4;//但是却不能将一个变量赋值给一个常数4=a; //这个是错误的 基本数据类型的赋值对于基本的数据类型，赋值操作没有引用的涉及，只是单纯的将一个值赋值给另一个值。例如a=b，当b再次被修改时，a不会受到影响，因为a与b相互独立。 对象的赋值于对对象的赋值来说，情况却大大不同，因为我们对对象的操作是操作了对象的引用，所以当一个对象赋值给另一个对象时，实际上是拷贝了引用到左值，也就是比如c和d是指向两个不同对象的引用，当c=d时，实际发生的情况是c和d都指向了原本只有d指向的对象。而c被赋值之后，原来的引用丢失了，它曾经所指向的不再被引用的对象被垃圾回收器回收了。 12345678910111213141516171819package com.chenxyt.java.practice;class Tank&#123; int level;&#125;public class CopyTest&#123; public static void main(String[] args) &#123; Tank tk1 = new Tank(); Tank tk2 = new Tank(); tk1.level = 2; tk2.level = 3; System.out.println("tk1.level = " + tk1.level + "---tk2.level = " + tk2.level); tk1=tk2; System.out.println("tk1.level = " + tk1.level + "---tk2.level = " + tk2.level); tk2.level=5; System.out.println("tk1.level = " + tk1.level + "---tk2.level = " + tk2.level); &#125;&#125;// tk1和tk2分别是两个独立的对象，它们内部有level属性，赋值之前两个对象的属性值不同，赋值操作完成之后两个对象的属性值相同，当再次更改对象tk2的level值时，预期的理想情况是不会影响tk1的值，但实际结果并非如此，tk1与tk2对象的属性相同，这与前面的分析结果相同。 别名现象Java中这种针对对象的特殊现象叫做别名现象，如果想避免这种现象的话，可以使用如下操作，赋值操作针对属性而不是对象的引用1tk1.level=tk2.level //这样操作就可以保持两个对象本身相互独立。 在调用方法传参的时候也是会产生别名问题。123456789101112131415161718192021package com.chenxyt.java.practice;class Tank&#123; int level;&#125;public class CopyTest&#123; public static void copy(Tank tk3)&#123; tk3.level = 9; &#125; public static void main(String[] args) &#123; Tank tk1 = new Tank(); tk1.level = 2; System.out.println("tk1.level = " + tk1.level); copy(tk1); System.out.println("tk1.level = " + tk1.level); &#125;&#125;// 运行结果，方法外部tk1对象的值被修改了// 输出// tk1.level = 2// tk1.level = 9 算术操作符Java中的算术操作符与其它语言基本类似，有加号（+）、减号（-）、乘号（*）、取整（/）、取余（%），同时也具有简化运算符的功能如要将x加4之后再赋值给x，则可以写成:1x+=4; 自动递增和递减Java中的递增递减操作与其它语言基本类似，递增符合（++），递减符合（–），操作目的是快速使一个整数加1或者减1如a++等同于a=a+1，这两种符号分别有两种使用方式称为“前缀式”和“后缀式”。 前缀式前缀式意味着符号在变量前边 后缀式后缀式意味着符号在变量后边 二者区别二者的区别，对于前缀式是先做运算再取值，如a=1，b=++a，此时a跟b的值都是2，而后缀式则是先取值再做运算，如a=1，b=a++，此时b的值为1，a的值为2。 关系操作符关系操作符生成的是一个boolean（布尔）结果，它们计算操作数之间的关系，如果关系为真则结果为true，如果关系为假则结果为false。关系操作符号包括小于（&lt;）、大于（&gt;）、小于等于（&lt;=）、大于等于（&gt;=）、等于（==）以及不等于（!=）。等于和不等于适用于所有的基本数据类型，而其它的操作符不适用于boolean类型，因为它们的值为true或者false，比较大小没有意义。 操作符==和!=同样适用于操作对象，但是与基本操作类型相比有一些不同。 12345678910111213141516171819202122232425262728293031323334package com.chenxyt.java.practice;public class OperationTest&#123; public static void main(String[] args) &#123; Integer itg1 = new Integer(22); Integer itg2 = new Integer(22); System.out.println(itg1==itg2); System.out.println(itg1!=itg2); int int1 = 22; int int2 = 22; System.out.println(int1==int2); System.out.println(int1!=int2); &#125;//输出//false//true//true//false//原因分析// 因为对于对象来说，“==”和“！=”比较的是对象的引用，虽然这两个对象的值相同，但是他们对象的引用并不是一个，也就是他们在内存中有两个不同的存储位置，所以不相同。所以要想比较对象的值是否相同，我们可以使用对象的equals（）方法来进行比较，它是Object类的一个通用方法，第一章中说到过所有类的父类都是Object，因此任何类的对象都可以调用这个方法。// 对象的对比package com.chenxyt.java.practice;public class OperationTest&#123; public static void main(String[] args) &#123; Integer itg1 = new Integer(22); Integer itg2 = new Integer(22); System.out.println(itg1.equals(itg2)); &#125;&#125;// 输出// true 12345678910111213141516package com.chenxyt.java.practice;class Oper&#123; int i;&#125;public class OperationTest&#123; public static void main(String[] args) &#123; Oper op1 = new Oper(); Oper op2 = new Oper(); op1.i=2; op2.i=2; System.out.println(op1.equals(op2)); &#125;&#125;// 输出// false//原因分析:Object类中equals（）方法实际上是比较两个引用是否相同，就是它与“==”的本质效果是一样的，但是在第一个示例中的Integer类中，Java覆盖了这个方法，方法内容判断两个对象的类型是否相同以及值是否相同即可。而我们自己创建的Oper类并没有覆盖这个方法，所以沿用的还是Object类的方法。常见的String类也是覆盖了equals（）方法，效果与Integer类的对象相同。 逻辑操作符Java中的逻辑操作符与其它语言基本类似，包括与（&amp;&amp;）、或（||）、非（!），不同的是Java中的逻辑操作符只能应用与布尔值之间或者是表达式结果为布尔值。 &amp;&amp;逻辑与运算符必须两边同时为真则结果为真，否则为假。||逻辑或运算符只要有一边为真则结果为真，!非运算符取对应值的对立面，即非真则假。 短路对于逻辑与和逻辑或运算还有个名词叫做短路，即当两个算式做逻辑与运算时，如果左边第一个算式为假，则显然这个逻辑表达式最后的结果一定为假，那么就没有必要进行下边的表达式计算，直接结束运算，这个过程称作短路。 按位操作符Java中的按位操作符与其他语言基本相似，有按位与（&amp;）、按位或（|）、按位异或（^）和按位非（~）操作符。它们针对基本数据类型的一个比特位（bit）进行运算。运算规则如下，&amp;操作符必须同时为1才为1，|操作符只有同时为0时才为0，^操作符只要有一个为1就为1，~是单目运算符，取反，若值为1则结果为0，反之为1。按位操作符除了~还可以与“=”合起来使用，如&amp;=或者|=、^=。对于布尔值，同样可以进行按位与、按位或和按位异或运算，但是不能进行按位非运算，并且他们不会被短路，不管第一个表达式结果是什么，都会继续运算下去。 移位操作符 移位操作符操作的也是二进制的位，移位操作符只能用来处理整数类型。移位操作也是二元操作符，一共有三种，左移操作符（&lt;&lt;），右移操作符（&gt;&gt;），无符号右移操作符（&gt;&gt;&gt;），左移操作符是操作符左边的数向左移动操作符右边指定的位数，低位补0，右移操作符是操作符左边的数向右移动操作符右边指定的位数，其中正数高位补0，负数高位补1。无符号右移操作符是Java独有的一种，即不管正数还是负数，右移之后高位都补0。关于移位操作有两点说明，一是高位指的是左边的位，二是对于int类型，最大长度为32位，对于long类型最大长度为64位。 三元操作符IF-ELSE1boolean-exp?value1 : value2; 12345678910package com.chenxyt.java.practice;public class OperationTest&#123; public static void main(String[] args) &#123; int a = 5; int b = a&gt;10?a*100:a*10; System.out.println("b===="+ b); &#125;// 输出// b====50 字符串操作符+和+=Java中可以使用+和+=连接String类型，并且当操作符左边你的数为String时，Java会试图将操作符右边的类型转换成String。 使用操作符常犯的错误注意=和==的区别，以及逻辑运算符如（&amp;&amp;）和位运算符（&amp;）的区别和前自增++i和后自增i++的区别。注意==和equals()的使用，注意别名现象。 类型转换操作符Java中有跟其它语言相同的转换方式，（类型）值形式，也可以使用基本类型的包装器的转换方法进行转换。 Java没有size ofC语言中使用size of来获取程序占用的内存字节大小，目的是确定平台的移植操作，Java中没有这个方法，也就是不需要获取这个值，因为Java在不同的平台下基本数据类型具有相同的大小，可以便捷的移植。十七、总结 总结操作符在各个语言中基本通用，熟练掌握自增自减、逻辑运算、位运算以及移位操作即可，理解==和equals()的原理，理解别名现象。]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>java编程思想</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[tr命令]]></title>
    <url>%2Fhexo-blog-deploy%2F2019%2F03%2F14%2F2019-03-linux-cmd-tr%2F</url>
    <content type="text"><![CDATA[简介tr命令可以对来自标准输入的字符进行替换、压缩和删除。它可以将一组字符变成另一组字符，经常用来编写优美的单行命令，作用很强大。 语法1tr(选项)(参数) 选项1234-c或——complerment：取代所有不属于第一字符集的字符；-d或——delete：删除所有属于第一字符集的字符；-s或--squeeze-repeats：把连续重复的字符以单独一个字符表示；-t或--truncate-set1：先删除第一字符集较第二字符集多出的字符。 参数 字符集1：指定要转换或删除的原字符集。 当执行转换操作时，必须使用参数“字符集2”指定转换的目标字符集。 但执行删除操作时，不需要参数“字符集2”； 字符集2： 指定要转换成的目标字符集。 实例将输入字符由大写转换为小写：123echo "HELLO WORLD" | tr 'A-Z' 'a-z'hello world# 'A-Z' 和 'a-z'都是集合，集合是可以自己制定的，例如：'ABD-&#125;'、'bB.,'、'a-de-h'、'a-c0-9'都属于集合，集合里可以使用'\n'、'\t'，可以可以使用其他ASCII字符。 使用tr删除字符：12echo "hello 123 world 456" | tr -d '0-9'hello world 将制表符转换为空格：1cat text | tr '\t' ' ' 字符集补集，从输入文本中将不在补集中的所有字符删除：123echo aa.,a 1 b#$bb 2 c*/cc 3 ddd 4 | tr -d -c '0-9 \n' 1 2 3 4# 此例中，补集中包含了数字0~9、空格和换行符\n，所以没有被删除，其他字符全部被删除了。 用tr压缩字符，可以压缩输入中重复的字符：12echo "thissss is a text linnnnnnne." | tr -s ' sn'this is a text line. 巧妙使用tr做数字相加操作：1echo 1 2 3 4 5 6 7 8 9 | xargs -n1 | echo $[ $(tr '\n' '+') 0 ] 删除Windows文件“造成”的’^M’字符：123cat file | tr -s "\r" "\n" &gt; new_file# 或cat file | tr -d "\r" &gt; new_file tr可以使用的字符类：1234567891011121314[:alnum:]：字母和数字[:alpha:]：字母[:cntrl:]：控制（非打印）字符[:digit:]：数字[:graph:]：图形字符[:lower:]：小写字母[:print:]：可打印字符[:punct:]：标点符号[:space:]：空白字符[:upper:]：大写字母[:xdigit:]：十六进制字符# 使用方式 tr '[:lower:]' '[:upper:]']]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux命令</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java编程思想学习笔记三:static关键字的四种用法]]></title>
    <url>%2Fhexo-blog-deploy%2F2019%2F03%2F14%2F2019-03-think-in-java-3%2F</url>
    <content type="text"><![CDATA[在Java中这是一个很重要的关键字，它有很多的用法，并且在某些特定的情况下使用可以优化程序的性能。本文学习static关键字的应用场景。在这之前了解变量的类型，变量按作用域分为成员变量和局部变量，成员变量也就是全局变量，它是在类中声明的，不属于类中任何一个方法。而局部变量是在类中的方法体中声明的，作用域只是这个方法体。接下来说一下static的作用。 1. 修饰成员变量static最常用的功能就是修饰成员变量，被static修饰的成员变量称为静态变量也叫做类变量，它与普通的成员变量的区别是：对于静态变量内存中只有一个拷贝，JVM只为其分配一次内存，在加载类的过程中完成内存的分配。也就是说这个变量时属于这个类的，而其它任何这个类实例化的对象都拥有同一个拷贝。可以使用类名.变量的形式进行访问。而对于普通的成员变量，每创建一个对象就会产生一个拷贝，并且每创建一个对象就会分配一次内存。所以相比之下static常用于对象之前需要共享变量以及方便访问变量时使用。 1234567891011121314151617181920public class TestStatic &#123; private String name; private int age; public void print()&#123; System.out.println("Name:" + name + "---Age:" + age); &#125; public static void main(String[] args) &#123; TestStatic ts1 = new TestStatic(); TestStatic ts2 = new TestStatic(); ts1.name = "zhangsan"; ts1.age = 22; ts2.name = "lisi"; ts2.age = 33; ts1.print(); ts2.print(); &#125;&#125;// 以上代码是普通的成员变量的例子，对象ts1和ts2分别拥有着age 和 name两个成员变量的两个副本，彼此互相不影响，所以在实例化之后赋值，ts1能得到想要的值，ts2也能得到想要的值。有两个副本互不影响的意思就是他们指向两个不同的内存空间。 输出 12345678910111213141516171819public class TestStatic &#123; private String name; private static int age; // 将其用static修饰为静态成员变量 public void print()&#123; System.out.println("Name:" + name + "---Age:" + age); &#125; public static void main(String[] args) &#123; TestStatic ts1 = new TestStatic(); TestStatic ts2 = new TestStatic(); ts1.name = "zhangsan"; ts1.age = 22; ts2.name = "lisi"; ts2.age = 33; ts1.print(); ts2.print(); &#125;// 这时由于age变量变成了类变量，两个对象ts1和ts2公用一个相同的副本，所以ts1修改过后的值会被ts2重新修改。// 此外第二个示例代码中，静态成员变量使用了对象.变量的方式进行调用，这里编译器会给出警告，使用类名.方法之后警告就会解除 2. 修饰成员方法static的另一个作用是修饰成员方法，修饰成员方法的目的是使该方法可以通过类名.方法的形式进行调用，避免了创建对象的繁琐。同时对于存储空间来说，被修饰的方法没有本质上的区别，它与不被修饰的方法都属于类方法，每个对象调用的都是同一个方法。 3. 修饰代码块对象的初始化过程12345678910111213141516class Load &#123; public Load(String msg)&#123; System.out.println(msg); &#125;&#125;public class TestStatic&#123; Load ld1 = new Load("普通变量1"); Load ld2 = new Load("普通变量2"); static Load ld3 = new Load("静态变量3"); static Load ld4 = new Load("静态变量4"); public TestStatic(String msg)&#123; System.out.println(msg); &#125; public static void main(String[] args) &#123; TestStatic ts = new TestStatic("TestStatic 初始化"); &#125; 静态成员变量最先被初始化，并且按照执行的先后顺序进行初始化。其次初始化的是成员变量，最后初始化的是构造方法。所以在创建一个对象的时候，最先被初始化的是静态成员变量。 1234567891011121314151617181920212223class Load &#123; public Load(String msg)&#123; System.out.println(msg); &#125;&#125;public class TestStatic&#123; Load ld1 = new Load("普通变量1"); Load ld2 = new Load("普通变量2"); static Load ld3 = new Load("静态变量3"); static Load ld4 = new Load("静态变量4"); public TestStatic(String msg)&#123; System.out.println(msg); &#125; public static void staticFunc()&#123; System.out.println("静态方法"); &#125; public static void main(String[] args) &#123; TestStatic.staticFunc(); System.out.println("@@@@@@@@@"); TestStatic ts = new TestStatic("TestStatic 初始化"); &#125;&#125; 静态成员的初始化发生在创建对象之前，确切的说是在调用静态方法之前就已经被初始化了。并且，当我们创建对象的时候，原本被初始化过的静态成员变量跟静态方法没有再次被初始化。 静态作用域这时我们的static的作用就是，修饰一段都需要被修饰为static的域。被static修饰的代码域，域中所有的内容都被当成static变量，且优先初始化。 123456789101112131415161718192021222324252627class Load &#123; public Load(String msg)&#123; System.out.println(msg); &#125;&#125;public class TestStatic&#123; Load ld1 = new Load("普通变量1"); Load ld2 = new Load("普通变量2"); static Load ld3; static Load ld4; static&#123; ld3 = new Load("静态变量3"); ld4 = new Load("静态变量4"); &#125; public TestStatic(String msg)&#123; System.out.println(msg); &#125; public static void staticFunc()&#123; System.out.println("静态方法"); &#125; public static void main(String[] args) &#123; TestStatic.staticFunc(); System.out.println("@@@@@@@@@"); TestStatic ts = new TestStatic("TestStatic 初始化"); &#125;&#125; 4. 静态导入可以导入一个带有静态方法的静态包，从而可以在当前类中直接调用包中的静态方法，就好像是自己的方法一样。12345678910111213141516//先在一个包中创建一个类并定义一个静态方法：package com.chenxyt.java.test;public class Printer &#123; public static void print(String msg)&#123; System.out.println(msg); &#125;//然后在另一个包中用import static 导入这个类：package com.chenxyt.java.practice;import static com.chenxyt.java.test.Printer.*;public class TestStatic&#123; public static void main(String[] args) &#123; print("This is TestStatic"); &#125;&#125; 总结static是Java语言中的一个很重要的关键字，主要用途有三个方面修饰成员变量，修饰成员方法以及修饰代码块。使用static修饰的成员变量在类加载的时候就已经被初始化了，它属于类变量，不属于某个对象，所有该类的实例化对象拥有同一个静态成员变量副本，常用的用途可以用它来做计数器。]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>java编程思想</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java编程思想学习笔记二：一切都是对象]]></title>
    <url>%2Fhexo-blog-deploy%2F2019%2F03%2F12%2F2019-03-think-in-java-2%2F</url>
    <content type="text"><![CDATA[用引用操作对象在Java中一切都是对象，但操纵标识符的是对象的一个引用。(生活中的例子:可以将这一情形想象是电视机与遥控器的关系。电视机是一个对象，遥控器是对象的引用，我们在房间里拿着遥控器不管在哪里都可以操控电视机对象。此外，脱离电视机对象，遥控器引用也是可以独立存在的。) 1String s; //这里只是创建了一个引用，并没有创建对象，如果此时向s发送消息的话，会报出运行时异常的错误，因为我们并没有给这个引用指定对象，前文我们说到消息的传递都是基于对象的。 我们在声明引用的时候要进行初始化：1String s = "abc"; //字符串可以使用带引号的文本进行初始化 必须由开发者创建所有的对象 我们创建了一个操作对象的引用，通常希望它可以与一个对象进行关联。 Java中更通用的做法是使用new关键字创建一个对象。 new关键字的意思是“给我一个新的对象”。 1String s = new String("abc"); //表示给我一个String类型的对象，并且初始化值为“abc” 计算机如何分配内存当我们创建好对象时，他们是怎么样进行内存分配的呢？程序在计算机中，有如下五个地方可以存储数据： 1. 寄存器这是最快的存储区，他与其他存储区不同的地方在于他在处理器的内部。同时他的数量也是非常有限的，因此他也是根据需求进行分配，你基本不能自己控制他进行内存分配。 2. 堆栈位于通用RAM（随机存储器）中，通过堆栈指针可以从处理器得到支持，指针向下移动分配新内存，指针向上移动回收内存。这是一种快速有效的分配内存方式，仅次于寄存器。创建程序时，Java系统必须知道处于堆栈中的所有项的确切声明周期，以便堆栈指针的移动。这一操作限制了程序的灵活性，虽然Java中某些数据存储在堆栈中，比如对象的引用，但是Java对象并不存在堆栈中。 3. 堆一种同样位于RAM中的内存池，用于存放所有的Java对象，堆不同于堆栈的好处在于编译器不需要提前知道对象的确切声明周期，因此灵活性很高。当需要一个对象的时候，只需要new一段代码，会自动的分配所需要的内存。当然这种分配的效率要比使用堆栈的低。 4. 常量存储常量值通常存在程序代码内部，这样做使得他们永远不会被改变。在部分嵌入式系统中，常量本身会与其他部分分离，这种情况通常将常量存储在ROM（只读存储器）中。 5. 非RAM存储数据可以完全存储在程序之外，那么他可以完全不受程序的控制，即便程序没有启动也可以存在。比如文件流对象和持久化对象。文件流通常是被发送给另一台机器，持久化对象通常存储在硬盘中。 基本类型通常情况下，new将对象存储在堆里，当创建一个简单的小的对象时，显得不是很有效，因此Java采用跟C或者C++相同的方式，不用new创建变量，而创建一个并非是引用的自动变量，这个变量直接存储值，并将其存储在堆栈中。与其他语言不同的是，Java中所有的基本类型的大小在各个平台都相同，这使得Java程序有更好的跨平台移植性。 所有的数值类型都有正负号，所以Java中不存在无符号类型。 包装器类基本类型具有包装器类，使得可以在堆中创建一个非基本对象，用来表示对应的基本类型。12345678char c = 'x'；Character ch = new Character（c）；// 也可以这样用：Character ch = new Character（'x'）；// Java SE5的自动包装功能可以自动的将基本类型转换为包装器类型：Character ch = 'x'；// 也可以反向转换：char c = ch； Java中还提供了两个用于高精度计算的类：BigInteger和BigDecimal，他们大体属于包装器类，但是他们没有对应的基本类型，不过可以通过方法调用的方式与int 和 float进行交互操作。BigInteger支持任意精度的整数，BigDecimal支持任意精度的浮点数。 Java与其他语言一样都提供了数组的功能，不同的是，Java语言保证了数组的安全性，会确保数组被初始化才使用，不会出现其他语言中的访问没有被初始化的内存区域。当创建了一个数组对象时，实际上就创建了一个引用数组，并且每个引用会自动初始化一个特定的值，该值拥有自己的关键字null，一旦Java看到了null，就知道这个引用还有指向对象，也就是没有被初始化。这个过程称为下标检查。 永远不需要销毁对象作用域Java语言与其他语言都有作用域的概念，作用域决定了在其内部定义的变量名的可见性和生命周期。作用域为对应的花括号区间内部。 Java对象与其他的基本类型不同，他可以存活于作用域之外。123&#123; String s = new String("x");&#125; 引用s在对应的作用域终点就消失了，然而，s指向的String对象仍然占据内存空间，我们无法在作用域之外访问这个对象，因为它的唯一的引用已经超出了作用域的范围，后面会讲述程序的执行过程中，如何传递和复制对象的引用。 垃圾回收机制是否对象占用的内存Java中，只要你需要，对象会一直存在，Java自带了垃圾回收器，用来监视new创建的对象，并辨别那些不会再引用的对象，从而释放内存供其他对象使用。所以在Java中不必担心忘了释放对象的内存。 创建新的数据类型：类同一种对象的集合我们可以理解为类，这里类表示由他实例化的对象都具有相同的基本属性。Java中使用class关键字创建一个新的类型。123class Students&#123;&#125; //定义了一种新的类型 Students，在这个类型中，没有说明属性，也没有指定方法，所以他暂时还不能处理消息，但是我们可以用它来创建新的对象，实例化一个类的对象如下Students student = new Student(); 类的数据类型 字段(类的一些属性) – 数据 方法(类与其它类之间交互消息的方式) – 行为 类基础数据类型的初始化Java中会为类当中（不是类中的不算哦）的基本类型成员提供一个默认值，以确保这个基本数据类型可以有效的进行初始化，防止程序出现错误，当然这个初始化的值可能不符合程序需求，需要自己明确的进行初始化。如果不是在类中的基本类型变量，那么它初始化的值是随机的。 方法、参数和返回值方法的定义Java的方法决定了对象能够做哪些事情，可以接收处理哪些信息。方法的基本组成包括：名称、参数、返回值和方法体。123ReturnType methodName(Arg arg)&#123; /*Method Body*/&#125; ReturnType是调用了该方法之后，返回给调用方的值的类型 methodName是该方法的名字，括号里的是参数列表 Arg是参数类型， arg是参数的名称 Method Body是函数方法的执行内容。 方法的调用Java中方法的调用是通过对象进行调用，且这个对象必须能够执行这个方法，否则在编译过程中会报错。123objectName.methodName(arg,arg1,arg2);//有返回值的调用ReturnType x = obejctName.methodName(arg,arg1,arg2); 构建一个Java程序java的包C++中对类的名字有命名空间的概念，Java中避免重复的命名采用了包的形式，将相同类型，或者相同作用相同业务场景的类放在一个包中，不同包中可以出现相同名称的类。 导包如果需要使用另一个包中的类，Java中通过import关键字导入对应类所属的包，这样就可以在当前类调用其他类了。 静态 static通常情况下，我们必须创建一个对象，并用这个对象访问数据或者方法，而有一种特殊的情况，我们可以用static修饰域或者方法，这意味着这个域或者方法不会与包含它的那个类的任何对象实例关联在一起。所以即使从未创建某个类的任何对象，也可以调用其static方法访问static域。 只需将static放在要修饰的定义之前，就可以将字段或者方法设定为static，如下生成了一个static字段，并进行初始化 1234567891011121314class TestStatic()&#123; static int i = 4;&#125;//现在即使创建了两个`TestStatic`对象，`i`仍然只有一个存储空间，**两个对象的值共享一个变量**。TestStatic ts1 = new TestStatic();TestStatic ts2 = new TestStatic();// 如上ts1.i和ts2.i指向同一个内存空间，因此他们值相同都是4// 直接通过类名.变量的方式，如TestStatic.i ,而这对于非static变量是不允许的。被static修饰的变量称为静态变量，他的作用是所有对象共享同一个数据，且声明周期贯穿整个程序执行过程，共享一个数据的应用可以作为一个计数器。// 类似的逻辑还可以应用于静态方法，既可以像非静态方法一样使用对象进行调用，也可以使用类名直接调用。定义静态方法与定义静态变量相似class TestStatic()&#123; static void staticMethod();&#125; 静态方法和变量存在的意义: static变量或者方法的应用重要意义就是可以不需要创建对象就可以调用它。 第一个java程序1234567import java.util.*public class HelloWorld&#123; public static void main(String[] args) &#123; System.out.println("Hello World"); &#125;&#125;// import是导入java.util工具包下的所有类,HelloWorld是类名，类名需要与文件名相同，main方法是程序的入口，虽然这里没有用到参数列表，但是对于main函数来说这是必须的。使用开发工具如Eclipse运行程序即可看到控制台打印“HelloWorld”]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>java编程思想</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java编程思想读书笔记一：对象导论]]></title>
    <url>%2Fhexo-blog-deploy%2F2019%2F03%2F11%2F2019-03-think-in-java-1%2F</url>
    <content type="text"><![CDATA[抽象过程1. 万物皆为对象理论上讲，我们可以抽取一个待解决问题中的任何概念化构件（狗、建筑、服务）等，将其表示为程序中的对象。 2. 程序是对象的集合对象之间是通过发送消息来告知彼此所要做的。通俗来说，一个程序是一些对象的集合体，程序之间的通信实际是对象与对象之间的通信，要想进行通信，就必须要发送一条消息。更确切的说，我们可以把消息理解为是对对象的某个特定方法的请求。 3. 每个对象都有自己的由其他对象所构成的存储换句话说就是一个对象可能由其他多个对象共同创建。 4. 每个对象都拥有其类型类型是用来区分不同对象的特性，也就是可以发送什么样的消息给它。 5. 某一特定类型的所有对象都可以接收同样的消息这里是说对象之间信息交互的关系。如果一个“圆形”对象也是一个“几何形”对象，那么这个“圆形“对象一定也能接收发给”几何形”对象的消息。 每个对象都有一个接口对象之间传递消息时，消息的接收是通过接口来传递的，接口对应着对象内部的一个方法，接口暴露给外部对象，内部方法决定消息的执行方式。 每个对象都提供服务可以把对象理解为服务提供者，每一个对象都有它所对应的服务需要提供，因此我们在创建一个对象或者说是构建一个类的时候，要思考能否更大程度的抽象出一个对象，以解决一个实际的问题。 被隐藏的具体实现我们将开发人员分为两种: 类创建者类创建者负责构造类，包括类的属性和接口、方法，这种类只向客户端程序员暴露必要的部分，而隐藏其他部分，防止客户端程序员对类中重要的数据进行修改以对程序造成重要损失，我们称作是访问控制。 客户端程序员。 访问控制客户端程序员负责快速准确的编写客户端程序。访问控制的第一个原因是让客户端程序员无法接触他们不该接触的部分，因为有些内容对程序本身来说很重要但是与应用程序业务没有关系。另一个原因是便于类创建者在不影响客户端程序的前提下来修改类内部的私有内容。Java中访问控制有三个级别：public、private、protected。 public顾明思议是公有的，表示由public修饰的内容可以供所有人可见。 private为私有的，表示由private修饰的部分只有自己可见。 protected与private类似，差别在于继承类中，子类可以访问父类中的protected修饰区而无法访问private修饰区。此外还有默认的访问权限，即没有上述三种修饰的情况下，默认在包内可见，在包外等同于private级别。 复用具体实现(组合)–has-a的关系一个类并不能完全的被复用到另外一种场景，这时我们需要创建一个新的类，并引入之前的类的对象，引入的对象我们声明为private级别的成员对象。一个新建的类可以有很多个其它类型的对象，这种方式我们称为组合它可以有效的实现我们想要的方式的组合，组合是has-a的关系，表明某某类有a对象的属性。同时，由于组合类的成员变量通常都被修饰为private，所以客户端程序员并不能访问他们，同时也方便了类创建者在不影响程序功能的前提下修改这些成员变量。 继承– is-a的关系当我们创建一个类时，如果另一个新类与这个类功能相似，我们仍然需要创建这个新类。解决这个问题的办法就是继承。继承虽然也是一个新类，但是这个类是由基类（俗称父类）衍生的导出类（俗称子类）。 子类与父类之间的关系 子类拥有父类所有非private的对象、属性、接口，此外可以根据不同的需要增加不同的功能。父类可以有很多个子类，它包含了子类的所有公共部分。如“几何形”是父类，每一个几何形都具有尺寸、颜色、位置等，同时每一个几何形都可以被绘制、擦除和移动。在此基础上可以导出它的子类“三角形”、“平行四边形”等，他们拥有父类的属性、方法之外还有自己独特的属性，例如有的形状可以被翻转等。 子类不光继承了父类的属性，同时也继承了父类的方法，也就是说所有发给父类的消息，都可以发给子类。子类对接口的实现方法可以不改变，即访问子类的接口实际是与访问父类相同，当然也可以自己“覆盖”父类接口的方法，也就是说我和父类使用相同的接口，但是我们做不同的事情(is-a的关系)。同时如前边所说，子类也可以自己新增方法来满足自己的需求。(is-like-a的关系,在子类中增加了新的方法，所以这种相同的关系并不完全) 伴随多态的可互换对象前期绑定和后期绑定子类继承父类，同时继承了父类的方法，也就是说发给父类的消息同时能够发给子类。那么当我们把子类对象看成泛化的基类对象时，如果有个方法是让泛化的父类操作自己，那么编译器在编译时不知道该执行哪段代码的。一个非面向对象程序的函数调用是前期绑定，函数要执行的代码在程序运行之前就已经确定了，然而在OOP中，直到程序执行我们才知道哪段代码被执行了,所以为了解决消息执行哪段代码的问题，Java使用了后期绑定的概念，使用一小段特殊的代码来代替非面向对象中所说的绝对地址调用，这段代码使用在对象中存储的信息来计算方法的地址 后期绑定的案例1234567891011void doSomething(Shape shape)&#123; shape.erase(); //... shape.draw();// 这个方法可以与任意`Shape`类型的对象交互，如果程序中有它的子类调用了该方法Circle circle = new Circle();Triangle triangle = new Triangle();cicle.doSomething();triangle.doSomething(); 编译对doSomething的调用会自动处理，而不必考虑是什么类型。这里编译器将子类看成父类，这个过程称作向上转型。这段代码并不是说“如果是Cirle就xxx，如果是Triangle就xxx”，而是“你就是个Shape，只管做就好，注意细节问题的正确性”。其中细节问题由编译器进行处理。 单根继承结构在Java语言中，所有的类都是Object类的子类，拥有着Object类的基本方法。这种单根继承结构有很大的好处，比如在垃圾回收中可以避免由于不知道对象的类型而无处下手，因为他们都可以使用Object类的方法，并且所有对象都可以很容易的在堆上创建。 容器有时候我们并不知道处理一个问题需要多少个对象，或者他们需要存活多久，那么我们就不知道该怎么样存储这些对象。Java语言中创建了一种对象类型，叫做容器（也叫集合）。这种新的对象类型内部有对其他对象的引用，当你需要的时候你可以很容易的扩充容器的空间来容纳对象。Java中提供了多种容器类型，如List（用于存储序列）、Map（也被称为关联数组，用来建立对象的关联）、Set（每种对象类型只持有一个）。因为容器中存储了其他对象的引用，所以根据单根继承结构，容器中的对象类型都是Obejct类型，这样很方便其他对象类型进行转型。但是从Object类型转到其它特定类型（称作向下转型）很容易发生错误，所以Java SE5之后引入了泛型的概念，参数传递使用一对&lt;&gt;，&lt;&gt;内部可以传递任意类型的对象，这便解决了向下转型带来的安全隐患。 对象的创建和生命周期对象的创建方式有两种: 在编程时由程序员控制，将对象置于栈中或者是静态区域，这种的好处是知道对象的大小、生命周期。同时也限制了对象的灵活性。 通过new在内存堆中动态的创建对象，这种方式的好处是灵活，需要的时候直接在内存中创建即可，实现了存储空间的动态管理。 Java中完全采用了动态内存的分配方式。 对象的生命周期对于生命周期， 栈上的生命周期，编译器可以知道它什么时候销毁，并自动回收。 而在堆上创建的对象，必须由程序员自己指定回收时间，如果没有指定则会造成内存泄漏。Java中提供了垃圾回收机制，可以自动的回收在堆上创建的对象。 异常处理：处理错误Java内置了异常处理机制，相当于一条与正确执行并行的路线，当程序发生异常时会执行异常的代码。同时，允许程序在异常中进行处理并返回到正确的结果中去 并发编程Java与其他语言一样，提供多线程的并发编程方式，提高程序运行效率。 Java与InternetJava不仅可以编写客户端程序，还可以编写网络Web应用程序。]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>java编程思想</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[shell printf命令：格式化输出语句]]></title>
    <url>%2Fhexo-blog-deploy%2F2019%2F03%2F11%2F2019-03-linux-shell-printf%2F</url>
    <content type="text"><![CDATA[简介printf 命令用于格式化输出， 是echo命令的增强版。它是C语言printf()库函数的一个有限的变形，并且在语法上有些不同。 Notes printf 由 POSIX 标准所定义，移植性要比 echo 好。 语法1printf format-string [arguments...] format-string 为格式控制字符串 arguments 为参数列表。 与C语言printf()函数的不同 printf 命令不用加括号 format-string 可以没有引号，但最好加上，单引号双引号均可。 参数多于格式控制符(%)时，format-string 可以重用，可以将所有参数都转换。 arguments 使用空格分隔，不用逗号。 如同 echo 命令，printf 命令也可以输出简单的字符串：12$printf "Hello, Shell\n"Hello, Shell printf 不像 echo 那样会自动换行，必须显式添加换行符(\n)。 案例12345678910111213141516171819202122232425262728# format-string为双引号$ printf "%d %s\n" 1 "abc"1 abc# 单引号与双引号效果一样 $ printf '%d %s\n' 1 "abc" 1 abc# 没有引号也可以输出$ printf %s abcdefabcdef# 格式只指定了一个参数，但多出的参数仍然会按照该格式输出，format-string 被重用$ printf %s abc defabcdef$ printf "%s\n" abc defabcdef$ printf "%s %s %s\n" a b c d e f g h i ja b cd e fg h ij# 如果没有 arguments，那么 %s 用NULL代替，%d 用 0 代替$ printf "%s and %d \n" and 0# 如果以 %d 的格式来显示字符串，那么会有警告，提示无效的数字，此时默认置为 0$ printf "The first program always prints'%s,%d\n'" Hello Shell-bash: printf: Shell: invalid numberThe first program always prints 'Hello,0'$]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>shell脚本</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[tail命令]]></title>
    <url>%2Fhexo-blog-deploy%2F2019%2F03%2F11%2F2019-03-linux-cmd-tail%2F</url>
    <content type="text"><![CDATA[简介tail命令用于输入文件中的尾部内容。tail命令默认在屏幕上显示指定文件的末尾10行。如果给定的文件不止一个，则在显示的每个文件前面加一个文件名标题。如果没有指定文件或者文件名为-，则读取标准输入。 Notes如果表示字节或行数的N值之前有一个”+”号，则从文件开头的第N项开始显示，而不是显示文件的最后N项。N值后面可以有后缀：b表示512，k表示1024，m表示1 048576(1M)。 语法1tail(选项)(参数) 选项1234567891011--retry：即是在tail命令启动时，文件不可访问或者文件稍后变得不可访问，都始终尝试打开文件。使用此选项时需要与选项“——follow=name”连用；-c&lt;N&gt;或——bytes=&lt;N&gt;：输出文件尾部的N（N为整数）个字节内容；-f&lt;name/descriptor&gt;或；--follow&lt;nameldescript&gt;：显示文件最新追加的内容。“name”表示以文件名的方式监视文件的变化。“-f”与“-fdescriptor”等效；-F：与选项“-follow=name”和"--retry"连用时功能相同；-n&lt;N&gt;或——line=&lt;N&gt;：输出文件的尾部N（N位数字）行内容。--pid=&lt;进程号&gt;：与“-f”选项连用，当指定的进程号的进程终止后，自动退出tail命令；-q或——quiet或——silent：当有多个文件参数时，不输出各个文件名；-s&lt;秒数&gt;或——sleep-interal=&lt;秒数&gt;：与“-f”选项连用，指定监视文件变化时间隔的秒数；-v或——verbose：当有多个文件参数时，总是输出各个文件名；--help：显示指令的帮助信息；--version：显示指令的版本信息。 参数文件列表：指定要显示尾部内容的文件列表。 实例 实例 123tail file （显示文件file的最后10行）tail +20 file （显示文件file的内容，从第20行至文件末尾）tail -c 10 file （显示文件file的最后10个字符） tail 一般用来监控日志 123tail -f 实时查看日志文件 tail -f 日志文件logtail - 100f 实时查看日志文件 后一百行tail -f -n 100 catalina.out linux查看日志后100行]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux命令</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[head命令]]></title>
    <url>%2Fhexo-blog-deploy%2F2019%2F03%2F11%2F2019-03-linux-cmd-head%2F</url>
    <content type="text"><![CDATA[简介head命令用于显示文件的开头的内容。在默认情况下，head命令显示文件的头10行内容。 语法1head(选项)(参数) 选项1234-n&lt;数字&gt;：指定显示头部内容的行数；-c&lt;字符数&gt;：指定显示头部内容的字符数；-v：总是显示文件名的头信息；-q：不显示文件名的头信息。 参数文件列表：指定显示头部内容的文件列表。]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux命令</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[more命令]]></title>
    <url>%2Fhexo-blog-deploy%2F2019%2F03%2F11%2F2019-03-linux-cmd-more%2F</url>
    <content type="text"><![CDATA[简介more命令是一个基于vi编辑器文本过滤器，它以全屏幕的方式按页显示文本文件的内容，支持vi中的关键字定位操作。more名单中内置了若干快捷键，常用的有H（获得帮助信息），Enter（向下翻滚一行），空格（向下滚动一屏），Q（退出命令）。该命令一次显示一屏文本，满屏后停下来，并且在屏幕的底部出现一个提示信息，给出至今己显示的该文件的百分比：–More–（XX%）可以用下列不同的方法对提示做出回答： 按Space键：显示文本的下一屏内容。 按Enter键：只显示文本的下一行内容。 按斜线符|：接着输入一个模式，可以在文本中寻找下一个相匹配的模式。 按H键：显示帮助屏，该屏上有相关的帮助信息。 按B键：显示上一屏内容。 按Q键：退出rnore命令。 语法1more(语法)(参数) 选项123456-&lt;数字&gt;：指定每屏显示的行数；-d：显示“[press space to continue,'q' to quit.]”和“[Press 'h' for instructions]”；-c：不进行滚屏操作。每次刷新这个屏幕；-s：将多个空行压缩成一行显示；-u：禁止下划线；+&lt;数字&gt;：从指定数字的行开始显示。 参数文件：指定分页显示内容的文件。 实例 显示文件file的内容，但在显示之前先清屏，并且在屏幕的最下方显示完核的百分比。 1more -dc file 显示文件file的内容，每10行显示一次，而且在显示之前先清屏 1more -c -10 file]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux命令</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[cat命令]]></title>
    <url>%2Fhexo-blog-deploy%2F2019%2F02%2F16%2F2019-02-linux-cmd-cat%2F</url>
    <content type="text"><![CDATA[简介cat命令连接文件并打印到标准输出设备上，cat经常用来显示文件的内容。 Notes: 当文件较大时，文本在屏幕上迅速闪过（滚屏），用户往往看不清所显示的内容。因此，一般用more等命令分屏显示。为了控制滚屏，可以按Ctrl+S键，停止滚屏；按Ctrl+Q键可以恢复滚屏。按Ctrl+C（中断）键可以终止该命令的执行，并且返回Shell提示符状态。 语法1cat(选项)(参数) 选项123456-n或-number：有1开始对所有输出的行数编号；-b或--number-nonblank：和-n相似，只不过对于空白行不编号；-s或--squeeze-blank：当遇到有连续两行以上的空白行，就代换为一行的空白行；-A：显示不可打印字符，行尾显示“$”；-e：等价于"-vE"选项；-t：等价于"-vT"选项； 参数文件列表：指定要连接的文件列表。 参数设ml和m2是当前目录下的两个文件123cat m1 #（在屏幕上显示文件ml的内容）cat m1 m2 # 同时显示文件ml和m2的内容）cat m1 m2 &gt; file #（将文件ml和m2合并后放入文件file中）]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux命令</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ls命令]]></title>
    <url>%2Fhexo-blog-deploy%2F2019%2F02%2F16%2F2019-02-linux-cmd-ls%2F</url>
    <content type="text"><![CDATA[简介ls命令用来显示目标列表，在Linux中是使用率较高的命令。ls命令的输出信息可以进行彩色加亮显示，以分区不同类型的文件。 语法1ls（选项）（参数） 选项1234567891011121314151617181920212223-a：显示所有档案及目录（ls内定将档案名或目录名称为“.”的视为影藏，不会列出）；-A：显示除影藏文件“.”和“..”以外的所有文件列表；-C：多列显示输出结果。这是默认选项；-l：与“-C”选项功能相反，所有输出信息用单列格式输出，不输出为多列；-F：在每个输出项后追加文件的类型标识符，具体含义：“*”表示具有可执行权限的普通文件，“/”表示目录，“@”表示符号链接，“|”表示命令管道FIFO，“=”表示sockets套接字。当文件为普通文件时，不输出任何标识符；-b：将文件中的不可输出的字符以反斜线“”加字符编码的方式输出；-c：与“-lt”选项连用时，按照文件状态时间排序输出目录内容，排序的依据是文件的索引节点中的ctime字段。与“-l”选项连用时，则排序的一句是文件的状态改变时间；-d：仅显示目录名，而不显示目录下的内容列表。显示符号链接文件本身，而不显示其所指向的目录列表；-f：此参数的效果和同时指定“aU”参数相同，并关闭“lst”参数的效果；-i：显示文件索引节点号（inode）。一个索引节点代表一个文件；--file-type：与“-F”选项的功能相同，但是不显示“*”；-k：以KB（千字节）为单位显示文件大小；-l：以长格式显示目录下的内容列表。输出的信息从左到右依次包括文件名，文件类型、权限模式、硬连接数、所有者、组、文件大小和文件的最后修改时间等；-m：用“,”号区隔每个文件和目录的名称；-n：以用户识别码和群组识别码替代其名称；-r：以文件名反序排列并输出目录内容列表；-s：显示文件和目录的大小，以区块为单位；-t：用文件和目录的更改时间排序；-L：如果遇到性质为符号链接的文件或目录，直接列出该链接所指向的原始文件或目录；-R：递归处理，将指定目录下的所有文件及子目录一并处理；--full-time：列出完整的日期与时间；--color[=WHEN]：使用不同的颜色高亮显示不同类型的。参数 参数目录：指定要显示列表的目录，也可以是具体的文件。 实例显示当前目录下非影藏文件与目录12[root@localhost ~]# lsanaconda-ks.cfg install.log install.log.syslog satools 显示当前目录下包括影藏文件在内的所有文件列表123[root@localhost ~]# ls -a. anaconda-ks.cfg .bash_logout .bashrc install.log .mysql_history satools .tcshrc .vimrc.. .bash_history .bash_profile .cshrc install.log.syslog .rnd .ssh .viminfo 输出长格式列表123456[root@localhost ~]# ls -1anaconda-ks.cfginstall.loginstall.log.syslogsatools 显示文件的inode信息索引节点（index inode简称为“inode”）是Linux中一个特殊的概念，具有相同的索引节点号的两个文本本质上是同一个文件（除文件名不同外）。123[root@localhost ~]# ls -i -l anaconda-ks.cfg install.log2345481 -rw------- 1 root root 859 Jun 11 22:49 anaconda-ks.cfg2345474 -rw-r--r-- 1 root root 13837 Jun 11 22:49 install.log 水平输出文件列表123[root@localhost /]# ls -mbin, boot, data, dev, etc, home, lib, lost+found, media, misc, mnt, opt, proc, root, sbin, selinux, srv, sys, tmp, usr, var 最近修改的文件显示在最上面123[root@localhost /]# ls -ttmp root etc dev lib boot sys proc data home bin sbin usr var lost+found media mnt opt selinux srv misc 显示递归文件123456[root@localhost ~]# ls -R.:anaconda-ks.cfg install.log install.log.syslog satools./satools:black.txt freemem.sh iptables.sh lnmp.sh mysql php502_check.sh ssh_safe.sh 打印文件的UID和GID123456789101112131415161718192021222324[root@localhost /]# ls -ntotal 254drwxr-xr-x 2 0 0 4096 Jun 12 04:03 bindrwxr-xr-x 4 0 0 1024 Jun 15 14:45 bootdrwxr-xr-x 6 0 0 4096 Jun 12 10:26 datadrwxr-xr-x 10 0 0 3520 Sep 26 15:38 devdrwxr-xr-x 75 0 0 4096 Oct 16 04:02 etcdrwxr-xr-x 4 0 0 4096 Jun 12 10:26 homedrwxr-xr-x 14 0 0 12288 Jun 16 04:02 libdrwx------ 2 0 0 16384 Jun 11 22:46 lost+founddrwxr-xr-x 2 0 0 4096 May 11 2011 mediadrwxr-xr-x 2 0 0 4096 Nov 8 2010 miscdrwxr-xr-x 2 0 0 4096 May 11 2011 mntdrwxr-xr-x 2 0 0 4096 May 11 2011 optdr-xr-xr-x 232 0 0 0 Jun 15 11:04 procdrwxr-x--- 4 0 0 4096 Oct 15 14:43 rootdrwxr-xr-x 2 0 0 12288 Jun 12 04:03 sbindrwxr-xr-x 2 0 0 4096 May 11 2011 selinuxdrwxr-xr-x 2 0 0 4096 May 11 2011 srvdrwxr-xr-x 11 0 0 0 Jun 15 11:04 sysdrwxrwxrwt 3 0 0 98304 Oct 16 08:45 tmpdrwxr-xr-x 13 0 0 4096 Jun 11 23:38 usrdrwxr-xr-x 19 0 0 4096 Jun 11 23:38 var 列出文件和文件夹的详细信息123456789101112131415161718192021222324[root@localhost /]# ls -ltotal 254drwxr-xr-x 2 root root 4096 Jun 12 04:03 bindrwxr-xr-x 4 root root 1024 Jun 15 14:45 bootdrwxr-xr-x 6 root root 4096 Jun 12 10:26 datadrwxr-xr-x 10 root root 3520 Sep 26 15:38 devdrwxr-xr-x 75 root root 4096 Oct 16 04:02 etcdrwxr-xr-x 4 root root 4096 Jun 12 10:26 homedrwxr-xr-x 14 root root 12288 Jun 16 04:02 libdrwx------ 2 root root 16384 Jun 11 22:46 lost+founddrwxr-xr-x 2 root root 4096 May 11 2011 mediadrwxr-xr-x 2 root root 4096 Nov 8 2010 miscdrwxr-xr-x 2 root root 4096 May 11 2011 mntdrwxr-xr-x 2 root root 4096 May 11 2011 optdr-xr-xr-x 232 root root 0 Jun 15 11:04 procdrwxr-x--- 4 root root 4096 Oct 15 14:43 rootdrwxr-xr-x 2 root root 12288 Jun 12 04:03 sbindrwxr-xr-x 2 root root 4096 May 11 2011 selinuxdrwxr-xr-x 2 root root 4096 May 11 2011 srvdrwxr-xr-x 11 root root 0 Jun 15 11:04 sysdrwxrwxrwt 3 root root 98304 Oct 16 08:48 tmpdrwxr-xr-x 13 root root 4096 Jun 11 23:38 usrdrwxr-xr-x 19 root root 4096 Jun 11 23:38 var 列出可读文件和文件夹详细信息123456789101112131415161718192021222324[root@localhost /]# ls -lhtotal 254Kdrwxr-xr-x 2 root root 4.0K Jun 12 04:03 bindrwxr-xr-x 4 root root 1.0K Jun 15 14:45 bootdrwxr-xr-x 6 root root 4.0K Jun 12 10:26 datadrwxr-xr-x 10 root root 3.5K Sep 26 15:38 devdrwxr-xr-x 75 root root 4.0K Oct 16 04:02 etcdrwxr-xr-x 4 root root 4.0K Jun 12 10:26 homedrwxr-xr-x 14 root root 12K Jun 16 04:02 libdrwx------ 2 root root 16K Jun 11 22:46 lost+founddrwxr-xr-x 2 root root 4.0K May 11 2011 mediadrwxr-xr-x 2 root root 4.0K Nov 8 2010 miscdrwxr-xr-x 2 root root 4.0K May 11 2011 mntdrwxr-xr-x 2 root root 4.0K May 11 2011 optdr-xr-xr-x 235 root root 0 Jun 15 11:04 procdrwxr-x--- 4 root root 4.0K Oct 15 14:43 rootdrwxr-xr-x 2 root root 12K Jun 12 04:03 sbindrwxr-xr-x 2 root root 4.0K May 11 2011 selinuxdrwxr-xr-x 2 root root 4.0K May 11 2011 srvdrwxr-xr-x 11 root root 0 Jun 15 11:04 sysdrwxrwxrwt 3 root root 96K Oct 16 08:49 tmpdrwxr-xr-x 13 root root 4.0K Jun 11 23:38 usrdrwxr-xr-x 19 root root 4.0K Jun 11 23:38 var 列出文件并标记颜色分类123[root@localhost nginx-1.2.1]# ls --color=autoauto CHANGES CHANGES.ru conf configure contrib html LICENSE Makefile man objs README src]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux命令</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Shell echo命令]]></title>
    <url>%2Fhexo-blog-deploy%2F2019%2F01%2F06%2F2019-01-linux-shell-echo%2F</url>
    <content type="text"><![CDATA[简介echo是Shell的一个内部指令，用于在屏幕上打印出指定的字符串。命令格式：1echo arg 用法案例转义字符 \1echo "\"It is a test\"" 显示变量 $12name="OK"echo "$name It is a test" 换行12345echo "OK!\n"echo "It is a test"# 输出：# OK!# It si a test 不换号1234echo "OK!\c"echo "It is a test"#输出：#OK!It si a test 重定向文件1echo "It is a test" &gt; myfile 原样输出 若需要原样输出字符串（不进行转义），请使用单引号1echo '$name\"' 命令执行结果123echo `date`# 或是echo $(date) 参考 echo命令]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>shell脚本</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[cd命令]]></title>
    <url>%2Fhexo-blog-deploy%2F2019%2F01%2F06%2F2019-01-linux-cmd-cd%2F</url>
    <content type="text"><![CDATA[简介cd命令用来切换工作目录至dirname。 其中dirName表示法可为绝对路径或相对路径。若目录名称省略，则变换至使用者的home directory(也就是刚login时所在的目录)。另外: ~也表示为home directory的意思 .则是表示目前所在的目录 ..则表示目前目录位置的上一层目录 语法1cd (选项) (参数) 选项123-p 如果要切换到的目标目录是一个符号连接，直接切换到符号连接指向的目标目录-L 如果要切换的目标目录是一个符号的连接，直接切换到字符连接名代表的目录，而非符号连接所指向的目标目录。- 当仅实用"-"一个选项时，当前工作目录将被切换到环境变量"OLDPWD"所表示的目录。 实例123456cd 进入用户主目录；cd ~ 进入用户主目录；cd - 返回进入此目录之前所在的目录；cd .. 返回上级目录（若当前目录为“/“，则执行完后还在“/"；".."为上级目录的意思）；cd ../.. 返回上两级目录；cd !$ 把上个命令的参数作为cd参数使用。]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux命令</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[pwd命令]]></title>
    <url>%2Fhexo-blog-deploy%2F2019%2F01%2F06%2F2019-01-linux-cmd-pwd%2F</url>
    <content type="text"><![CDATA[简介pwd命令以绝对路径的方式显示用户当前工作目录。命令将当前目录的全路径名称（从根目录）写入标准输出。全部目录使用/分隔。第一个/表示根目录，最后一个目录是当前目录。执行pwd命令可立刻得知您目前所在的工作目录的绝对路径名称。 语法1pwd（选项） 选项12--help：显示帮助信息；--version：显示版本信息。 实例12[root@localhost ~]# pwd/root]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux命令</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Shell数组：shell数组的定义、数组长度]]></title>
    <url>%2Fhexo-blog-deploy%2F2018%2F12%2F27%2F2018-12-linux-shell-array%2F</url>
    <content type="text"><![CDATA[简介Shell在编程方面比Windows批处理强大很多，无论是在循环、运算。 bash支持一维数组（不支持多维数组），并且没有限定数组的大小。类似与C语言，数组元素的下标由0开始编号。获取数组中的元素要利用下标，下标可以是整数或算术表达式，其值应大于或等于0。 定义数组在Shell中，用括号来表示数组，数组元素用“空格”符号分割开。定义数组的一般形式为： array_name=(value1 ... valuen)例如： 12345678910111213array_name1=(value0 value1 value2 value3)# 或者array_name2=(value0value1value2value3)# 还可以单独定义数组的各个分量：array_name3[0]=value0array_name3[1]=value1array_name3[2]=value2 可以不使用连续的下标，而且下标的范围没有限制。 读取数组读取数组元素值的一般格式是：${array_name[index]} 1valuen=$&#123;array_name[2]&#125; 例子1234567891011#!/bin/shNAME[0]="Zara"NAME[1]="Qadir"NAME[2]="Mahnaz"NAME[3]="Ayan"NAME[4]="Daisy"echo "First Index: $&#123;NAME[0]&#125;"echo "Second Index: $&#123;NAME[1]&#125;"# 输出# First Index: Zara# Second Index: Qadir 使用@ 或 * 可以获取数组中的所有元素12$&#123;array_name[*]&#125;$&#123;array_name[@]&#125; 例子1234567891011#!/bin/shNAME[0]="Zara"NAME[1]="Qadir"NAME[2]="Mahnaz"NAME[3]="Ayan"NAME[4]="Daisy"echo "First Method: $&#123;NAME[*]&#125;"echo "Second Method: $&#123;NAME[@]&#125;"# 输出# First Method: Zara Qadir Mahnaz Ayan Daisy# Second Method: Zara Qadir Mahnaz Ayan Daisy 获取数组的长度获取数组长度的方法与获取字符串长度的方法相同。123456# 取得数组元素的个数length=$&#123;#array_name[@]&#125;# 或者length=$&#123;#array_name[*]&#125;# 取得数组单个元素的长度lengthn=$&#123;#array_name[n]&#125;]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>shell脚本</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[sosreport命令]]></title>
    <url>%2Fhexo-blog-deploy%2F2018%2F12%2F27%2F2018-12-linux-cmd-sosreport%2F</url>
    <content type="text"><![CDATA[简介sosreport是一个类型于supportconfig 的工具，sosreport是python编写的一个工具，适用于centos（和redhat一样，包名为sos）、ubuntu（其下包名为sosreport）等大多数版本的linux 。sosreport在github上的托管页面为：https://github.com/sosreport/sos ，而且默认在很多系统的源里都已经集成有。如果使用的是正版redhat，在出现系统问题，寻求官方支持时，官方一般也会通过sosreport将收集的信息进行分析查看。需要注意的是在一些老的redhat发行版中叫sysreport —— 如redhat4.5之前的版本中。 sosreport的安装centos / redhat1yum -y insatll sos ubuntu下的安装1sudo apt-get install sosreport sosreport用法可以使用sosreport --help或man sosreport 获取使用帮助手册 sosreport命令进行系统环境收集1sosreport -a --report]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux命令</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Shell字符串]]></title>
    <url>%2Fhexo-blog-deploy%2F2018%2F12%2F24%2F2018-12-linux-shell-string%2F</url>
    <content type="text"><![CDATA[简介字符串是shell编程中最常用最有用的数据类型（除了数字和字符串，也没啥其它类型好用了），字符串可以用单引号，也可以用双引号，也可以不用引号。单双引号的区别跟PHP类似。 单引号1str='this is a string' 单引号字符串的限制： 单引号里的任何字符都会原样输出，单引号字符串中的变量是无效的； 单引号字串中不能出现单引号（对单引号使用转义符后也不行）。 双引号12your_name='qinjx'str="Hello, I know your are \"$your_name\"! \n" 双引号的优点 双引号里可以有变量 双引号里可以出现转义字符 拼接字符串1234567your_name="qinjx"greeting="hello, "$your_name" !"greeting_1="hello, $&#123;your_name&#125; !"echo $greeting $greeting_1# 输出# hello, qinjx ! hello, qinjx ! 获取字符串长度123string="abcd"echo $&#123;#string&#125; #输出 4 提取子字符串123string="alibaba is a great company"echo $&#123;string:1:4&#125; #输出liba 查找子字符串使用expr查找子串 123string="alibaba is a great company"echo `expr index "$string" is`# 输出 3]]></content>
      <tags>
        <tag>shell脚本</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[history命令]]></title>
    <url>%2Fhexo-blog-deploy%2F2018%2F12%2F24%2F2018-12-linux-cmd-history%2F</url>
    <content type="text"><![CDATA[简介history命令用于显示指定数目的指令命令，读取历史命令文件中的目录到历史命令缓冲区和将历史命令缓冲区中的目录写入命令文件。 该命令单独使用时，仅显示历史命令，在命令行中，可以使用符号!执行指定序号的历史命令。例如，要执行第2个历史命令，则输入!2。 历史命令是被保存在内存中的，当退出或者登录shell时，会自动保存或读取。在内存中，历史命令仅能够存储1000条历史命令，该数量是由环境变量HISTSIZE进行控制。 语法1history(选项)(参数) 选项1234-c：清空当前历史命令；-a：将历史命令缓冲区中命令写入历史命令文件中；-r：将历史命令文件中的命令读入当前历史命令缓冲区；-w：将当前历史命令缓冲区命令写入历史命令文件中。 参数n：打印最近的n条历史命令。 实例使用history命令显示最近使用的10条历史命令，输入如下命令：1234567891011[root@localhost ~]# history 10 92 ls 93 cd .. 94 ls 95 exit 96 ls -a 97 cd .ssh/ 98 ls 99 cat known_hosts 100 exit 101 history 10]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux命令</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[shell注释]]></title>
    <url>%2Fhexo-blog-deploy%2F2018%2F12%2F23%2F2018-12-linux-shell-annotation%2F</url>
    <content type="text"><![CDATA[使用#注释以#开头的行就是注释，会被解释器忽略。sh里没有多行注释，只能每一行加一个#号。 例子12345678910111213#--------------------------------------------# 这是一个自动打ipa的脚本，基于webfrogs的ipa-build书写：# https://github.com/webfrogs/xcode_shell/blob/master/ipa-build# 功能：自动为etao ios app打包，产出物为14个渠道的ipa包# 特色：全自动打包，不需要输入任何参数#--------------------------------------------##### 用户配置区 开始 ######## 项目根目录，推荐将此脚本放在项目的根目录，这里就不用改了# 应用名，确保和Xcode里Product下的target_name.app名字一致###### 用户配置区 结束 ##### 如何实现多行注释如果在开发过程中，遇到大段的代码需要临时注释起来，过一会儿又取消注释，怎么办呢？每一行加个#符号太费力了，可以把这一段要注释的代码用一对花括号括起来，定义成一个函数，没有地方调用这个函数，这块代码就不会执行，达到了和注释一样的效果。]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>shell脚本</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[last命令]]></title>
    <url>%2Fhexo-blog-deploy%2F2018%2F12%2F23%2F2018-12-linux-cmd-last%2F</url>
    <content type="text"><![CDATA[简介last命令用于显示用户最近登录信息。单独执行last命令，它会读取 /var/log/wtmp 的文件，并把该给文件的内容记录的登入系统的用户名单全部显示出来。 语法1last(选项)(参数) 选项123456-a：把从何处登入系统的主机名称或ip地址，显示在最后一行；-d：将IP地址转换成主机名称；-f &lt;记录文件&gt;：指定记录文件。-n &lt;显示列数&gt;或-&lt;显示列数&gt;：设置列出名单的显示列数；-R：不显示登入系统的主机名称或IP地址；-x：显示系统关机，重新开机，以及执行等级的改变等信息。 参数 用户名：显示用户登录列表； 终端：显示从指定终端的登录列表。 实例123456789101112# last命令用了显示用户登录情况，以下是直接显示固定行数的记录last -10root pts/0 221.6.45.34 Tue Dec 17 09:40 still logged inroot pts/0 221.6.45.34 Mon Dec 16 09:00 - 11:57 (02:56)root pts/0 222.94.97.122 Sun Dec 15 20:39 - 23:28 (02:48)root pts/0 222.95.209.80 Sat Dec 14 14:39 - 14:58 (00:18)root pts/0 221.6.45.34 Thu Dec 12 16:55 - 17:37 (00:41)root pts/0 49.65.139.195 Wed Dec 11 20:40 - 21:16 (00:35)root pts/0 49.65.139.195 Wed Dec 11 19:46 - 20:03 (00:17)root pts/0 221.6.45.34 Tue Dec 10 14:41 - 15:52 (01:10)root pts/0 221.6.45.34 Mon Dec 9 17:24 - 17:30 (00:06)root pts/0 221.6.45.34 Mon Dec 9 09:38 - 11:41 (02:02)]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux命令</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[who命令]]></title>
    <url>%2Fhexo-blog-deploy%2F2018%2F12%2F22%2F2018-12-linux-cmd-who%2F</url>
    <content type="text"><![CDATA[简介who命令是显示目前登录系统的用户信息。执行who命令可得知目前有那些用户登入系统，单独执行who命令会列出登入帐号，使用的终端机，登入时间以及从何处登入或正在使用哪个X显示器。 语法1who(选项)(参数) 选项12345678-H或--heading：显示各栏位的标题信息列；-i或-u或--idle：显示闲置时间，若该用户在前一分钟之内有进行任何动作，将标示成"."号，如果该用户已超过24小时没有任何动作，则标示出"old"字符串；-m：此参数的效果和指定"am i"字符串相同；-q或--count：只显示登入系统的帐号名称和总人数；-s：此参数将忽略不予处理，仅负责解决who指令其他版本的兼容性问题；-w或-T或--mesg或--message或--writable：显示用户的信息状态栏；--help：在线帮助；--version：显示版本信息。 参数文件：指定查询文件。 实例12345678910111213141516[root@localhost ~]# whoroot pts/0 2013-08-19 15:04 (192.168.0.134)root pts/1 2013-12-20 10:37 (180.111.155.40)[root@localhost ~]# who -qroot root# users=2[root@localhost ~]# who -HNAME LINE time COMMENTroot pts/0 2013-08-19 15:04 (192.168.0.134)root pts/1 2013-12-20 10:37 (180.111.155.40)[root@localhost ~]# who -wroot + pts/0 2013-08-19 15:04 (192.168.0.134)root + pts/1 2013-12-20 10:37 (180.111.155.40)]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux命令</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Shell运算符]]></title>
    <url>%2Fhexo-blog-deploy%2F2018%2F12%2F22%2F2018-12-linux-shell-operator%2F</url>
    <content type="text"><![CDATA[简介Bash 支持很多运算符，包括算数运算符、关系运算符、布尔运算符、字符串运算符和文件测试运算符。 算术运算符原生bash不支持简单的数学运算，但是可以通过其他命令来实现，例如 awk 和 expr，expr 最常用。12345#!/bin/bashval=`expr 2 + 2`echo "Total value : $val"# 输出# Total value : 4 注意 表达式和运算符之间要有空格，例如 2+2 是不对的，必须写成 2 + 2，这与我们熟悉的大多数编程语言不一样。 完整的表达式要被 包含，注意这个字符不是常用的单引号，在 Esc 键下边。 例子1234567891011121314151617181920212223242526272829#!/bin/sha=10b=20val=`expr $a + $b`echo "a + b : $val"val=`expr $a - $b`echo "a - b : $val"val=`expr $a \* $b`echo "a * b : $val"val=`expr $b / $a`echo "b / a : $val"val=`expr $b % $a`echo "b % a : $val"if [ $a == $b ]then echo "a is equal to b"fiif [ $a != $b ]then echo "a is not equal to b"fi# 输出# a + b : 30# a - b : -10# a * b : 200# b / a : 2# b % a : 0# a is not equal to b Notes 乘号(*)前边必须加反斜杠(\)才能实现乘法运算； 算术运算符列表 运算符 说明 举例 + 加法 expr $a + $b 结果为 30。 - 减法 expr $a - $b 结果为 10。 * 乘法 expr $a \* $b 结果为 200。 / 除法 expr $b / $a 结果为 2。 % 取余 expr $b % $a 结果为 0。 = 赋值 a=$b 将把变量 b 的值赋给 a。 == 相等。 用于比较两个数字，相同则返回 true。 [ $a == $b ] 返回 false。 != 不相等。 用于比较两个数字，不相同则返回 true。 [ $a != $b ] 返回 true。 Notes 条件表达式要放在方括号之间，并且要有空格，例如 [$a==$b] 是错误的，必须写成 [ $a == $b ]。 关系运算符关系运算符只支持数字，不支持字符串，除非字符串的值是数字 例子1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#!/bin/sha=10b=20if [ $a -eq $b ]then echo "$a -eq $b : a is equal to b"else echo "$a -eq $b: a is not equal to b"fiif [ $a -ne $b ]then echo "$a -ne $b: a is not equal to b"else echo "$a -ne $b : a is equal to b"fiif [ $a -gt $b ]then echo "$a -gt $b: a is greater than b"else echo "$a -gt $b: a is not greater than b"fiif [ $a -lt $b ]then echo "$a -lt $b: a is less than b"else echo "$a -lt $b: a is not less than b"fiif [ $a -ge $b ]then echo "$a -ge $b: a is greater or equal to b"else echo "$a -ge $b: a is not greater or equal to b"fiif [ $a -le $b ]then echo "$a -le $b: a is less or equal to b"else echo "$a -le $b: a is not less or equal to b"fi# 输出# 10 -eq 20: a is not equal to b# 10 -ne 20: a is not equal to b# 10 -gt 20: a is not greater than b# 10 -lt 20: a is less than b# 10 -ge 20: a is not greater or equal to b# 10 -le 20: a is less or equal to b 关系运算符列表 运算符 说明 举例 -eq 检测两个数是否相等，相等返回 true。 [ $a -eq $b ] 返回 true。 -ne 检测两个数是否相等，不相等返回 true。 [ $a -ne $b ] 返回 true。 -gt 检测左边的数是否大于右边的，如果是，则返回 true。 [ $a -gt $b ] 返回 false。 -lt 检测左边的数是否小于右边的，如果是，则返回 true。 [ $a -lt $b ] 返回 true。 -ge 检测左边的数是否大等于右边的，如果是，则返回 true。 [ $a -ge $b ] 返回 false。 -le 检测左边的数是否小于等于右边的，如果是，则返回 true。 [ $a -le $b ] 返回 true。 布尔运算符例子1234567891011121314151617181920212223242526272829303132#!/bin/sha=10b=20if [ $a != $b ]then echo "$a != $b : a is not equal to b"else echo "$a != $b: a is equal to b"fiif [ $a -lt 100 -a $b -gt 15 ]then echo "$a -lt 100 -a $b -gt 15 : returns true"else echo "$a -lt 100 -a $b -gt 15 : returns false"fiif [ $a -lt 100 -o $b -gt 100 ]then echo "$a -lt 100 -o $b -gt 100 : returns true"else echo "$a -lt 100 -o $b -gt 100 : returns false"fiif [ $a -lt 5 -o $b -gt 100 ]then echo "$a -lt 100 -o $b -gt 100 : returns true"else echo "$a -lt 100 -o $b -gt 100 : returns false"fi# 输出# 10 != 20 : a is not equal to b# 10 -lt 100 -a 20 -gt 15 : returns true# 10 -lt 100 -o 20 -gt 100 : returns true# 10 -lt 5 -o 20 -gt 100 : returns false 运算符 说明 举例 ! 非运算，表达式为 true 则返回 false，否则返回 true。 [ ! false ] 返回 true。 -o 或运算，有一个表达式为 true 则返回 true。 [ $a -lt 20 -o $b -gt 100 ] 返回 true。 -a 与运算，两个表达式都为 true 才返回 true。 [ $a -lt 20 -a $b -gt 100 ] 返回 false。 字符串运算符例子123456789101112131415161718192021222324252627282930313233343536373839#!/bin/sha="abc"b="efg"if [ $a = $b ]then echo "$a = $b : a is equal to b"else echo "$a = $b: a is not equal to b"fiif [ $a != $b ]then echo "$a != $b : a is not equal to b"else echo "$a != $b: a is equal to b"fiif [ -z $a ]then echo "-z $a : string length is zero"else echo "-z $a : string length is not zero"fiif [ -n $a ]then echo "-n $a : string length is not zero"else echo "-n $a : string length is zero"fiif [ $a ]then echo "$a : string is not empty"else echo "$a : string is empty"fi# 输出# abc = efg: a is not equal to b# abc != efg : a is not equal to b# -z abc : string length is not zero# -n abc : string length is not zero# abc : string is not empty 字符串运算符列表 运算符 说明 举例 = 检测两个字符串是否相等，相等返回 true。 [ $a = $b ] 返回 false。 != 检测两个字符串是否相等，不相等返回 true。 [ $a != $b ] 返回 true。 -z 检测字符串长度是否为0，为0返回 true。 [ -z $a ] 返回 false。 -n 检测字符串长度是否为0，不为0返回 true。 [ -z $a ] 返回 true。 str 检测字符串是否为空，不为空返回 true。 [ $a ] 返回 true。 文件测试运算符文件测试运算符用于检测 Unix 文件的各种属性。 例子123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354#!/bin/sh# 例如，变量 file 表示文件“/var/www/tutorialspoint/unix/test.sh”，它的大小为100字节，具有 rwx 权限。下面的代码，将检测该文件的各种属性：file="/var/www/tutorialspoint/unix/test.sh"if [ -r $file ]then echo "File has read access"else echo "File does not have read access"fiif [ -w $file ]then echo "File has write permission"else echo "File does not have write permission"fiif [ -x $file ]then echo "File has execute permission"else echo "File does not have execute permission"fiif [ -f $file ]then echo "File is an ordinary file"else echo "This is sepcial file"fiif [ -d $file ]then echo "File is a directory"else echo "This is not a directory"fiif [ -s $file ]then echo "File size is zero"else echo "File size is not zero"fiif [ -e $file ]then echo "File exists"else echo "File does not exist"fi# 输出# File has read access# File has write permission# File has execute permission# File is an ordinary file# This is not a directory# File size is zero# File exists 文件测试运算符列表 操作符 说明 举例 -b file 检测文件是否是块设备文件，如果是，则返回 true。 [ -b $file ] 返回 false。 -c file 检测文件是否是字符设备文件，如果是，则返回 true。 [ -b $file ] 返回 false。 -d file 检测文件是否是目录，如果是，则返回 true。 [ -d $file ] 返回 false。 -f file 检测文件是否是普通文件（既不是目录，也不是设备文件），如果是，则返回 true。 [ -f $file ] 返回 true -g file 检测文件是否设置了 SGID 位，如果是，则返回 true。 [ -g $file ] 返回 false。 -k file 检测文件是否设置了粘着位(Sticky Bit)，如果是，则返回 true。 [ -k $file ] 返回 false。 -p file 检测文件是否是具名管道，如果是，则返回 true。 [ -p $file ] 返回 false。 -u file 检测文件是否设置了 SUID 位，如果是，则返回 true。 [ -u $file ] 返回 false。 -r file 检测文件是否可读，如果是，则返回 true。 [ -r $file ] 返回 true。 -w file 检测文件是否可写，如果是，则返回 true 。 [ -w $file ] 返回 true。 -x file 检测文件是否可执行，如果是，则返回 true。 [ -x $file ] 返回 true。 -s file 检测文件是否为空（文件大小是否大于0），不为空返回 true。 [ -s $file ] 返回 true。 -e file 检测文件（包括目录）是否存在，如果是，则返回 true。 [ -e $file ] 返回 true。]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>shell脚本</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[linux-cmd-free]]></title>
    <url>%2Fhexo-blog-deploy%2F2018%2F12%2F20%2F2018-12-linux-cmd-free%2F</url>
    <content type="text"><![CDATA[简介free命令可以显示当前系统未使用的和已使用的内存数目，还可以显示被内核使用的内存缓冲区。 语法1free(选项) 选项1234567-b：以Byte为单位显示内存使用情况；-k：以KB为单位显示内存使用情况；-m：以MB为单位显示内存使用情况；-o：不显示缓冲区调节列；-s&lt;间隔秒数&gt;：持续观察内存使用状况；-t：显示内存总和列；-V：显示版本信息。 实例12345free -m total used free shared buffers cachedMem: 2016 1973 42 0 163 1497-/+ buffers/cache: 312 1703Swap: 4094 0 4094 第一部分Mem行解释123456total：内存总数；used：已经使用的内存数；free：空闲的内存数；shared：当前已经废弃不用；buffers Buffer：缓存内存数；cached Page：缓存内存数。 关系：total = used + free 第二部分(-/+ buffers/cache)解释12(-buffers/cache) used内存数：第一部分Mem行中的 used – buffers – cached(+buffers/cache) free内存数: 第一部分Mem行中的 free + buffers + cached 可见 -buffers/cache 反映的是被程序实实在在吃掉的内存，而 +buffers/cache 反映的是可以挪用的内存总数。 第三部分指交换分区。]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux命令</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Shell替换：Shell变量替换，命令替换，转义字符]]></title>
    <url>%2Fhexo-blog-deploy%2F2018%2F12%2F19%2F2018-12-linux-shell-replace%2F</url>
    <content type="text"><![CDATA[转义字符如果表达式中包含特殊字符，Shell 将会进行替换。例如，在双引号中使用变量就是一种替换，转义字符也是一种替换。 12345#!/bin/basha=10echo -e "Value of a is $a \n"# 运行结果# Value of a is 10 这里 -e 表示对转义字符进行替换。如果不使用 -e 选项，将会原样输出：1Value of a is 10\n 可以使用 echo 命令的 -E 选项禁止转义，默认也是不转义的；使用 -n 选项可以禁止插入换行符。 转义字符列表 转义字符 含义 \ 反斜杠 \a 警报，响铃 \b 退格（删除键） \f 换页(FF)，将当前位置移到下页开头 \n 换行 \r 回车 \t 水平制表符（tab键） \v 垂直制表符 命令替换命令替换是指Shell可以先执行命令，将输出结果暂时保存，在适当的地方输出。 命令替换的语法1234# 反引号`command`# 也可以使用圆括号$(command) 实例1234567#!/bin/bashDATE=`date`echo "Date is $DATE"USERS=`who | wc -l`echo "Logged in user are $USERS"UP=`date ; uptime`echo "Uptime is $UP" 输出:1234Date is Wed Dec 19 22:14:29 CST 2018Logged in user are 1Uptime is Wed Dec 19 22:14:29 CST 2018 22:14:29 up 11:19, 1 user, load average: 0.00, 0.01, 0.05 变量替换变量替换可以根据变量的状态（是否为空、是否定义等）来改变它的值 变量替换的列表 形式 说明 ${var} 变量本来的值 ${var:-word} 如果变量 var 为空或已被删除(unset)，那么返回 word，但不改变 var 的值。 ${var:=word} 如果变量 var 为空或已被删除(unset)，那么返回 word，并将 var 的值设置为 word。 ${var:?message} 如果变量 var 为空或已被删除(unset)，那么将消息 message 送到标准错误输出，可以用来检测变量var 是否可以被正常赋值。 若此替换出现在Shell脚本中，那么脚本将停止运行。 ${var:+word} 如果变量 var 被定义，那么返回 word，但不改变 var 的值。 实例123456789101112131415161718#!/bin/bashecho $&#123;var:-"Variable is not set"&#125;echo "1 - Value of var is $&#123;var&#125;"echo $&#123;var:="Variable is not set"&#125;echo "2 - Value of var is $&#123;var&#125;"unset varecho $&#123;var:+"This is default value"&#125;echo "3 - Value of var is $var"var="Prefix"echo $&#123;var:+"This is default value"&#125;echo "4 - Value of var is $var"echo $&#123;var:?"Print this message"&#125;echo "5 - Value of var is $&#123;var&#125;" 输出123456789Variable is not set1 - Value of var isVariable is not set2 - Value of var is Variable is not set3 - Value of var isThis is default value4 - Value of var is PrefixPrefix5 - Value of var is Prefix]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>shell脚本</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[uptime命令]]></title>
    <url>%2Fhexo-blog-deploy%2F2018%2F12%2F19%2F2018-12-linux-cmd-uptime%2F</url>
    <content type="text"><![CDATA[简介uptime命令能够打印系统总共运行了多长时间和系统的平均负载。uptime命令可以显示的信息显示依次为： 现在时间 系统已经运行了多长时间 目前有多少登陆用户 系统在过去的1分钟、5分钟和15分钟内的平均负载。 语法1uptime(选项) 选项1-V：显示指令的版本信息。 实例使用uptime命令查看系统负载：12345[root@LinServ-1 ~]# uptime -V #显示uptime命令版本信息procps version 3.2.7[root@LinServ-1 ~]# uptime 15:31:30 up 127 days, 3:00, 1 user, load average: 0.00, 0.00, 0.00 显示内容说明：123415:31:30 //系统当前时间up 127 days, 3:00 //主机已运行时间,时间越大，说明你的机器越稳定。1 user //用户连接数，是总连接数而不是用户数load average: 0.00, 0.00, 0.00 // 系统平均负载，统计最近1，5，15分钟的系统平均负载 Notes 那么什么是系统平均负载呢？ 系统平均负载是指在特定时间间隔内运行队列中的平均进程数。 如果每个CPU内核的当前活动进程数不大于3的话，那么系统的性能是良好的。如果每个CPU内核的任务数大于5，那么这台机器的性能有严重问题。如果你的linux主机是1个双核CPU的话，当Load Average 为6的时候说明机器已经被充分使用了。]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux命令</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[uname命令]]></title>
    <url>%2Fhexo-blog-deploy%2F2018%2F12%2F19%2F2018-12-linux-cmd-uname%2F</url>
    <content type="text"><![CDATA[简介uname命令用于打印当前系统相关信息（内核版本号、硬件架构、主机名称和操作系统类型等）。 语法1uname(选项) 选项1234567891011-a或--all：显示全部的信息；-m或--machine：显示电脑类型；-n或-nodename：显示在网络上的主机名称；-r或--release：显示操作系统的发行编号；-s或--sysname：显示操作系统名称；-v：显示操作系统的版本；-p或--processor：输出处理器类型或"unknown"；-i或--hardware-platform：输出硬件平台或"unknown"；-o或--operating-system：输出操作系统名称；--help：显示帮助；--version：显示版本信息。 实例使用uname命令查看全部信息：1234567891011121314151617181920212223242526272829303132333435363738[root@localhost ~]# uname #单独使用uname命令时相当于uname -sLinux[root@localhost ~]# uname -aLinux localhost 2.6.18-348.6.1.el5 #1 SMP Tue May 21 15:34:22 EDT 2013 i686 i686 i386 GNU/Linux[root@localhost ~]# uname -mi686[root@localhost ~]# uname -nlocalhost[root@localhost ~]# uname -r2.6.18-4-686[root@localhost ~]# uname -sLinux[root@localhost ~]# uname -v#1 SMP Tue May 21 15:34:22 EDT 2013[root@localhost ~]# uname -pi686[root@localhost ~]# uname -ii386[root@localhost ~]# uname -oGNU/Linux[root@localhost ~]# uname --versionuname (GNU coreutils) 8.26Copyright (C) 2016 Free Software Foundation, Inc.License GPLv3+: GNU GPL version 3 or later &lt;http://gnu.org/licenses/gpl.html&gt;.This is free software: you are free to change and redistribute it.There is NO WARRANTY, to the extent permitted by law.Written by David MacKenzie.]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux命令</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Shell特殊变量]]></title>
    <url>%2Fhexo-blog-deploy%2F2018%2F12%2F18%2F2018-12-linux-shell-specialvariable%2F</url>
    <content type="text"><![CDATA[简介变量名只能包含数字、字母和下划线，因为某些包含其他字符的变量有特殊含义，这样的变量被称为特殊变量。 特殊变量列表 变量 含义 $0 当前脚本的文件名 $n 传递给脚本或函数的参数。n 是一个数字，表示第几个参数。例如，第一个参数是$1，第二个参数是$2。 $# 传递给脚本或函数的参数个数。 $* 传递给脚本或函数的所有参数。 $@ 传递给脚本或函数的所有参数。被双引号(“ “)包含时，与 $* 稍有不同，下面将会讲到。 $? 上个命令的退出状态，或函数的返回值。 $$ 当前Shell进程ID。对于 Shell 脚本，就是这些脚本所在的进程ID。 命令行参数($n)运行脚本时传递给脚本的参数称为命令行参数。命令行参数用 $n 表示，例如，$1 表示第一个参数，$2 表示第二个参数，依次类推。 1234567#!/bin/bashecho "File Name: $0"echo "First Parameter : $1"echo "First Parameter : $2"echo "Quoted Values: $@"echo "Quoted Values: $*"echo "Total Number of Parameters : $#" 测试输出 1234567$./test.sh Zara AliFile Name : ./test.shFirst Parameter : ZaraSecond Parameter : AliQuoted Values: Zara AliQuoted Values: Zara AliTotal Number of Parameters : 2 $* 和 $@ 的区别$* 和 $@ 都表示传递给函数或脚本的所有参数，不被双引号(&quot; &quot;)包含时，都以”$1” “$2” … “$n” 的形式输出所有参数。 当它们被双引号(&quot; &quot;)包含时，&quot;$*&quot; 会将所有的参数作为一个整体，以&quot;$1 $2 … $n&quot;的形式输出所有参数；&quot;$@&quot; 会将各个参数分开，以&quot;$1&quot; &quot;$2&quot; … &quot;$n&quot; 的形式输出所有参数。 列子12345678910111213141516171819202122232425#!/bin/bashecho "\$*=" $*echo "\"\$*\"=" "$*"echo "\$@=" $@echo "\"\$@\"=" "$@"echo "print each param from \$*"for var in $*do echo "$var"doneecho "print each param from \$@"for var in $@do echo "$var"doneecho "print each param from \"\$*\""for var in "$*"do echo "$var"doneecho "print each param from \"\$@\""for var in "$@"do echo "$var"done 输出执行./test.sh &quot;a&quot; &quot;b&quot; &quot;c&quot; &quot;d&quot;123456789101112131415161718192021$*= a b c d"$*"= a b c d$@= a b c d"$@"= a b c dprint each param from $*abcdprint each param from $@abcdprint each param from "$*"a b c dprint each param from "$@"abcd 退出状态 $? 可以获取上一个命令的退出状态。所谓退出状态，就是上一个命令执行后的返回结果。 退出状态是一个数字，一般情况下，大部分命令执行成功会返回 0，失败返回 1。 不过，也有一些命令返回其他值，表示不同类型的错误。 $? 也可以表示函数的返回值]]></content>
      <tags>
        <tag>shell脚本</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ifconfig命令]]></title>
    <url>%2Fhexo-blog-deploy%2F2018%2F12%2F18%2F2018-12-linux-cmd-ifconfig%2F</url>
    <content type="text"><![CDATA[简介ifconfig命令被用于配置和显示Linux内核中网络接口的网络参数。用ifconfig命令配置的网卡信息，在网卡重启后机器重启后，配置就不存在。要想将上述的配置信息永远的存的电脑里，那就要修改网卡的配置文件了。 语法1ifconfig(参数) 参数123456789101112131415161718add&lt;地址&gt;：设置网络设备IPv6的ip地址；del&lt;地址&gt;：删除网络设备IPv6的IP地址；down：关闭指定的网络设备；&lt;hw&lt;网络设备类型&gt;&lt;硬件地址&gt;：设置网络设备的类型与硬件地址；io_addr&lt;I/O地址&gt;：设置网络设备的I/O地址；irq&lt;IRQ地址&gt;：设置网络设备的IRQ；media&lt;网络媒介类型&gt;：设置网络设备的媒介类型；mem_start&lt;内存地址&gt;：设置网络设备在主内存所占用的起始地址；metric&lt;数目&gt;：指定在计算数据包的转送次数时，所要加上的数目；mtu&lt;字节&gt;：设置网络设备的MTU；netmask&lt;子网掩码&gt;：设置网络设备的子网掩码；tunnel&lt;地址&gt;：建立IPv4与IPv6之间的隧道通信地址；up：启动指定的网络设备；-broadcast&lt;地址&gt;：将要送往指定地址的数据包当成广播数据包来处理；-pointopoint&lt;地址&gt;：与指定地址的网络设备建立直接连线，此模式具有保密功能；-promisc：关闭或启动指定网络设备的promiscuous模式；IP地址：指定网络设备的IP地址；网络设备：指定网络设备的名称。 实例显示网络设备信息（激活状态的）12345678910111213141516[root@localhost ~]# ifconfigeth0 Link encap:Ethernet HWaddr 00:16:3E:00:1E:51 inet addr:10.160.7.81 Bcast:10.160.15.255 Mask:255.255.240.0 UP BROADCAST RUNNING MULTICAST MTU:1500 Metric:1 RX packets:61430830 errors:0 dropped:0 overruns:0 frame:0 TX packets:88534 errors:0 dropped:0 overruns:0 carrier:0 collisions:0 txqueuelen:1000 RX bytes:3607197869 (3.3 GiB) TX bytes:6115042 (5.8 MiB)lo Link encap:Local Loopback inet addr:127.0.0.1 Mask:255.0.0.0 UP LOOPBACK RUNNING MTU:16436 Metric:1 RX packets:56103 errors:0 dropped:0 overruns:0 frame:0 TX packets:56103 errors:0 dropped:0 overruns:0 carrier:0 collisions:0 txqueuelen:0 RX bytes:5079451 (4.8 MiB) TX bytes:5079451 (4.8 MiB) 说明： eth0表示第一块网卡，其中HWaddr表示网卡的物理地址，可以看到目前这个网卡的物理地址(MAC地址）是00:16:3E:00:1E:51。 inet addr用来表示网卡的IP地址，此网卡的IP地址是10.160.7.81，广播地址Bcast:10.160.15.255，掩码地址Mask:255.255.240.0。 lo是表示主机的回环地址，这个一般是用来测试一个网络程序，但又不想让局域网或外网的用户能够查看，只能在此台主机上运行和查看所用的网络接口。比如把 httpd服务器的指定到回环地址，在浏览器输入127.0.0.1就能看到你所架WEB网站了。但只是您能看得到，局域网的其它主机或用户无从知道 第一行：连接类型：Ethernet（以太网）HWaddr（硬件mac地址）。 第二行：网卡的IP地址、子网、掩码。 第三行：UP（代表网卡开启状态）RUNNING（代表网卡的网线被接上）MULTICAST（支持组播）MTU:1500（最大传输单元）：1500字节。 第四、五行：接收、发送数据包情况统计。 第七行：接收、发送数据字节数统计信息。 启动关闭指定网卡12ifconfig eth0 upifconfig eth0 down ifconfig eth0 up为启动网卡eth0，ifconfig eth0 down为关闭网卡eth0。ssh登陆linux服务器操作要小心，关闭了就不能开启了，除非你有多网卡。 用ifconfig修改MAC地址：1ifconfig eth0 hw ether 00:AA:BB:CC:dd:EE 配置IP地址123[root@localhost ~]# ifconfig eth0 192.168.2.10[root@localhost ~]# ifconfig eth0 192.168.2.10 netmask 255.255.255.0[root@localhost ~]# ifconfig eth0 192.168.2.10 netmask 255.255.255.0 broadcast 192.168.2.255 启用和关闭arp协议12ifconfig eth0 arp #开启网卡eth0 的arp协议ifconfig eth0 -arp #关闭网卡eth0 的arp协议 设置最大传输单元1ifconfig eth0 mtu 1500 #设置能通过的最大数据包大小为 1500 bytes]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux命令</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[killall命令]]></title>
    <url>%2Fhexo-blog-deploy%2F2018%2F12%2F16%2F2018-12-linux-cmd-killall%2F</url>
    <content type="text"><![CDATA[简介killall命令使用进程的名称来杀死进程，使用此指令可以杀死一组同名进程。我们可以使用kill命令杀死指定进程PID的进程，如果要找到我们需要杀死的进程，我们还需要在之前使用ps等命令再配合grep来查找进程，而killall把这两个过程合二为一，是一个很好用的命令。 语法1killall(选项)(参数) 选项123456789-e：对长名称进行精确匹配；-l：忽略大小写的不同；-p：杀死进程所属的进程组；-i：交互式杀死进程，杀死进程前需要进行确认；-l：打印所有已知信号列表；-q：如果没有进程被杀死。则不输出任何信息；-r：使用正规表达式匹配要杀死的进程名称；-s：用指定的进程号代替默认信号“SIGTERM”；-u：杀死指定用户的进程。 参数进程名称：指定要杀死的进程名称。 实例1killall vi]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux命令</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[kill命令]]></title>
    <url>%2Fhexo-blog-deploy%2F2018%2F12%2F15%2F2018-12-linux-cmd-kill%2F</url>
    <content type="text"><![CDATA[简介kill命令用来删除执行中的程序或工作。kill可将指定的信息送至程序。预设的信息为SIGTERM(15),可将指定程序终止。若仍无法终止该程序，可使用SIGKILL(9)信息尝试强制删除程序。程序或工作的编号可利用ps指令或job指令查看。 语法1kill(选项)(参数) 选项12345-a：当处理当前进程时，不限制命令名和进程号的对应关系；-l &lt;信息编号&gt;：若不加&lt;信息编号&gt;选项，则-l参数会列出全部的信息名称；-p：指定kill 命令只打印相关进程的进程号，而不发送任何信号；-s &lt;信息名称或编号&gt;：指定要送出的信息；-u：指定用户。 参数进程或作业识别号：指定要删除的进程或作业。 实例列出所有信号名称1234567891011121314151617 kill -l 1) SIGHUP 2) SIGINT 3) SIGQUIT 4) SIGILL 5) SIGTRAP 6) SIGABRT 7) SIGBUS 8) SIGFPE 9) SIGKILL 10) SIGUSR1 11) SIGSEGV 12) SIGUSR213) SIGPIPE 14) SIGALRM 15) SIGTERM 16) SIGSTKFLT17) SIGCHLD 18) SIGCONT 19) SIGSTOP 20) SIGTSTP21) SIGTTIN 22) SIGTTOU 23) SIGURG 24) SIGXCPU25) SIGXFSZ 26) SIGVTALRM 27) SIGPROF 28) SIGWINCH29) SIGIO 30) SIGPWR 31) SIGSYS 34) SIGRTMIN35) SIGRTMIN+1 36) SIGRTMIN+2 37) SIGRTMIN+3 38) SIGRTMIN+439) SIGRTMIN+5 40) SIGRTMIN+6 41) SIGRTMIN+7 42) SIGRTMIN+843) SIGRTMIN+9 44) SIGRTMIN+10 45) SIGRTMIN+11 46) SIGRTMIN+1247) SIGRTMIN+13 48) SIGRTMIN+14 49) SIGRTMIN+15 50) SIGRTMAX-1451) SIGRTMAX-13 52) SIGRTMAX-12 53) SIGRTMAX-11 54) SIGRTMAX-1055) SIGRTMAX-9 56) SIGRTMAX-8 57) SIGRTMAX-7 58) SIGRTMAX-659) SIGRTMAX-5 60) SIGRTMAX-4 61) SIGRTMAX-3 62) SIGRTMAX-263) SIGRTMAX-1 64) SIGRTMAX 只有第9种信号(SIGKILL)才可以无条件终止进程，其他信号进程都有权利忽略，下面是常用的信号 1234567HUP 1 终端断线INT 2 中断（同 Ctrl + C）QUIT 3 退出（同 Ctrl + \）TERM 15 终止KILL 9 强制终止CONT 18 继续（与STOP相反， fg/bg命令）STOP 19 暂停（同 Ctrl + Z） 先用ps查找进程，然后用kill杀掉1234567ps -ef | grep vimroot 3268 2884 0 16:21 pts/1 00:00:00 vim install.logroot 3370 2822 0 16:21 pts/0 00:00:00 grep vimkill 3268kill 3268-bash: kill: (3268) - 没有那个进程]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux命令</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Shell变量]]></title>
    <url>%2Fhexo-blog-deploy%2F2018%2F12%2F11%2F2018-12-linux-shell-variable%2F</url>
    <content type="text"><![CDATA[Shell变量简介在Bash shell 中，每一个变量的值都是字符串，无论你给变量赋值时有没有使用引号，值都会以字符串的形式存储。这意味着，Bash shell 在默认情况下不会区分变量类型，即使你将整数和小数赋值给变量，它们也会被视为字符串，这一点和大部分的编程语言不同。脚本语言在定义变量时通常不需要指明类型，直接赋值就可以，Shell 变量也遵循这个规则。 定义变量Shell 支持以下三种定义变量的方式：123variable=valuevariable='value'variable="value" variable 是变量名，value 是赋给变量的值 如果 value 不包含任何空白符（例如空格、Tab缩进等），那么可以不使用引号； 如果 value 包含了空白符，那么就必须使用引号包围起来 Notes 赋值号的周围不能有空格，这与绝大多数的编程语言不同。 命名规范 变量名由数字、字母、下划线组成； 必须以字母或者下划线开头； 不能使用 Shell 里的关键字（通过 help 命令可以查看保留关键字）。 单引号和双引号的区别 以单引号&#39; &#39;包围变量的值时，单引号里面是什么就输出什么，即使内容中有变量和命令（命令需要反引起来）也会把它们原样输出。这种方式比较适合定义显示纯字符串的情况，即不希望解析变量、命令等的场景。 以双引号&quot; &quot;包围变量的值时，输出时会先解析里面的变量和命令，而不是把双引号中的变量名和命令原样输出。这种方式比较适合字符串中附带有变量和命令并且想将其解析后再输出的变量定义。 例子 123456789#!/bin/bashurl="https://liuhll.github.io/hexo-blog-deploy/"website1='我的个人博客网站：$&#123;url&#125;'website2="我的个人博客网站:$&#123;url&#125;"echo $website1echo $website2# 输出# 我的个人博客网站：$&#123;url&#125;# 我的个人博客网站:https//liuhll.github.io/hexo-blog-deploy/ 使用建议 如果变量的内容是数字，那么可以不加引号； 如果真的需要原样输出就加单引号； 其他没有特别要求的字符串等最好都加上双引号，定义变量时加双引号是最常见的使用场景。 使用变量使用一个定义过的变量，只要在变量名前面加美元符号$即可。123author="刘洪亮"echo $authorecho $&#123;author&#125; 变量名外面的花括号{ }是可选的，加不加都行，加花括号是为了帮助解释器识别变量的边界。12skill="java"echo "I am good at $&#123;skill&#125;Script" 如果不给skill 变量加花括号，写成echo &quot;I am good at $skillScript&quot;，解释器就会把 $skillScript当成一个变量（其值为空），代码执行结果就不是我们期望的样子了。 Notes推荐给所有变量加上花括号{ }，这是个良好的编程习惯 修改变量的值 已定义的变量，可以被重新赋值。 第二次对变量赋值时不能在变量名前加$，只有在使用变量时才能加$。 1234url="https://liuhll.github.io"echo $&#123;url&#125;url="https://liuhll.github.io/hexo-blog-deploy/"echo $&#123;url&#125; 将命令的结果赋值给变量Shell 也支持将命令的执行结果赋值给变量，常见的有以下两种方式12variable=`command`variable=$(command) 第一种方式把命令用反引号包围起来，反引号和单引号非常相似，容易产生混淆，所以不推荐使用这种方式； 第二种方式把命令用$()包围起来，区分更加明显，所以推荐使用这种方式。 只读变量使用 readonly 命令可以将变量定义为只读变量，只读变量的值不能被改变。 尝试更改只读变量，结果报错。 12345#!/bin/bashmyUrl="https://liuhll.github.io"readonly myUrlmyUrl="https://liuhll.github.io/hexo-blog-deploy/"# error output =&gt; /bin/sh: NAME: This variable is read only. 删除变量 使用 unset 命令可以删除变量，变量被删除后不能再次使用 unset 命令不能删除只读变量。 12345#!/bin/shmyUrl="https://liuhll.github.io/hexo-blog-deploy/"unset myUrlecho $myUrl# 脚本没有任何输出 变量类型1.局部变量局部变量在脚本或命令中定义，仅在当前shell实例中有效，其他shell启动的程序不能访问局部变量。 2.环境变量所有的程序，包括shell启动的程序，都能访问环境变量，有些程序需要环境变量来保证其正常运行。必要的时候shell脚本也可以定义环境变量。 3.shell变量shell变量是由shell程序设置的特殊变量。shell变量中有一部分是环境变量，有一部分是局部变量，这些变量保证了shell的正常运行]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>shell脚本</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[top命令]]></title>
    <url>%2Fhexo-blog-deploy%2F2018%2F12%2F11%2F2018-12-linux-cmd-top%2F</url>
    <content type="text"><![CDATA[简介top命令可以实时动态地查看系统的整体运行情况，是一个综合了多方信息监测系统性能和运行信息的实用工具。通过top命令所提供的互动式界面，用热键可以管理。 语法1top(选项) 选项12345678910-b：以批处理模式操作；-c：显示完整的治命令；-d：屏幕刷新间隔时间；-I：忽略失效过程；-s：保密模式；-S：累积模式；-i&lt;时间&gt;：设置间隔时间；-u&lt;用户名&gt;：指定用户名；-p&lt;进程号&gt;：指定进程；-n&lt;次数&gt;：循环显示的次数。 top交互命令在top命令执行过程中可以使用的一些交互命令。这些命令都是单字母的，如果在命令行中使用了-s选项， 其中一些命令可能会被屏蔽。 12345678910-b：以批处理模式操作；-c：显示完整的治命令；-d：屏幕刷新间隔时间；-I：忽略失效过程；-s：保密模式；-S：累积模式；-i&lt;时间&gt;：设置间隔时间；-u&lt;用户名&gt;：指定用户名；-p&lt;进程号&gt;：指定进程；-n&lt;次数&gt;：循环显示的次数。 实例12345top - 09:44:56 up 16 days, 21:23, 1 user, load average: 9.59, 4.75, 1.92Tasks: 145 total, 2 running, 143 sleeping, 0 stopped, 0 zombieCpu(s): 99.8%us, 0.1%sy, 0.0%ni, 0.2%id, 0.0%wa, 0.0%hi, 0.0%si, 0.0%stMem: 4147888k total, 2493092k used, 1654796k free, 158188k buffersSwap: 5144568k total, 56k used, 5144512k free, 2013180k cached 解释 top - 09:44:56[当前系统时间], 16 days[系统已经运行了16天], 1 user[个用户当前登录], load average: 9.59, 4.75, 1.92[系统负载，即任务队列的平均长度] Tasks: 145 total[总进程数], 2 running[正在运行的进程数], 143 sleeping[睡眠的进程数], 0 stopped[停止的进程数], 0 zombie[冻结进程数], Cpu(s): 99.8%us[用户空间占用CPU百分比], 0.1%sy[内核空间占用CPU百分比], 0.0%ni[用户进程空间内改变过优先级的进程占用CPU百分比], 0.2%id[空闲CPU百分比], 0.0%wa[等待输入输出的CPU时间百分比], 0.0%hi[], 0.0%st[], Mem: 4147888k total[物理内存总量], 2493092k used[使用的物理内存总量], 1654796k free[空闲内存总量], 158188k buffers[用作内核缓存的内存量] Swap: 5144568k total[交换区总量], 56k used[使用的交换区总量], 5144512k free[空闲交换区总量], 2013180k cached[缓冲的交换区总量],]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux命令</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ps命令]]></title>
    <url>%2Fhexo-blog-deploy%2F2018%2F12%2F11%2F2018-12-linux-cmd-ps%2F</url>
    <content type="text"><![CDATA[简介ps命令用于报告当前系统的进程状态。可以搭配kill指令随时中断、删除不必要的程序。ps命令是最基本同时也是非常强大的进程查看命令，使用该命令可以确定有哪些进程正在运行和运行的状态、进程是否结束、进程有没有僵死、哪些进程占用了过多的资源等等，总之大部分信息都是可以通过执行该命令得到的 语法1ps(选项) 选项1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162-a：显示所有终端机下执行的程序，除了阶段作业领导者之外。a：显示现行终端机下的所有程序，包括其他用户的程序。-A：显示所有程序。-c：显示CLS和PRI栏位。c：列出程序时，显示每个程序真正的指令名称，而不包含路径，选项或常驻服务的标示。-C&lt;指令名称&gt;：指定执行指令的名称，并列出该指令的程序的状况。-d：显示所有程序，但不包括阶段作业领导者的程序。-e：此选项的效果和指定"A"选项相同。e：列出程序时，显示每个程序所使用的环境变量。-f：显示UID,PPIP,C与STIME栏位。f：用ASCII字符显示树状结构，表达程序间的相互关系。-g&lt;群组名称&gt;：此选项的效果和指定"-G"选项相同，当亦能使用阶段作业领导者的名称来指定。g：显示现行终端机下的所有程序，包括群组领导者的程序。-G&lt;群组识别码&gt;：列出属于该群组的程序的状况，也可使用群组名称来指定。h：不显示标题列。-H：显示树状结构，表示程序间的相互关系。-j或j：采用工作控制的格式显示程序状况。-l或l：采用详细的格式来显示程序状况。L：列出栏位的相关信息。-m或m：显示所有的执行绪。n：以数字来表示USER和WCHAN栏位。-N：显示所有的程序，除了执行ps指令终端机下的程序之外。-p&lt;程序识别码&gt;：指定程序识别码，并列出该程序的状况。p&lt;程序识别码&gt;：此选项的效果和指定"-p"选项相同，只在列表格式方面稍有差异。r：只列出现行终端机正在执行中的程序。-s&lt;阶段作业&gt;：指定阶段作业的程序识别码，并列出隶属该阶段作业的程序的状况。s：采用程序信号的格式显示程序状况。S：列出程序时，包括已中断的子程序资料。-t&lt;终端机编号&gt;：指定终端机编号，并列出属于该终端机的程序的状况。t&lt;终端机编号&gt;：此选项的效果和指定"-t"选项相同，只在列表格式方面稍有差异。-T：显示现行终端机下的所有程序。-u&lt;用户识别码&gt;：此选项的效果和指定"-U"选项相同。u：以用户为主的格式来显示程序状况。-U&lt;用户识别码&gt;：列出属于该用户的程序的状况，也可使用用户名称来指定。U&lt;用户名称&gt;：列出属于该用户的程序的状况。v：采用虚拟内存的格式显示程序状况。-V或V：显示版本信息。-w或w：采用宽阔的格式来显示程序状况。 x：显示所有程序，不以终端机来区分。X：采用旧式的Linux i386登陆格式显示程序状况。-y：配合选项"-l"使用时，不显示F(flag)栏位，并以RSS栏位取代ADDR栏位 。-&lt;程序识别码&gt;：此选项的效果和指定"p"选项相同。--cols&lt;每列字符数&gt;：设置每列的最大字符数。--columns&lt;每列字符数&gt;：此选项的效果和指定"--cols"选项相同。--cumulative：此选项的效果和指定"S"选项相同。--deselect：此选项的效果和指定"-N"选项相同。--forest：此选项的效果和指定"f"选项相同。--headers：重复显示标题列。--help：在线帮助。--info：显示排错信息。--lines&lt;显示列数&gt;：设置显示画面的列数。--no-headers：此选项的效果和指定"h"选项相同，只在列表格式方面稍有差异。--group&lt;群组名称&gt;：此选项的效果和指定"-G"选项相同。--Group&lt;群组识别码&gt;：此选项的效果和指定"-G"选项相同。--pid&lt;程序识别码&gt;：此选项的效果和指定"-p"选项相同。--rows&lt;显示列数&gt;：此选项的效果和指定"--lines"选项相同。--sid&lt;阶段作业&gt;：此选项的效果和指定"-s"选项相同。--tty&lt;终端机编号&gt;：此选项的效果和指定"-t"选项相同。--user&lt;用户名称&gt;：此选项的效果和指定"-U"选项相同。--User&lt;用户识别码&gt;：此选项的效果和指定"-U"选项相同。--version：此选项的效果和指定"-V"选项相同。--widty&lt;每列字符数&gt;：此选项的效果和指定"-cols"选项相同。 Notes由于ps命令能够支持的系统类型相当的多，所以ps命令的选项非常的多。]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux命令</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[wget命令]]></title>
    <url>%2Fhexo-blog-deploy%2F2018%2F12%2F03%2F2018-12-linux-cmd-wget%2F</url>
    <content type="text"><![CDATA[简介wget命令用来从指定的URL下载文件。wget非常稳定，它在带宽很窄的情况下和不稳定网络中有很强的适应性，如果是由于网络的原因下载失败，wget会不断的尝试，直到整个文件下载完毕。如果是服务器打断下载过程，它会再次联到服务器上从停止的地方继续下载。这对从那些限定了链接时间的服务器上下载大文件非常有用。 语法1wget(选项)(参数) 选项12345678910111213141516171819202122-a&lt;日志文件&gt;：在指定的日志文件中记录资料的执行过程；-A&lt;后缀名&gt;：指定要下载文件的后缀名，多个后缀名之间使用逗号进行分隔；-b：进行后台的方式运行wget；-B&lt;连接地址&gt;：设置参考的连接地址的基地地址；-c：继续执行上次终端的任务；-C&lt;标志&gt;：设置服务器数据块功能标志on为激活，off为关闭，默认值为on；-d：调试模式运行指令；-D&lt;域名列表&gt;：设置顺着的域名列表，域名之间用“，”分隔；-e&lt;指令&gt;：作为文件“.wgetrc”中的一部分执行指定的指令；-h：显示指令帮助信息；-i&lt;文件&gt;：从指定文件获取要下载的URL地址；-l&lt;目录列表&gt;：设置顺着的目录列表，多个目录用“，”分隔；-L：仅顺着关联的连接；-r：递归下载方式；-nc：文件存在时，下载文件不覆盖原有文件；-nv：下载时只显示更新和出错信息，不显示指令的详细执行过程；-q：不显示指令执行过程；-nh：不查询主机名称；-v：显示详细执行过程；-V：显示版本信息；--passive-ftp：使用被动模式PASV连接FTP服务器；--follow-ftp：从HTML文件中下载FTP连接文件。 参数URL：下载指定的URL地址。 实例使用wget下载单个文件从网络下载一个文件并保存在当前目录，在下载的过程中会显示进度条，包含（下载完成百分比，已经下载的字节，当前下载速度，剩余下载时间）。 1wget http://www.linuxde.net/testfile.zip 下载并以不同的文件名保存wget默认会以最后一个符合/的后面的字符来命令，对于动态链接的下载通常文件名会不正确,例如:参数url为: http://www.linuxde.net/download.aspx?id=1080 即使下载的文件是zip格式，它仍然以download.php?id=1080命名。为了解决这个问题，我们可以使用参数-O来指定一个文件名。 1wget -O wordpress.zip http://www.linuxde.net/download.aspx?id=1080 wget限速下载当你执行wget的时候，它默认会占用全部可能的宽带下载。但是当你准备下载一个大文件，而你还需要下载其它文件时就有必要限速了 1wget --limit-rate=300k http://www.linuxde.net/testfile.zip 使用wget断点续传使用wget -c重新启动下载中断的文件，对于我们下载大文件时突然由于网络等原因中断非常有帮助，我们可以继续接着下载而不是重新下载一个文件。需要继续中断的下载时可以使用-c参数。1wget -c http://www.linuxde.net/testfile.zip 使用wget后台下载对于下载非常大的文件的时候，我们可以使用参数-b进行后台下载。1234wget -b http://www.linuxde.net/testfile.zipContinuing in background, pid 1840.Output will be written to `wget-log'. 可以使用以下命令来察看下载进度: 1tail -f wget-log 伪装代理名称下载有些网站能通过根据判断代理名称不是浏览器而拒绝你的下载请求。不过你可以通过--user-agent参数伪装1wget --user-agent="Mozilla/5.0 (Windows; U; Windows NT 6.1; en-US) AppleWebKit/534.16 (KHTML, like Gecko) Chrome/10.0.648.204 Safari/534.16" http://www.linuxde.net/testfile.zip 测试下载链接当你打算进行定时下载，你应该在预定时间测试下载链接是否有效。我们可以增加--spider参数进行检查。12345678910111213wget --spider URL# 如果下载链接正确，将会显示Spider mode enabled. Check if remote file exists.HTTP request sent, awaiting response... 200 OKLength: unspecified [text/html]Remote file exists and could contain further links,but recursion is disabled -- not retrieving.# 但当你给错了一个链接，将会显示如下错误Spider mode enabled. Check if remote file exists.HTTP request sent, awaiting response... 404 Not FoundRemote file does not exist -- broken link!!! 在以下几种情况下使用--spider参数 定时下载之前进行检查 间隔检测网站是否可用 检查网站页面的死链接 增加重试次数如果网络有问题或下载一个大文件也有可能失败。wget默认重试20次连接下载文件。如果需要，你可以使用--tries增加重试次数。1wget --tries=40 URL 下载多个文件 保存一份下载链接文件 12345cat &gt; filelist.txturl1url2url3url4 使用这个文件和参数-i下载 1wget -i filelist.txt 下载指定格式文件1wget -r -A.pdf url 使用场景: 下载一个网站的所有图片。 下载一个网站的所有视频。 下载一个网站的所有PDF文件。 FTP下载可以使用wget来完成ftp链接的下载12wget ftp-urlwget --ftp-user=USERNAME --ftp-password=PASSWORD url]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux命令</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Shell提示符($和#的区别)]]></title>
    <url>%2Fhexo-blog-deploy%2F2018%2F12%2F02%2F2018-12-linux-shell-prompt%2F</url>
    <content type="text"><![CDATA[简介启动终端模拟包或者从 Linux 控制台登录后，便可以看到 Shell 提示符。提示符是通往 Shell 的大门，是输入 Shell 命令的地方。 普通用户的提示符$普通用户的提示符是美元符号$。 超级用户提示符#超级用户(root)的提示服务好井号#。 提示符格式不同的 Linux 发行版使用的提示符格式不同。例如在 CentOS 中，默认的提示符格式为：1[liunx@liuhl-ubuntu ~]$ ubuntu的提示符格式为:1liuhl@liuhl-ubuntu:~$ 提示符格式一般包含三方面的信息: 启动 Shell 的用户名，也即 liuhl； 本地主机名称，也即 liuhl-ubuntu 当前目录，波浪号~是主目录的简写表示法。 Shell 通过PS1和PS2两个环境变量来控制提示符格式: PS1 控制最外层命令行的提示符格式。 12liuhl@liuhl-ubuntu:~$ echo $PS1\[\e]0;\u@\h: \w\a\]$&#123;debian_chroot:+($debian_chroot)&#125;\u@\h:\w\$ PS2 控制第二层命令行的提示符格式。 1234567liuhl@liuhl-ubuntu:~$ echo $PS2&gt;liuhl@liuhl-ubuntu ~$ echo "&gt; yan&gt; chang&gt; sheng&gt; " Shell 使用以\为前导的特殊字符来表示命令提示符中包含的要素，这使得 PS1 和 PS2 的格式看起来可能有点奇怪。下表展示了可以在 PS1 和 PS2 中使用的特殊字符。 字符 描述 \a 铃声字符 \d 格式为“日 月 年”的日期 \e ASCII转义字符 \h 本地主机名 \H 完全合格的限定域主机名 \j shell当前管理的作业数 \1 shell终端设备名的基本名称 \n ASCII换行字符 \r ASCII回车 \s shell的名称 \t 格式为“小时:分钟:秒”的24小时制的当前时间 \T 格式为“小时:分钟:秒”的12小时制的当前时间 \@ 格式为am/pm的12小时制的当前时间 \u 当前用户的用户名 \v bash shell的版本 \V bash shell的发布级别 \w 当前工作目录 \W 当前工作目录的基本名称 ! 该命令的bash shell历史数 # 该命令的命令数量 \$ 如果是普通用户，则为美元符号$；如果超级用户（root 用户），则为井号#。 \nnn 对应于八进制值 nnn 的字符 \ 斜杠 [ 控制码序列的开头 ] 控制码序列的结尾 修改提示符12[liuhl@localhost ~]$ PS1="[\t][\u]\$ "[22:14:34][liuhl]$ 新的 Shell 提示符现在可以显示当前的时间和用户名。不过这个新定义的 PS1 变量只在当前 Shell 会话期间有效，再次启动 Shell 时将重新使用默认的提示符格式。]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>shell脚本</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[poweroff命令]]></title>
    <url>%2Fhexo-blog-deploy%2F2018%2F12%2F02%2F2018-12-linux-cmd-poweroff%2F</url>
    <content type="text"><![CDATA[简介poweroff命令用来关闭计算机操作系统并且切断系统电源。 语法1poweroff(选项) 选项123456-n：关闭操作系统时不执行sync操作；-w：不真正关闭操作系统，仅在日志文件“/var/log/wtmp”中；-d：关闭操作系统时，不将操作写入日志文件“/var/log/wtmp”中添加相应的记录；-f：强制关闭操作系统；-i：关闭操作系统之前关闭所有的网络接口；-h：关闭操作系统之前将系统中所有的硬件设置为备用模式。 实例如果确认系统中已经没有用户存在且所有数据都已保存，需要立即关闭系统，可以使用poweroff命令。 使用poweroff立即关闭系统： 1poweroff]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux命令</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[reboot命令]]></title>
    <url>%2Fhexo-blog-deploy%2F2018%2F12%2F02%2F2018-12-linux-cmd-reboot%2F</url>
    <content type="text"><![CDATA[简介reboot命令用来重新启动正在运行的Linux操作系统。 语法1reboot(选项) 选项12345-d：重新开机时不把数据写入记录文件/var/tmp/wtmp。本参数具有“-n”参数效果；-f：强制重新开机，不调用shutdown指令的功能；-i：在重开机之前，先关闭所有网络界面；-n：重开机之前不检查是否有未结束的程序；-w：仅做测试，并不真正将系统重新开机，只会把重开机的数据写入/var/log目录下的wtmp记录文件 实例12reboot //重开机。reboot -w //做个重开机的模拟（只有纪录并不会真的重开机）。]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux命令</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[date命令]]></title>
    <url>%2Fhexo-blog-deploy%2F2018%2F12%2F01%2F2018-12-linux-cmd-date%2F</url>
    <content type="text"><![CDATA[简介date命令是显示或设置系统时间与日期。 很多shell脚本里面需要打印不同格式的时间或日期，以及要根据时间和日期执行操作。延时通常用于脚本执行过程中提供一段等待的时间。日期可以以多种格式去打印，也可以使用命令设置固定的格式。在类UNIX系统中，日期被存储为一个整数，其大小为自世界标准时间（UTC）1970年1月1日0时0分0秒起流逝的秒数。 语法1date(选项)(参数) 选项12345-d&lt;字符串&gt;：显示字符串所指的日期与时间。字符串前后必须加上双引号；-s&lt;字符串&gt;：根据字符串来设置日期与时间。字符串前后必须加上双引号；-u：显示GMT；--help：在线帮助；--version：显示版本信息。 参数&lt;+时间日期格式&gt;：指定显示时使用的日期时间格式。 日期格式字符串列表123456789101112131415161718192021222324%H 小时，24小时制（00~23）%I 小时，12小时制（01~12）%k 小时，24小时制（0~23）%l 小时，12小时制（1~12）%M 分钟（00~59）%p 显示出AM或PM%r 显示时间，12小时制（hh:mm:ss %p）%s 从1970年1月1日00:00:00到目前经历的秒数%S 显示秒（00~59）%T 显示时间，24小时制（hh:mm:ss）%X 显示时间的格式（%H:%M:%S）%Z 显示时区，日期域（CST）%a 星期的简称（Sun~Sat）%A 星期的全称（Sunday~Saturday）%h,%b 月的简称（Jan~Dec）%B 月的全称（January~December）%c 日期和时间（Tue Nov 20 14:12:58 2012）%d 一个月的第几天（01~31）%x,%D 日期（mm/dd/yy）%j 一年的第几天（001~366）%m 月份（01~12）%w 一个星期的第几天（0代表星期天）%W 一年的第几个星期（00~53，星期一为第一天）%y 年的最后两个数字（1999则是99） 实例 格式化输出 12date +"%Y-%m-%d"# 2018-12-01 输出昨天日期 1234date -d "1 day ago" +"%Y/%m/%d %H:%M.%S"# 2018/11/30 22:36.22date -d "-1 day" +"%Y/%m/%d %H:%M.%S"# 2018/11/30 22:36.22 普通转格式 12date -d "2018-12-1" +"%Y/%m/%d %H:%M.%S"# 2018/12/01 00:00.00 加减操作 1234567date +%Y%m%d //显示前天年月日date -d "+1 day" +%Y%m%d //显示前一天的日期date -d "-1 day" +%Y%m%d //显示后一天的日期date -d "-1 month" +%Y%m%d //显示上一月的日期date -d "+1 month" +%Y%m%d //显示下一月的日期date -d "-1 year" +%Y%m%d //显示前一年的日期date -d "+1 year" +%Y%m%d //显示下一年的日期 设定时间 1234567date -s //设置当前时间，只有root权限才能设置，其他只能查看date -s 20120523 //设置成20120523，这样会把具体时间设置成空00:00:00date -s 01:01:01 //设置具体时间，不会对日期做更改date -s "01:01:01 2012-05-23" //这样可以设置全部时间date -s "01:01:01 20120523" //这样可以设置全部时间date -s "2012-05-23 01:01:01" //这样可以设置全部时间date -s "20120523 01:01:01" //这样可以设置全部时间 有时需要检查一组命令花费的时间 12345678#!/bin/bashstart=$(date +%s)nmap man.linuxde.net &amp;&gt; /dev/nullend=$(date +%s)difference=$(( end - start ))echo $difference seconds.]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux命令</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Shell脚本简介]]></title>
    <url>%2Fhexo-blog-deploy%2F2018%2F12%2F01%2F2018-12-linux-shell-intro%2F</url>
    <content type="text"><![CDATA[什么是shell在计算机系统中,能够控制计算机硬件（CPU、内存、显示器等）的只有操作系统内核（Kernel），无论是图形界面还是命令行都只是架设在用户和内核之间的一座桥梁。 由于安全、复杂、繁琐等原因，用户不能直接接触内核（也没有必要），需要另外再开发一个程序，让用户直接使用这个程序；该程序的作用就是接收用户的操作（点击图标、输入命令），并进行简单的处理，然后再传递给内核。如此一来，用户和内核之间就多了一层“代理”，这层“代理”既简化了用户的操作，也保护了内核。用户界面和命令行就是这个另外开发的程序，就是这层“代理”。在Linux下，这个命令行程序叫做 Shell。 shell的作用 调用其他程序，给其他程序传递数据或参数，并获取程序的处理结果； 在多个程序之间传递数据，把一个程序的输出作为另一个程序的输入； Shell 本身也可以被其他程序调用。 总的来说: Shell 是将内核、程序和用户连接了起来。 shell脚本的解释器Linux 的 Shell 种类众多，常见的有： Bourne Shell（/usr/bin/sh或/bin/sh） Bourne Again Shell（/bin/bash） C Shell（/usr/bin/csh） K Shell（/usr/bin/ksh） Shell for Root（/sbin/sh） NotesBash 是大多数Linux 系统默认的 Shell。 在一般情况下，人们并不区分 Bourne Shell 和 Bourne Again Shell，所以，像 #!/bin/sh，它同样也可以改为 #!/bin/bash#! 告诉系统其后路径所指定的程序即是解释此脚本文件的 Shell 程序 运行shell脚本的方法作为可执行程序 使脚本具有执行权限 执行脚本 12chmod +x ./test.sh #使脚本具有执行权限./test.sh #执行脚本 Notes一定要写成 ./test.sh，而不是 test.sh，运行其它二进制的程序也一样，直接写 test.sh，linux 系统会去 PATH 里寻找有没有叫 test.sh 的，而只有 /bin, /sbin, /usr/bin，/usr/sbin 等在 PATH 里，你的当前目录通常不在 PATH 里，所以写成 test.sh 是会找不到命令的，要用 ./test.sh 告诉系统说，就在当前目录找。 作为解释器参数 直接运行解释器，其参数就是 shell 脚本的文件名 12/bin/sh test.sh/bin/php test.php Notes这种方式运行的脚本，不需要在第一行指定解释器信息，写了也没用]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>shell脚本</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[echo命令]]></title>
    <url>%2Fhexo-blog-deploy%2F2018%2F11%2F30%2F2018-12-linux-cmd-echo%2F</url>
    <content type="text"><![CDATA[简介echo命令用于在shell中打印shell变量的值，或者直接输出指定的字符串。linux的echo命令，在shell编程中极为常用, 在终端下打印变量value的时候也是常常用到的，因此有必要了解下echo的用法echo命令的功能是在显示器上显示一段文字，一般起到一个提示的作用。 语法1echo(选项)(参数) 选项1-e：激活转义字符 使用-e选项时，若字符串中出现以下字符，则特别加以处理，而不会将它当成一般文字输出： \a 发出警告声； \b 删除前一个字符； \c 最后不加上换行符号； \f 换行但光标仍旧停留在原来的位置； \n 换行且光标移至行首； \r 光标移至行首，但不换行； \t 插入tab； \v 与\f相同； \ 插入\字符； \nnn 插入nnn（八进制）所代表的ASCII字符； 参数变量：指定要打印的变量。 实例 文字色 12echo -e "\e[1;31mThis is red text\e[0m"This is red text # shell终端会输出红色的字体 \e[1;31m 将颜色设置为红色 \e[0m 将颜色重新置回 背景色 12echo -e "\e[1;42mGreed Background\e[0m"Greed Background # 字体背景为绿色]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux命令</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[linux命令简介]]></title>
    <url>%2Fhexo-blog-deploy%2F2018%2F11%2F29%2F2018-11-linux-cmd-intro%2F</url>
    <content type="text"><![CDATA[Linux命令格式1命令名称 [命令参数] [命令对象] 命令名称、命令参数、命令对象之间请用空格键分隔。 命令名称是对Linux系统进行管理的命令。对于Linux系统来说，无论是中央处理器、内存、磁盘驱动器、键盘、鼠标，还是用户等都是文件，Linux系统管理的命令是它正常运行的核心，与之前的DOS命令类似。linux命令在系统中有两种类型：内置Shell命令和Linux命令。 命令对象一般是指要处理的文件、目录、用户等资源。 命令参数可以用长格式（完整的选项名称），也可以用短格式（单个字母的缩写），两者分别用--与-作为前缀。 长格式: man --help 短格式: man -h 命令分类 文件管理 文档编辑 文件传输 磁盘管理 磁盘维护 网络通讯 系统管理 系统设置 备份压缩 设备管理]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux命令</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[系统的性能，可用性，可伸缩性，可扩展性的概念]]></title>
    <url>%2Fhexo-blog-deploy%2F2018%2F11%2F29%2F2018-11-ase-note%2F</url>
    <content type="text"><![CDATA[性能(Performance)性能是一个网站能够同时处理用户请求的表现能力。 不同的视觉，有不同的表现形式，性能的指标通常包括，响应时间，并发数，吞吐量，以及性能计数器等。 响应时间系统响应时间，是计算机对用户的输入或请求作出反应的时间 。系统响应时间的计算要考虑到用户的数目，用户数目越多，响应时间必须越快，不然就难以保证每一个用户都有可以接受的响应时间。响应时间和时间片的大小有关，一般情况是：时间片越短，响应时间越快。 并发数是指同时访问服务器站点的连接数。 吞吐量指的就是单位时间内，系统处理的请求数量。 TPS（每秒的事务数），HPS（每秒的HTTP请求数），QPS（每秒的查询数）等等。性能一般通过缓存来解决。 性能计数器性能计数器，它描述的是服务器或者操作系统的一组指标，包括，对象与线程数，内存使用，CPU使用，磁盘和网络的I/O等等。 提高性能的手段提高网站的性能，很多的手段，比如，浏览器访问优化，CDN加速，反向代理，分布式缓存，使用集群，代码和数据结构的优化，存储性能的优化等 可用性(Availability)可用性是在某个考察时间，系统能够正常运行的概率或时间占有率期望值。是衡量设备在投入使用后实际使用的效能，是设备或系统的可靠性、可维护性和维护支持性的综合特性。在大型网站应用系统中，衡量的指标一般是服务的可用性用几个9来表示。 瞬时可用性考察时间为指定瞬间。 时段可用性考察时间为指定时段。 固有可用性考察时间为连续使用期间的任一时刻。 实现手段高可用性一般通过负载均衡，数据备份，失效转移，提高软件质量，特别是发布时的质量来实现和保证的。 可伸缩性（Scalability）是一种对软件系统计算处理能力的设计指标，高可伸缩性代表一种弹性，在系统扩展成长过程中，软件能够保证旺盛的生命力，通过很少的改动甚至只是硬件设备的添置，就能实现整个系统处理能力的线性增长，实现高吞吐量和低延迟高性能。 纵向的可伸缩性在同一个逻辑单元内增加资源来提高处理能力。这样的例子包括在现有服务器上增加CPU，或者在现有的RAID/SAN存储中增加硬盘来提高存储量。 横向的可伸缩性增加更多逻辑单元的资源，并令它们像是一个单元一样工作。大多数集群方案、分布式文件系统、负载平衡都是在帮助你提高横向的可伸缩性。 实现手段可伸缩性一般通过DNS域名解析负载均衡，反向代理负载均衡，IP负载均衡，数据链路层负载均衡，改进和提高分布式缓存的算法，利用NOSQL数据库的可伸缩性等等 可扩展性（Extensibility）可扩展性，通常和可伸缩性混为一谈.在软件范畴上，是软件系统本身的属性，或者进一步说是设计的属性，代码的属性。因为我们经常说设计的可扩展性，代码的可扩展性.也可以说是系统设计的松耦合性。 实现手段实现方式：一般通过事件驱动架构和分布式架构来实现一个网站系统的可扩展性。 参考资料 并发连接数、请求数、并发用户数]]></content>
      <categories>
        <category>架构设计</category>
      </categories>
      <tags>
        <tag>架构设计</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CAP原则]]></title>
    <url>%2Fhexo-blog-deploy%2F2018%2F11%2F29%2F2018-11-cap-principle%2F</url>
    <content type="text"><![CDATA[简介CAP原则又称CAP定理，指的是在一个分布式系统中， Consistency（一致性）、 Availability（可用性）、Partition tolerance（分区容错性），三者不可得兼。CAP理论告诉我们，一个分布式系统不可能满足一致性，可用性和分区容错性这三个需求，最多只能同时满足两个。 由于当前的网络硬件肯定会出现延迟丢包等问题，所以分区容忍性是我们必须需要实现的。所以我们只能在一致性和可用性之间进行权衡，没有NoSQL系统能同时保证这三点。 在操作上，CAP的本质是，在发生了分区(网络故障)以后，有一段timeout时间，在这个时间内程序必须做出基本的决定： 取消操作，从而降低可用性 继续进行操作，从而导致风险不一致。 一致性(C)在分布式系统中的所有数据备份，在同一时刻是否同样的值。（等同于所有节点访问同一份最新的数据副本） 可用性(A)在集群中一部分节点故障后，集群整体是否还能响应客户端的读写请求。（对数据更新具备高可用性） 分区容错(P)以实际效果而言，分区相当于对通信的时限要求。系统如果不能在时限内达成数据一致性，就意味着发生了分区的情况，必须就当前操作在C和A之间做出选择。 参考资料 CAP定理在分布式系统设计中的最新应用 关于CAP定理所有你不知道的 如何在系统设计中使用CAP定理？]]></content>
      <categories>
        <category>分布式理论</category>
      </categories>
      <tags>
        <tag>CAP原则</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[设计模式之解释器模式]]></title>
    <url>%2Fhexo-blog-deploy%2F2018%2F11%2F28%2F2018-11-design-pattern-interpreter-pattern-note%2F</url>
    <content type="text"><![CDATA[简介解释器模式（Interpreter Pattern）提供了评估语言的语法或表达式的方式，它属于行为型模式。这种模式实现了一个表达式接口，该接口解释一个特定的上下文。这种模式被用在 SQL 解析、符号处理引擎等。 动机在软件构建过程中，如果某一特定领域的问题比较复杂，类似的模式不断重复出现，如果使用普通的编程方式来实现将面临非常频繁的变化。在这种情况下，将特定领域的问题表达为某种语法规则下的句子，然后构建一个解释器来解释这样的句子，从而达到解决问题的目的。 意图给定一个语言，定义它的文法的一种表示，并定义一种解释器，这个解释器使用该表示来解释语言中的句子。 结构图 模式组成抽象表达式(AbstractExpression)定义解释器的接口，约定解释器的解释操作。其中的Interpret接口，正如其名字那样，它是专门用来解释该解释器所要实现的功能。 终结符表达式(Terminal Expression)实现了抽象表达式角色所要求的接口，主要是一个Interpret()方法；文法中的每一个终结符都有一个具体终结表达式与之相对应。比如有一个简单的公式R=R1+R2，在里面R1和R2就是终结符，对应的解析R1和R2的解释器就是终结符表达式。 非终结符表达式(Nonterminal Expression)文法中的每一条规则都需要一个具体的非终结符表达式，非终结符表达式一般是文法中的运算符或者其他关键字，比如公式R=R1+R2中，+就是非终结符，解析+的解释器就是一个非终结符表达式。 环境角色(Context)这个角色的任务一般是用来存放文法中各个终结符所对应的具体值，比如R=R1+R2，我们给R1赋值100，给R2赋值200。这些信息需要存放到环境角色中，很多情况下我们使用Map来充当环境角色就足够了。 客户端（Client）指的是使用解释器的客户端，通常在这里将按照语言的语法做的表达式转换成使用解释器对象描述的抽象语法树，然后调用解释操作。 代码实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254namespace InterpreterPattern&#123; // 抽象表达式 public abstract class Expression &#123; protected Dictionary&lt;string, int&gt; table = new Dictionary&lt;string, int&gt;(9); protected Expression() &#123; table.Add("一", 1); table.Add("二", 2); table.Add("三", 3); table.Add("四", 4); table.Add("五", 5); table.Add("六", 6); table.Add("七", 7); table.Add("八", 8); table.Add("九", 9); &#125; public virtual void Interpreter(Context context) &#123; if (context.Statement.Length == 0) &#123; return; &#125; foreach (string key in table.Keys) &#123; int value = table[key]; if (context.Statement.EndsWith(key + GetPostFix())) &#123; context.Data += value * this.Multiplier(); context.Statement = context.Statement.Substring(0, context.Statement.Length - this.GetLength()); &#125; if (context.Statement.EndsWith("零")) &#123; context.Statement = context.Statement.Substring(0, context.Statement.Length - 1); &#125; &#125; &#125; public abstract string GetPostFix(); public abstract int Multiplier(); //这个可以通用，但是对于个位数字例外，所以用虚方法 public virtual int GetLength() &#123; return this.GetPostFix().Length + 1; &#125; &#125; //个位表达式 public sealed class GeExpression : Expression &#123; public override string GetPostFix() &#123; return ""; &#125; public override int Multiplier() &#123; return 1; &#125; public override int GetLength() &#123; return 1; &#125; &#125; //十位表达式 public sealed class ShiExpression : Expression &#123; public override string GetPostFix() &#123; return "十"; &#125; public override int Multiplier() &#123; return 10; &#125; &#125; //百位表达式 public sealed class BaiExpression : Expression &#123; public override string GetPostFix() &#123; return "百"; &#125; public override int Multiplier() &#123; return 100; &#125; &#125; //千位表达式 public sealed class QianExpression : Expression &#123; public override string GetPostFix() &#123; return "千"; &#125; public override int Multiplier() &#123; return 1000; &#125; &#125; //万位表达式 public sealed class WanExpression : Expression &#123; public override string GetPostFix() &#123; return "万"; &#125; public override int Multiplier() &#123; return 10000; &#125; public override void Interpreter(Context context) &#123; if (context.Statement.Length == 0) &#123; return; &#125; ArrayList tree = new ArrayList(); tree.Add(new GeExpression()); tree.Add(new ShiExpression()); tree.Add(new BaiExpression()); tree.Add(new QianExpression()); foreach (string key in table.Keys) &#123; if (context.Statement.EndsWith(GetPostFix())) &#123; int temp = context.Data; context.Data = 0; context.Statement = context.Statement.Substring(0, context.Statement.Length - this.GetLength()); foreach (Expression exp in tree) &#123; exp.Interpreter(context); &#125; context.Data = temp + context.Data * this.Multiplier(); &#125; &#125; &#125; &#125; //亿位表达式 public sealed class YiExpression : Expression &#123; public override string GetPostFix() &#123; return "亿"; &#125; public override int Multiplier() &#123; return 100000000; &#125; public override void Interpreter(Context context) &#123; ArrayList tree = new ArrayList(); tree.Add(new GeExpression()); tree.Add(new ShiExpression()); tree.Add(new BaiExpression()); tree.Add(new QianExpression()); foreach (string key in table.Keys) &#123; if (context.Statement.EndsWith(GetPostFix())) &#123; int temp = context.Data; context.Data = 0; context.Statement = context.Statement.Substring(0, context.Statement.Length - this.GetLength()); foreach (Expression exp in tree) &#123; exp.Interpreter(context); &#125; context.Data = temp + context.Data * this.Multiplier(); &#125; &#125; &#125; &#125; //环境上下文 public sealed class Context &#123; private string _statement; private int _data; public Context(string statement) &#123; this._statement = statement; &#125; public string Statement &#123; get &#123; return this._statement; &#125; set &#123; this._statement = value; &#125; &#125; public int Data &#123; get &#123; return this._data; &#125; set &#123; this._data = value; &#125; &#125; &#125; class Program &#123; static void Main(string[] args) &#123; string roman = "五亿七千三百零二万六千四百五十二"; //分解：((五)亿)((七千)(三百)(零)(二)万) //((六千)(四百)(五十)(二)) Context context = new Context(roman); ArrayList tree = new ArrayList(); tree.Add(new GeExpression()); tree.Add(new ShiExpression()); tree.Add(new BaiExpression()); tree.Add(new QianExpression()); tree.Add(new WanExpression()); tree.Add(new YiExpression()); foreach (Expression exp in tree) &#123; exp.Interpreter(context); &#125; Console.Write(context.Data); Console.Read(); &#125; &#125;&#125; 实现要点使用Interpreter模式来表示文法规则，从而可以使用面向对象技巧方便地“扩展”文法。 Interpreter模式比较适合简单的文法表示，对于复杂的文法表示，Interpreter模式会产生比较大的类层次结构，需要求助于语法分析生成器这样的标准工具。 优缺点优点 易于改变和扩展文法。 每一条文法规则都可以表示为一个类，因此可以方便地实现一个简单的语言。 实现文法较为容易。在抽象语法树中每一个表达式节点类的实现方式都是相似的，这些类的代码编写都不会特别复杂，还可以通过一些工具自动生成节点类代码。 增加新的解释表达式较为方便。如果用户需要增加新的解释表达式只需要对应增加一个新的终结符表达式或非终结符表达式类，原有表达式类代码无须修改，符合“开闭原则” 缺点 对于复杂文法难以维护。在解释器模式中，每一条规则至少需要定义一个类，因此如果一个语言包含太多文法规则，类的个数将会急剧增加，导致系统难以管理和维护，此时可以考虑使用语法分析程序等方式来取代解释器模式。 执行效率较低。由于在解释器模式中使用了大量的循环和递归调用，因此在解释较为复杂的句子时其速度很慢，而且代码的调试过程也比较麻烦。 使用场景Interpreter模式的应用场合是Interpreter模式应用中的难点，只有满足业务规则频繁变化，且类似的模式不断重复出现，并且容易抽象为语法规则的问题才适合使用Interpreter模式。 当一个语言需要解释执行，并可以将该语言中的句子表示为一个抽象语法树的时候，可以考虑使用解释器模式（如XML文档解释、正则表达式等领域） 一些重复出现的问题可以用一种简单的语言来进行表达。 一个语言的文法较为简单. 当执行效率不是关键和主要关心的问题时可考虑解释器模式（注：高效的解释器通常不是通过直接解释抽象语法树来实现的，而是需要将它们转换成其他形式，使用解释器模式的执行效率并不高。）]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
        <tag>行为型</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[设计模式之备忘录模式]]></title>
    <url>%2Fhexo-blog-deploy%2F2018%2F11%2F27%2F2018-11-design-pattern-memento-pattern-note%2F</url>
    <content type="text"><![CDATA[简介备忘录模式（Memento Pattern）保存一个对象的某个状态，以便在适当的时候恢复对象。备忘录模式属于行为型模式。 一个对象肯定会有很多状态，这些状态肯定会相互转变而促进对象的发展，如果要想在某一时刻把当前对象回复到以前某一时刻的状态，这个情况用“备忘录模式”就能很好解决该问题。 动机在软件构建过程中，某些对象的状态在转换的过程中，可能由于某种需要，要求程序能够回溯到对象之前处于某个点时的状态。如果使用一些公有接口来让其他对象得到对象的状态，便会暴露对象的细节实现。如何实现对象状态的良好保存与恢复，但同时又不会因此而破坏对象本身的封装性？ 意图在不破坏封装性的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态（如果没有这个关键点，其实深拷贝就可以解决问题）。这样以后就可以将该对象恢复到原先保存的状态。 结构图 模式组成发起人角色（Originator）记录当前时刻的内部状态，负责创建和恢复备忘录数据。负责创建一个备忘录Memento，用以记录当前时刻自身的内部状态，并可使用备忘录恢复内部状态。Originator【发起人】可以根据需要决定Memento【备忘录】存储自己的哪些内部状态。 备忘录角色（Memento）负责存储发起人对象的内部状态，在进行恢复时提供给发起人需要的状态，并可以防止Originator以外的其他对象访问备忘录。备忘录有两个接口：Caretaker【管理角色】只能看到备忘录的窄接口，他只能将备忘录传递给其他对象。Originator【发起人】却可看到备忘录的宽接口，允许它访问返回到先前状态所需要的所有数据。 ##管理者角色（Caretaker）负责保存备忘录对象。负责备忘录Memento，不能对Memento的内容进行访问或者操作。 代码实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119namespace MementoPattern&#123; // 联系人--需要备份的数据，是状态数据，没有操作 public sealed class ContactPerson &#123; //姓名 public string Name &#123; get; set; &#125; //电话号码 public string MobileNumber &#123; get; set; &#125; &#125; // 发起人--相当于【发起人角色】Originator public sealed class MobileBackOriginator &#123; // 发起人需要保存的内部状态 private List&lt;ContactPerson&gt; _personList; public List&lt;ContactPerson&gt; ContactPersonList &#123; get &#123; return this._personList; &#125; set &#123; this._personList = value; &#125; &#125; //初始化需要备份的电话名单 public MobileBackOriginator(List&lt;ContactPerson&gt; personList) &#123; if (personList != null) &#123; this._personList = personList; &#125; else &#123; throw new ArgumentNullException("参数不能为空！"); &#125; &#125; // 创建备忘录对象实例，将当期要保存的联系人列表保存到备忘录对象中 public ContactPersonMemento CreateMemento() &#123; return new ContactPersonMemento(new List&lt;ContactPerson&gt;(this._personList)); &#125; // 将备忘录中的数据备份还原到联系人列表中 public void RestoreMemento(ContactPersonMemento memento) &#123; this.ContactPersonList = memento.ContactPersonListBack; &#125; public void Show() &#123; Console.WriteLine("联系人列表中共有&#123;0&#125;个人，他们是:", ContactPersonList.Count); foreach (ContactPerson p in ContactPersonList) &#123; Console.WriteLine("姓名: &#123;0&#125; 号码: &#123;1&#125;", p.Name, p.MobileNumber); &#125; &#125; &#125; // 备忘录对象，用于保存状态数据，保存的是当时对象具体状态数据--相当于【备忘录角色】Memeto public sealed class ContactPersonMemento &#123; // 保存发起人创建的电话名单数据，就是所谓的状态 public List&lt;ContactPerson&gt; ContactPersonListBack &#123; get; private set; &#125; public ContactPersonMemento(List&lt;ContactPerson&gt; personList) &#123; ContactPersonListBack = personList; &#125; &#125; // 管理角色，它可以管理【备忘录】对象，如果是保存多个【备忘录】对象，当然可以对保存的对象进行增、删等管理处理---相当于【管理者角色】Caretaker public sealed class MementoManager &#123; //如果想保存多个【备忘录】对象，可以通过字典或者堆栈来保存，堆栈对象可以反映保存对象的先后顺序 //比如：public Dictionary&lt;string, ContactPersonMemento&gt; ContactPersonMementoDictionary &#123; get; set; &#125; public ContactPersonMemento ContactPersonMemento &#123; get; set; &#125; &#125; class Program &#123; static void Main(string[] args) &#123; List&lt;ContactPerson&gt; persons = new List&lt;ContactPerson&gt;() &#123; new ContactPerson() &#123; Name="黄飞鸿", MobileNumber = "13533332222"&#125;, new ContactPerson() &#123; Name="方世玉", MobileNumber = "13966554433"&#125;, new ContactPerson() &#123; Name="洪熙官", MobileNumber = "13198765544"&#125; &#125;; //手机名单发起人 MobileBackOriginator mobileOriginator = new MobileBackOriginator(persons); mobileOriginator.Show(); // 创建备忘录并保存备忘录对象 MementoManager manager = new MementoManager(); manager.ContactPersonMemento = mobileOriginator.CreateMemento(); // 更改发起人联系人列表 Console.WriteLine("----移除最后一个联系人--------"); mobileOriginator.ContactPersonList.RemoveAt(2); mobileOriginator.Show(); // 恢复到原始状态 Console.WriteLine("-------恢复联系人列表------"); mobileOriginator.RestoreMemento(manager.ContactPersonMemento); mobileOriginator.Show(); Console.Read(); &#125; &#125;&#125; 实现要点备忘录（Memento）存储原发器（Originator）对象的内部状态，在需要时恢复原发器状态。Memento模式适用于由原发器管理，却又必须存储在原发器之外的信息。 在实现Memento模式中，要防止原发器以外的对象访问备忘录对象。备忘录对象有两个接口，一个为原发器使用的宽接口；一个为其他对象使用的窄接口。在实现Memento模式时，要考虑拷贝对象状态的效率问题，如果对象开销比较大，可以采用某种增量式改变（即只记住改变的状态）来改进Memento模式。 我们也可以用序列化的方式实现备忘录。序列化之后，我们可以把它临时性保存到数据库、文件、进程内、进程外等地方。 优缺点优点 如果某个操作错误地破坏了数据的完整性，此时可以使用备忘录模式将数据恢复成原来正确的数据。 备份的状态数据保存在发起人角色之外，这样发起人就不需要对各个备份的状态进行管理。而是由备忘录角色进行管理，而备忘录角色又是由管理者角色管理，符合单一职责原则。 提供了一种状态恢复的实现机制，使得用户可以方便地回到一个特定的历史步骤，当新的状态无效或者存在问题时，可以使用先前存储起来的备忘录将状态复原。 实现了信息的封装，一个备忘录对象是一种原发器对象的表示，不会被其他代码改动，这种模式简化了原发器对象，备忘录只保存原发器的状态，采用堆栈来存储备忘录对象可以实现多次撤销操作，可以通过在负责人中定义集合对象来存储多个备忘录。 本模式简化了发起人。发起人不再需要管理和保存其内部状态的一个个版本，客户端可以自行管理他们所需要的这些状态的版本。 当发起人角色的状态改变的时候，有可能这个状态无效，这时候就可以使用暂时存储起来的备忘录将状态复原。 缺点 在实际的系统中，可能需要维护多个备份，需要额外的资源，这样对资源的消耗比较严重。资源消耗过大，如果类的成员变量太多，就不可避免占用大量的内存，而且每保存一次对象的状态都需要消耗内存资源，如果知道这一点大家就容易理解为什么一些提供了撤销功能的软件在运行时所需的内存和硬盘空间比较大了。 如果发起人角色的状态需要完整地存储到备忘录对象中，那么在资源消耗上面备忘录对象会很昂贵。 当负责人角色将一个备忘录 存储起来的时候，负责人可能并不知道这个状态会占用多大的存储空间，从而无法提醒用户一个操作是否很昂贵。 当发起人角色的状态改变的时候，有可能这个协议无效。如果状态改变的成功率不高的话，不如采取“假如”协议模式。 使用场景 如果系统需要提供回滚操作时，使用备忘录模式非常合适。例如文本编辑器的Ctrl+Z撤销操作的实现，数据库中事务操作。 保存一个对象在某一个时刻的状态或部分状态，这样以后需要时它能够恢复到先前的状态。 如果用一个接口来让其他对象得到这些状态，将会暴露对象的实现细节并破坏对象的封装性，一个对象不希望外界直接访问其内部状态，通过负责人可以间接访问其内部状态。 有时一些发起人对象的内部信息必须保存在发起人对象以外的地方，但是必须要由发起人对象自己读取，这时，使用备忘录模式可以把复杂的发起人内部信息对其他的对象屏蔽起来，从而可以恰当地保持封装的边界。 封装性为了确保备忘录的封装性，除了原发器外，其他类是不能也不应该访问备忘录类的，在实际开发中，原发器与备忘录之间的关系是非常特殊的，它们要分享信息而不让其他类知道，实现的方法因编程语言的不同而不同。 多备份实现 在负责人中定义一个集合对象来存储多个状态，而且可以方便地返回到某一历史状态。 在备份对象时可以做一些记号，这些记号称为检查点(Check Point)。在使用HashMap等实现时可以使用Key来设置检查点。]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
        <tag>行为型</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[设计模式之访问者模式]]></title>
    <url>%2Fhexo-blog-deploy%2F2018%2F11%2F27%2F2018-11-design-pattern-visitor-pattern-note%2F</url>
    <content type="text"><![CDATA[简介在访问者模式（Visitor Pattern）中，我们使用了一个访问者类，它改变了元素类的执行算法。通过这种方式，元素的执行算法可以随着访问者改变而改变。这种类型的设计模式属于行为型模式。根据模式，元素对象已接受访问者对象，这样访问者对象就可以处理元素对象上的操作。 动机 在软件构建过程中，由于需求的改变，某些类层次结构中常常需要增加新的行为（方法），如果直接在基类中做这样的更改，将会给子类带来很繁重的变更负担，甚至破坏原有设计。如何在不更改类层次结构的前提下，在运行时根据需要透明地为类层次结构上的各个类动态添加新的操作，从而避免上述问题？ 意图表示一个作用于某对象结构中的各个元素的操作。它可以在不改变各元素的类的前提下定义作用于这些元素的新的操作。 结构图 模式组成抽象访问者角色（Vistor）声明一个包括多个访问操作，多个操作针对多个具体节点角色（可以说有多少个具体节点角色就有多少访问操作），使得所有具体访问者必须实现的接口。 具体访问者角色（ConcreteVistor）实现抽象访问者角色中所有声明的接口，也可以说是实现对每个具体节点角色的新的操作。 抽象节点角色（Element）声明一个接受操作，接受一个访问者对象作为参数，如果有其他参数，可以在这个“接受操作”里在定义相关的参数。 具体节点角色（ConcreteElement）实现抽象元素所规定的接受操作。 结构对象角色（ObjectStructure）节点的容器，可以包含多个不同类或接口的容器。 代码实现 这是访问者模式第一种代码实例 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128namespace Vistor&#123; //抽象图形定义---相当于“抽象节点角色”Element public abstract class Shape &#123; //画图形 public abstract void Draw(); //外界注入具体访问者 public abstract void Accept(ShapeVisitor visitor); &#125; //抽象访问者 Visitor public abstract class ShapeVisitor &#123; public abstract void Visit(Rectangle shape); public abstract void Visit(Circle shape); public abstract void Visit(Line shape); //这里有一点要说：Visit方法的参数可以写成Shape吗？就是这样 Visit(Shape shape)，当然可以，但是ShapeVisitor子类Visit方法就需要判断当前的Shape是什么类型，是Rectangle类型，是Circle类型，或者是Line类型。 &#125; //具体访问者 ConcreteVisitor public sealed class CustomVisitor : ShapeVisitor &#123; //针对Rectangle对象 public override void Visit(Rectangle shape) &#123; Console.WriteLine("针对Rectangle新的操作！"); &#125; //针对Circle对象 public override void Visit(Circle shape) &#123; Console.WriteLine("针对Circle新的操作！"); &#125; //针对Line对象 public override void Visit(Line shape) &#123; Console.WriteLine("针对Line新的操作！"); &#125; &#125; //矩形----相当于“具体节点角色” ConcreteElement public sealed class Rectangle : Shape &#123; public override void Draw() &#123; Console.WriteLine("矩形我已经画好！"); &#125; public override void Accept(ShapeVisitor visitor) &#123; visitor.Visit(this); &#125; &#125; //圆形---相当于“具体节点角色”ConcreteElement public sealed class Circle : Shape &#123; public override void Draw() &#123; Console.WriteLine("圆形我已经画好！"); &#125; public override void Accept(ShapeVisitor visitor) &#123; visitor.Visit(this); &#125; &#125; //直线---相当于“具体节点角色” ConcreteElement public sealed class Line : Shape &#123; public override void Draw() &#123; Console.WriteLine("直线我已经画好！"); &#125; public override void Accept(ShapeVisitor visitor) &#123; visitor.Visit(this); &#125; &#125; //结构对象角色 internal class AppStructure &#123; private ShapeVisitor _visitor; public AppStructure(ShapeVisitor visitor) &#123; this._visitor = visitor; &#125; public void Process(Shape shape) &#123; shape.Accept(_visitor); &#125; &#125; class Program &#123; static void Main(string[] args) &#123; //如果想执行新增加的操作 ShapeVisitor visitor = new CustomVisitor(); AppStructure app = new AppStructure(visitor); Shape shape = new Rectangle(); shape.Draw();//执行自己的操作 app.Process(shape);//执行新的操作 shape = new Circle(); shape.Draw();//执行自己的操作 app.Process(shape);//执行新的操作 shape = new Line(); shape.Draw();//执行自己的操作 app.Process(shape);//执行新的操作 Console.ReadLine(); &#125; &#125;&#125; 这是访问者模式第二种代码实例 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118namespace Visitor&#123; //抽象访问者角色 Visitor public abstract class Visitor &#123; public abstract void PutTelevision(Television tv); public abstract void PutComputer(Computer comp); &#125; //具体访问者角色 ConcreteVisitor public sealed class SizeVisitor : Visitor &#123; public override void PutTelevision(Television tv) &#123; Console.WriteLine("按商品大小&#123;0&#125;排放", tv.Size); &#125; public override void PutComputer(Computer comp) &#123; Console.WriteLine("按商品大小&#123;0&#125;排放", comp.Size); &#125; &#125; //具体访问者角色 ConcreteVisitor public sealed class StateVisitor : Visitor &#123; public override void PutTelevision(Television tv) &#123; Console.WriteLine("按商品新旧值&#123;0&#125;排放", tv.State); &#125; public override void PutComputer(Computer comp) &#123; Console.WriteLine("按商品新旧值&#123;0&#125;排放", comp.State); &#125; &#125; //抽象节点角色 Element public abstract class Goods &#123; public abstract void Operate(Visitor visitor); private int nSize; public int Size &#123; get &#123; return nSize; &#125; set &#123; nSize = value; &#125; &#125; private int nState; public int State &#123; get &#123; return nState; &#125; set &#123; nState = value; &#125; &#125; &#125; //具体节点角色 ConcreteElement public sealed class Television : Goods &#123; public override void Operate(Visitor visitor) &#123; visitor.PutTelevision(this); &#125; &#125; //具体节点角色 ConcreteElement public sealed class Computer : Goods &#123; public override void Operate(Visitor visitor) &#123; visitor.PutComputer(this); &#125; &#125; //结构对象角色 public sealed class StoragePlatform &#123; private IList&lt;Goods&gt; list = new List&lt;Goods&gt;(); public void Attach(Goods element) &#123; list.Add(element); &#125; public void Detach(Goods element) &#123; list.Remove(element); &#125; public void Operate(Visitor visitor) &#123; foreach (Goods g in list) &#123; g.Operate(visitor); &#125; &#125; &#125; class Program &#123; static void Main(string[] args) &#123; StoragePlatform platform = new StoragePlatform(); platform.Attach(new Television()); platform.Attach(new Computer()); SizeVisitor sizeVisitor = new SizeVisitor(); StateVisitor stateVisitor = new StateVisitor(); platform.Operate(sizeVisitor); platform.Operate(stateVisitor); Console.Read(); &#125; &#125;&#125; 实现要点Visitor模式通过所谓双重分发（double dispatch）来实现在不更改Element类层次结构的前提下，在运行时透明地为类层次结构上的各个类动态添加新的操作。所谓双重分发即Visitor模式中间包括了两个多态分发（注意其中的多态机制）：第一个为accept方法的多态辨析；第二个为visit方法的多态辨析。 设计模式其实是一种堵漏洞的方式，但是没有一种设计模式能够堵完所有的漏洞，即使是组合各种设计模式也是一样。每个设计模式都有漏洞，都有它们解决不了的情况或者变化。每一种设计模式都假定了某种变化，也假定了某种不变化。Visitor模式假定的就是操作变化，而Element类层次结构稳定。 优缺点优点 访问者模式使得添加新的操作变得容易。如果一些操作依赖于一个复杂的结构对象的话，那么一般而言，添加新的操作会变得很复杂。而使用访问者模式，增加新的操作就意味着添加一个新的访问者类。因此，使得添加新的操作变得容易。 访问者模式使得有关的行为操作集中到一个访问者对象中，而不是分散到一个个的元素类中。这点类似与”中介者模式”。 访问者模式可以访问属于不同的等级结构的成员对象，而迭代只能访问属于同一个等级结构的成员对象。 缺点 增加新的元素类变得困难。每增加一个新的元素意味着要在抽象访问者角色中增加一个新的抽象操作，并在每一个具体访问者类中添加相应的具体操作。具体来说，Visitor模式的最大缺点在于扩展类层次结构（增添新的Element子类），会导致Visitor类的改变。因此Visitor模式适用于Element类层次结构稳定，而其中的操作却经常面临频繁改动。 使用场景 如果系统有比较稳定的数据结构，而又有易于变化的算法时，此时可以考虑使用访问者模式。因为访问者模式使得算法操作的添加比较容易。 如果一组类中，存在着相似的操作，为了避免出现大量重复的代码，可以考虑把重复的操作封装到访问者中。（当然也可以考虑使用抽象类了） 如果一个对象存在着一些与本身对象不相干，或关系比较弱的操作时，为了避免操作污染这个对象，则可以考虑把这些操作封装到访问者对象中。]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
        <tag>行为型</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[设计模式之责任链模式]]></title>
    <url>%2Fhexo-blog-deploy%2F2018%2F11%2F25%2F2018-11-design-pattern-chainofresponsibility-pattern-note%2F</url>
    <content type="text"><![CDATA[简介顾名思义，责任链模式（Chain of Responsibility Pattern）为请求创建了一个接收者对象的链。这种模式给予请求的类型，对请求的发送者和接收者进行解耦。这种类型的设计模式属于行为型模式。在这种模式中，通常每个接收者都包含对另一个接收者的引用。如果一个对象不能处理该请求，那么它会把相同的请求传给下一个接收者，依此类推。 动机在软件构建过程中，一个请求可能被多个对象处理，但是每个请求在运行时只能有一个接受者，如果显示指定，将必不可少地带来请求发送者与接受者的紧耦合。如何使请求的发送者不需要指定具体的接受者，让请求的接受者自己在运行时决定来处理请求，从而使两者解耦。 意图避免请求发送者与接收者耦合在一起，让多个对象都有可能接受请求，将这些对象连接成一条链，并且沿着这条链传递请求，知道有对象处理它为止。 结构图 模式的组成抽象处理者角色（Handler）抽象处理者定义了一个处理请求的接口，它一般设计为抽象类，由于不同的具体处理者处理请求的方式不同，因此在其中定义了抽象请求处理方法。因为每一个处理者的下家还是一个处理者，因此在抽象处理者中定义了一个自类型的对象，作为其对下家的引用。通过该引用，处理者可以连成一条链。 具体处理者角色（ConcreteHandler）具体处理者是抽象处理者的子类，它可以处理用户请求，在具体处理者类中实现了抽象处理者中定义的抽象处理方法，在处理请求之前需要进行判断，看是否有相应的处理权限，如果可以处理请求就处理它，否则将请求转发给后继者；在具体处理者中可以访问链中下一个对象，以便请求的转发。 代码实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115namespace ChainOfResponsibility&#123; // 采购请求 public sealed class PurchaseRequest &#123; // 金额 public double Amount &#123; get; set; &#125; // 产品名字 public string ProductName &#123; get; set; &#125; public PurchaseRequest(double amount, string productName) &#123; Amount = amount; ProductName = productName; &#125; &#125; //抽象审批人,Handler---相当于“抽象处理者角色” public abstract class Approver &#123; //下一位审批人，由此形成一条链 public Approver NextApprover &#123; get; set; &#125; //审批人的名称 public string Name &#123; get; set; &#125; public Approver(string name) &#123; this.Name = name; &#125; //处理请求 public abstract void ProcessRequest(PurchaseRequest request); &#125; //部门经理----相当于“具体处理者角色” ConcreteHandler public sealed class Manager : Approver &#123; public Manager(string name): base(name)&#123; &#125; public override void ProcessRequest(PurchaseRequest request) &#123; if (request.Amount &lt;= 10000.0) &#123; Console.WriteLine("&#123;0&#125; 部门经理批准了对原材料&#123;1&#125;的采购计划！", this.Name, request.ProductName); &#125; else if (NextApprover != null) &#123; NextApprover.ProcessRequest(request); &#125; &#125; &#125; //财务经理---相当于“具体处理者角色”ConcreteHandler public sealed class FinancialManager : Approver &#123; public FinancialManager(string name): base(name)&#123; &#125; public override void ProcessRequest(PurchaseRequest request) &#123; if (request.Amount &gt; 10000.0 &amp;&amp; request.Amount &lt;= 50000.0) &#123; Console.WriteLine("&#123;0&#125; 财务经理批准了对原材料&#123;1&#125;的采购计划！", this.Name, request.ProductName); &#125; else if (NextApprover != null) &#123; NextApprover.ProcessRequest(request); &#125; &#125; &#125; //总裁---相当于“具体处理者角色” ConcreteHandler public sealed class CEO :Approver &#123; public CEO(string name): base(name)&#123; &#125; public override void ProcessRequest(PurchaseRequest request) &#123; if (request.Amount &gt; 50000.0 &amp;&amp; request.Amount &lt; 300000.0) &#123; Console.WriteLine("&#123;0&#125; 总裁批准了对原材料 &#123;1&#125; 的采购计划！", this.Name, request.ProductName); &#125; else &#123; Console.WriteLine("这个采购计划的金额比较大，需要一次董事会会议讨论才能决定！"); &#125; &#125; &#125; class Program &#123; static void Main(string[] args) &#123; PurchaseRequest requestDao = new PurchaseRequest(8000.0, "单刀5把"); PurchaseRequest requestHuaJi = new PurchaseRequest(10000.0, "10把方天画戟"); PurchaseRequest requestJian = new PurchaseRequest(80000.0, "5把金丝龙鳞闪电劈"); Approver manager = new Manager("黄飞鸿"); Approver financial = new FinancialManager("黄麒英"); Approver ceo = new CEO("十三姨"); // 设置职责链 manager.NextApprover = financial; financial.NextApprover = ceo; // 处理请求 manager.ProcessRequest(requestDao); manager.ProcessRequest(requestHuaJi); manager.ProcessRequest(requestJian); Console.ReadLine(); &#125; &#125;&#125; 实现要点Chain of Responsibility模式的应用场合在于一个请求可能有多个接受者，但是最后真正的接受者只有一个，只有这时候请求发送者与接受者的耦合才有可能出现变化脆弱的症状，职责链的目的就是将二者解耦，从而更好地应对变化。 应用了Chain of Responsibility模式后，对象的职责分派将更具灵活性。我们可以在运行时动态添加/修改请求的处理职责。 当我们要新增一个DHandler处理请求，就不需再改原来的代码了，遵从了开放封闭原则。这样我们的程序就更赋予变化，更有变化的抵抗力。Handler类本身继承自BaseHandler类型，又包含了一个BaseHandler类型的对象，这点类似Decorator模式。 如果请求传递到职责链的末尾仍得不到处理，应该有一个合理的缺省机制。这也是每一个接受对象的责任，而不是发出请求的对象的责任。 优缺点优点 降低耦合度：职责链模式使得一个对象无需知道是其他哪一个对象处理其请求。对象仅需知道该请求会被处理即可，接受者和发送者都没有对方的明确信息，且链中的对象不需要知道链的结构，有客户端负责链的创建。 可简化对象的相互连接：接受者对象仅需维持一个指向其后继者的引用，而不需维持它对所有的候选处理者的引用。 增强给对象指派职责的灵活性：在给对象分派职责时，职责链可以给我们带来更多的灵活性。可以通过在运行时对该连进行动态的增加或修改处理一个请求的职责。 增加新的请求处理类很方便：在系统中增加一个新的请求处理者无需修改原有系统的代码，只需要在客户端重新建链即可，从这一点看来是符合“开闭原则”的。 缺点 在找到正确的处理对象之前，所有的条件判定都要执行一遍，当责任链过长时，可能会引起性能的问题。 可能导致某个请求不被处理。 客户端需要组装这个链条，耦合了客户端和链条的组成结构，可以把这个在客户端的组合动作提到外面，通过配置来做，会更好点。 使用场景 一个系统的审批需要多个对象才能完成处理的情况下，例如请假系统等。 代码中存在多个if-else语句的情况下，此时可以考虑使用责任链模式来对代码进行重构 有多个对象可以处理同一个请求，具体哪个对象处理该请求有运行时刻自动确定。客户端只需将请求提交到链上，无须关心请求的处理对象是谁以及它是如何处理的。 不明确指定接受者的情况下，向多个对象中的一个提交一个请求。请求的发送者与请求者解耦，请求将沿着链进行传递，寻求响应的处理者。 可动态指定一组对象处理请求。客户端可以动态创建职责链来处理请求，还可以动态改变链中处理者之间的先后次序]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
        <tag>行为型</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[设计模式之策略模式]]></title>
    <url>%2Fhexo-blog-deploy%2F2018%2F11%2F25%2F2018-11-design-pattern-stragety-pattern-note%2F</url>
    <content type="text"><![CDATA[简介在策略模式（Strategy Pattern）中，一个类的行为或其算法可以在运行时更改。这种类型的设计模式属于行为型模式。 在策略模式中，我们创建表示各种策略的对象和一个行为随着策略对象改变而改变的context对象。策略对象改变context 对象的执行算法。 动机在软件构建过程中，某些对象使用的算法可能多种多样，经常改变，如果将这些算法都编码到对象中，将会使对象变得异常复杂；而且有时候支持不使用的算法也是一个性能负担。如何在运行时根据需要透明地更改对象的算法？将算法与对象本身解耦，从而避免上述问题？ 意图定义一系列算法，把它们一个个封装起来，并且使它们可互相替换。该模式使得算法可独立于使用它的客户而变化。 结构图 模式的组成环境角色（Context） 持有一个Strategy类的引用。 需要使用ConcreteStrategy提供的算法。 内部维护一个Strategy的实例。 负责动态设置运行时Strategy具体的实现算法。 负责跟Strategy之间的交互和数据传递 抽象策略角色（Strategy） 定义了一个公共接口，各种不同的算法以不同的方式实现这个接口，Context使用这个接口调用不同的算法，一般使用接口或抽象类实现。 具体策略角色（ConcreteStrategy） 实现了Strategy定义的接口，提供具体的算法实现 代码实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475namespace 策略模式的实现&#123; //环境角色---相当于Context类型 public sealed class SalaryContext &#123; private ISalaryStrategy _strategy; public SalaryContext(ISalaryStrategy strategy) &#123; this._strategy = strategy; &#125; public ISalaryStrategy ISalaryStrategy &#123; get &#123; return _strategy; &#125; set &#123; _strategy = value; &#125; &#125; public void GetSalary(double income) &#123; _strategy.CalculateSalary(income); &#125; &#125; //抽象策略角色---相当于Strategy类型 public interface ISalaryStrategy &#123; //工资计算 void CalculateSalary(double income); &#125; //程序员的工资--相当于具体策略角色ConcreteStrategyA public sealed class ProgrammerSalary : ISalaryStrategy &#123; public void CalculateSalary(double income) &#123; Console.WriteLine("我的工资是：基本工资(" + income + ")底薪(" + 8000 + ")+加班费+项目奖金（10%）"); &#125; &#125; //普通员工的工资---相当于具体策略角色ConcreteStrategyB public sealed class NormalPeopleSalary : ISalaryStrategy &#123; public void CalculateSalary(double income) &#123; Console.WriteLine("我的工资是：基本工资(" + income + ")底薪(3000)+加班费"); &#125; &#125; //CEO的工资---相当于具体策略角色ConcreteStrategyC public sealed class CEOSalary : ISalaryStrategy &#123; public void CalculateSalary(double income) &#123; Console.WriteLine("我的工资是：基本工资(" + income + ")底薪(20000)+项目奖金(20%)+公司股票"); &#125; &#125; public class Client &#123; public static void Main(String[] args) &#123; //普通员工的工资 SalaryContext context = new SalaryContext(new NormalPeopleSalary()); context.GetSalary(3000); //CEO的工资 context.ISalaryStrategy = new CEOSalary(); context.GetSalary(6000); Console.Read(); &#125; &#125;&#125; 实现要点Strategy及其子类为组件提供了一系列可重用的算法，从而可以使得类型在运行时方便地根据需要在各个算法之间进行切换，所谓封装算法，支持算法的变化。Strategy模式提供了用条件判断语句以外的另一种选择，消除条件判断语句，就是在解耦合。含有许多条件判断语句的代码通常都需要Strategy模式。 与State类似，如果Strategy对象没有实例变量，那么各个上下文可以共享一个Strategy对象，从而节省对象开销。Strategy模式适用的是算法结构中整个算法的改变，而不是算法中某个部分的改变。 Template Method方法：执行算法的步骤协议是本身放在抽象类里面的，允许一个通用的算法操作多个可能实现 Strategy模式：执行算法的协议是在具体类，每个具体实现有不同通用算法来做。 优缺点优点 策略类之间可以自由切换。由于策略类都实现同一个接口，所以使它们之间可以自由切换。 易于扩展。增加一个新的策略只需要添加一个具体的策略类即可，基本不需要改变原有的代码。 避免使用多重条件选择语句，充分体现面向对象设计思想。 缺点 客户端必须知道所有的策略类，并自行决定使用哪一个策略类。这点可以考虑使用IOC容器和依赖注入的方式来解决 策略模式会造成很多的策略类。 使用场景 一个系统需要动态地在几种算法中选择一种的情况下。那么这些算法可以包装到一个个具体的算法类里面，并为这些具体的算法类提供一个统一的接口。 如果一个对象有很多的行为，如果不使用合适的模式，这些行为就只好使用多重的if-else语句来实现，此时，可以使用策略模式，把这些行为转移到相应的具体策略类里面，就可以避免使用难以维护的多重条件选择语句，并体现面向对象涉及的概念。]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
        <tag>行为型</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[设计模式之状态模式]]></title>
    <url>%2Fhexo-blog-deploy%2F2018%2F11%2F24%2F2018-11-design-pattern-state-pattern-note%2F</url>
    <content type="text"><![CDATA[简介在状态模式（State Pattern）中，类的行为是基于它的状态改变的。这种类型的设计模式属于行为型模式。在状态模式中，我们创建表示各种状态的对象和一个行为随着状态对象改变而改变的context对象。 动机在软件构建过程中，某些对象的状态如果改变，其行为也会随之而发生变化，比如文档处于只读状态，其支持的行为和读写状态支持的行为就可能完全不同。如何在运行时根据对象的状态来透明地更改对象的行为？而不会为对象操作和状态转化之间引入紧耦合？ 意图允许一个对象在其内部状态改变时改变它的行为。从而使对象看起来似乎修改了其行为 结构图 模式的组成环境角色（Context）也称上下文，定义客户端所感兴趣的接口，并且保留一个具体状态类的实例。这个具体状态类的实例给出此环境对象的现有状态。 抽象状态角色（State）定义一个接口，用以封装环境对象的一个特定的状态所对应的行为。 具体状态角色（ConcreteState）每一个具体状态类都实现了环境（Context）的一个状态所对应的行为 在状态模式结构中需要理解环境类与抽象状态类的作用： 环境类实际上就是拥有状态的对象，环境类有时候可以充当状态管理器(State Manager)的角色，可以在环境类中对状态进行切换操作。 抽象状态类可以是抽象类，也可以是接口，不同状态类就是继承这个父类的不同子类，状态类的产生是由于环境类存在多个状态，同时还满足两个条件：这些状态经常需要切换，在不同的状态下对象的行为不同。因此可以将不同对象下的行为单独提取出来封装在具体的状态类中，使得环境类对象在其内部状态改变时可以改变它的行为，对象看起来似乎修改了它的类，而实际上是由于切换到不同的具体状态类实现的。由于环境类可以设置为任一具体状态类，因此它针对抽象状态类进行编程，在程序运行时可以将任一具体状态类的对象设置到环境类中，从而使得环境类可以改变内部状态，并且改变行为。 代码实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137namespace 状态模式的实现 &#123; //环境角色---相当于Context类型 public sealed class Order &#123; private State current; public Order() &#123; //工作状态初始化为上午工作状态 current = new WaitForAcceptance(); IsCancel = false; &#125; private double minute; public double Minute &#123; get &#123; return minute; &#125; set &#123; minute = value; &#125; &#125; public bool IsCancel &#123; get; set; &#125; private bool finish; public bool TaskFinished &#123; get &#123; return finish; &#125; set &#123; finish = value; &#125; &#125; public void SetState(State s) &#123; current = s; &#125; public void Action() &#123; current.Process(this); &#125; &#125; //抽象状态角色---相当于State类型 public interface State &#123; //处理订单 void Process(Order order); &#125; //等待受理--相当于具体状态角色 public sealed class WaitForAcceptance : State &#123; public void Process(Order order) &#123; System.Console.WriteLine("我们开始受理，准备备货！"); if (order.Minute &lt; 30 &amp;&amp; order.IsCancel) &#123; System.Console.WriteLine("接受半个小时之内，可以取消订单！"); order.SetState(new CancelOrder()); order.Action(); &#125; order.SetState(new AcceptAndDeliver()); order.TaskFinished = false; order.Action(); &#125; &#125; //受理发货---相当于具体状态角色 public sealed class AcceptAndDeliver : State &#123; public void Process(Order order) &#123; System.Console.WriteLine("我们货物已经准备好，可以发货了，不可以撤销订单！"); if (order.Minute &lt; 30 &amp;&amp; order.IsCancel) &#123; System.Console.WriteLine("接受半个小时之内，可以取消订单！"); order.SetState(new CancelOrder()); order.Action(); &#125; if (order.TaskFinished==false) &#123; order.SetState(new ConfirmationReceipt()); order.Action(); &#125; &#125; &#125; //确认收货---相当于具体状态角色 public sealed class ConfirmationReceipt : State &#123; public void Process(Order order) &#123; System.Console.WriteLine("检查货物，没问题可以就可以签收！"); order.SetState(new Success()); order.TaskFinished = false; order.Action(); &#125; &#125; //交易成功---相当于具体状态角色 public sealed class Success : State &#123; public void Process(Order order) &#123; System.Console.WriteLine("订单结算"); order.TaskFinished = true; &#125; &#125; //取消订单---相当于具体状态角色 public sealed class CancelOrder : State &#123; public void Process(Order order) &#123; System.Console.WriteLine("检查货物，有问题，取消订单！"); order.TaskFinished = true; &#125; &#125; public class Client &#123; public static void Main(String[] args) &#123; //订单 Order order = new Order(); order.Minute = 9; order.Action(); //可以取消订单 order.IsCancel = true; order.Minute = 20; order.Action(); order.Minute = 33; order.Action(); order.Minute = 43; order.Action(); Console.Read(); &#125; &#125; &#125; 实现要点 State模式将所有与一个特定状态相关的行为都放入一个State的子类对象中，在对象状态切换时，切换相应的对象；但同时维持State的接口，这样实现了具体操作与状态转换之间的解耦。 为不同的状态引入不同的对象使得状态转换变得更加明确，而且可以保证不会出现状态不一致的情况，因为转换是原子性的——即要么彻底转换过来，要么不转换。 如果State对象没有实例变量，那么各个上下文可以共享同一个State对象，从而节省对象开销。 优缺点优点 封装了转换规则。 枚举可能的状态，在枚举状态之前需要确定状态种类。 将所有与某个状态有关的行为放到一个类中，并且可以方便地增加新的状态，只需要改变对象状态即可改变对象的行为。 允许状态转换逻辑与状态对象合成一体，而不是某一个巨大的条件语句块。 可以让多个环境对象共享一个状态对象，从而减少系统中对象的个数。 缺点 状态模式的使用必然会增加系统类和对象的个数。 状态模式的结构与实现都较为复杂，如果使用不当将导致程序结构和代码的混乱。 状态模式对“开闭原则”的支持并不太好，对于可以切换状态的状态模式，增加新的状态类需要修改那些负责状态转换的源代码，否则无法切换到新增状态；而且修改某个状态类的行为也需修改对应类的源代码。 使用场景 对象的行为依赖于它的状态（属性）并且可以根据它的状态改变而改变它的相关行为。 代码中包含大量与对象状态有关的条件语句，这些条件语句的出现，会导致代码的可维护性和灵活性变差，不能方便地增加和删除状态，使客户类与类库之间的耦合增强。在这些条件语句中包含了对象的行为，而且这些条件对应于对象的各种状态]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
        <tag>行为型</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[设计模式之中介者模式]]></title>
    <url>%2Fhexo-blog-deploy%2F2018%2F11%2F22%2F2018-11-design-pattern-mediator-pattern-note%2F</url>
    <content type="text"><![CDATA[简介中介者模式（Mediator Pattern）是用来降低多个对象和类之间的通信复杂性。这种模式提供了一个中介类，该类通常处理不同类之间的通信，并支持松耦合，使代码易于维护。中介者模式属于行为型模式。 动机在软件构建过程中，经常会出现多个对象互相关联交互的情况，对象之间常常会维持一种复杂的引用关系，如果遇到一些需求的更改，这种直接的引用关系将面临不断地变化。在这种情况下，我们可使用一个“中介对象”来管理对象间的关联关系，避免相互交互的对象之间的紧耦合引用关系，从而更好地抵御变化。 意图定义了一个中介对象来封装一系列对象之间的交互关系。中介者使各个对象之间不需要显式地相互引用，从而使耦合性降低，而且可以独立地改变它们之间的交互行为。 结构图 角色组成抽象中介者角色（Mediator）在里面定义各个同事之间交互需要的方法，可以是公共的通信方法，也可以是小范围的交互方法。 具体中介者角色（ConcreteMediator）它需要了解并维护各个同事对象，并负责具体的协调各同事对象的交互关系。 抽象同事类（Colleague）通常为抽象类，主要约束同事对象的类型，并实现一些具体同事类之间的公共功能，比如，每个具体同事类都应该知道中介者对象，也就是具体同事类都会持有中介者对象，都可以到这个类里面。 具体同事类（ConcreteColleague）实现自己的业务，需要与其他同事通信时候，就与持有的中介者通信，中介者会负责与其他同事类交互。 代码实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135namespace 中介者模式的实现&#123; //抽象中介者角色 public interface Mediator &#123; void Command(Department department); &#125; //总经理--相当于具体中介者角色 public sealed class President : Mediator &#123; //总经理有各个部门的管理权限 private Financial _financial; private Market _market; private Development _development; public void SetFinancial(Financial financial) &#123; this._financial = financial; &#125; public void SetDevelopment(Development development) &#123; this._development = development; &#125; public void SetMarket(Market market) &#123; this._market = market; &#125; public void Command(Department department) &#123; if (department.GetType() == typeof(Market)) &#123; _financial.Process(); &#125; &#125; &#125; //同事类的接口 public abstract class Department &#123; //持有中介者(总经理)的引用 private Mediator mediator; protected Department(Mediator mediator) &#123; this.mediator = mediator; &#125; public Mediator GetMediator &#123; get &#123; return mediator; &#125; private set &#123; this.mediator = value; &#125; &#125; //做本部门的事情 public abstract void Process(); //向总经理发出申请 public abstract void Apply(); &#125; //开发部门 public sealed class Development : Department &#123; public Development(Mediator m) : base(m) &#123; &#125; public override void Process() &#123; Console.WriteLine("我们是开发部门，要进行项目开发，没钱了，需要资金支持！"); &#125; public override void Apply() &#123; Console.WriteLine("专心科研，开发项目！"); &#125; &#125; //财务部门 public sealed class Financial : Department &#123; public Financial(Mediator m) : base(m) &#123; &#125; public override void Process() &#123; Console.WriteLine("汇报工作！没钱了，钱太多了！怎么花?"); &#125; public override void Apply() &#123; Console.WriteLine("数钱！"); &#125; &#125; //市场部门 public sealed class Market : Department &#123; public Market(Mediator mediator) : base(mediator) &#123; &#125; public override void Process() &#123; Console.WriteLine("汇报工作！项目承接的进度，需要资金支持！"); GetMediator.Command(this); &#125; public override void Apply() &#123; Console.WriteLine("跑去接项目！"); &#125; &#125; class Program &#123; static void Main(String[] args) &#123; // 中介者 President mediator = new President(); // 同事类 Market market = new Market(mediator); Development development = new Development(mediator); Financial financial = new Financial(mediator); mediator.SetFinancial(financial); mediator.SetDevelopment(development); mediator.SetMarket(market); market.Process(); market.Apply(); Console.Read(); &#125; &#125;&#125; 实现要点将多个对象间复杂的关联关系解耦，Mediator模式将多个对象间的控制逻辑进行集中管理，变“多个对象互相关联”为“多个对象和一个中介者关联”，简化了系统的维护，抵御了可能的变化。随着控制逻辑的复杂化，Mediator具体对象的实现可能相当复杂。这时候可以对Mediator对象进行分解处理。 门面模式与中介者模式的区别 Facade模式是解耦系统外到系统内（单向）的对相关联关系 Mediator模式是解耦系统内各个对象之间（双向）的关联关系 优缺点优点 松散耦合 中介者模式通过把多个同事对象之间的交互封装到中介对象里面，从而使得对象之间松散耦合，基本上可以做到互不依赖。这样一来，同时对象就可以独立的变化和复用，不再“牵一发动全身” 集中控制交互 多个同事对象的交互，被封装在中介者对象里面集中管理，使得这些交互行为发生变化的时候，只需要修改中介者就可以了。 多对多变为一对多 没有中介者模式的时候，同事对象之间的关系通常是多对多，引入中介者对象后，中介者和同事对象的关系通常变为双向的一对多，这会让对象的关系更容易理解和实现。 缺点 过多集中化 如果同事对象之间的交互非常多，而且比较复杂，当这些复杂性全都集中到中介者的时候，会导致中介者对象变的十分复杂，而且难于维护和管理 总结如果不使用中介者模式的话，各个同事对象将会相互进行引用，如果每个对象都与多个对象进行交互时，将会形成如下图所示的网状结构:如果不使用中介者模式的话，每个对象之间过度耦合，这样的既不利于类的复用也不利于扩展。如果引入了中介者模式，那么对象之间的关系将变成星型结构，采用中介者模式之后会形成如下图所示的结构： 使用中介者模式之后，任何一个类的变化，只会影响中介者和类本身，不像之前的设计，任何一个类的变化都会引起其关联所有类的变化。这样的设计大大减少了系统的耦合度]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
        <tag>行为型</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[设计模式之观察者模式]]></title>
    <url>%2Fhexo-blog-deploy%2F2018%2F11%2F22%2F2018-11-design-pattern-observer-pattern-note%2F</url>
    <content type="text"><![CDATA[简介当对象间存在一对多关系时，则使用观察者模式（Observer Pattern）。比如，当一个对象被修改时，则会自动通知它的依赖对象。观察者模式属于行为型模式。 动机在软件构建过程中，我们需要为某些对象建立一种“通知依赖关系”——一个对象（目标对象）的状态发生改变，所有的依赖对象（观察者对象）都将得到通知。如果这样的依赖关系过于紧密，将使软件不能很好地抵御变化。使用面向对象技术，可以将这种依赖关系弱化，并形成一种稳定的依赖关系。从而实现软件体系结构的松耦合。 意图定义对象间的一种一对多的依赖关系，以便当一个对象的状态发生改变时，所有依赖于它的对象都得到通知并自动更新。 结构图 角色组成抽象主题角色（Subject）抽象主题把所有观察者对象的引用保存在一个列表中，并提供增加和删除观察者对象的操作，抽象主题角色又叫做抽象被观察者角色，一般由抽象类或接口实现。 抽象观察者角色（Observer）为所有具体观察者定义一个接口，在得到主题通知时更新自己，一般由抽象类或接口实现。 具体主题角色（ConcreteSubject）实现抽象主题接口，具体主题角色又叫做具体被观察者角色。 具体观察者角色（ConcreteObserver）实现抽象观察者角色所要求的接口，以便使自身状态与主题的状态相协调。 代码实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153namespace 观察者模式的实现&#123; //银行短信系统抽象接口，是被观察者--该类型相当于抽象主体角色Subject public abstract class BankMessageSystem &#123; protected IList&lt;Depositor&gt; observers; //构造函数初始化观察者列表实例 protected BankMessageSystem() &#123; observers = new List&lt;Depositor&gt;(); &#125; //增加预约储户 public abstract void Add(Depositor depositor); //删除预约储户 public abstract void Delete(Depositor depositor); //通知储户 public void Notify() &#123; foreach (Depositor depositor in observers) &#123; if (depositor.AccountIsChanged) &#123; depositor.Update(depositor.Balance, depositor.OperationDateTime); //账户发生了变化，并且通知了，储户的账户就认为没有变化 depositor.AccountIsChanged = false; &#125; &#125; &#125; &#125; //北京银行短信系统，是被观察者--该类型相当于具体主体角色ConcreteSubject public sealed class BeiJingBankMessageSystem : BankMessageSystem &#123; //增加预约储户 public override void Add(Depositor depositor) &#123; //应该先判断该用户是否存在，存在不操作，不存在则增加到储户列表中，这里简化了 observers.Add(depositor); &#125; //删除预约储户 public override void Delete(Depositor depositor) &#123; //应该先判断该用户是否存在，存在则删除，不存在无操作，这里简化了 observers.Remove(depositor); &#125; &#125; //储户的抽象接口--相当于抽象观察者角色（Observer） public abstract class Depositor &#123; //状态数据 private string _name; private int _balance; private int _total; private bool _isChanged; //初始化状态数据 protected Depositor(string name, int total) &#123; this._name = name; this._balance = total;//存款总额等于余额 this._isChanged = false;//账户未发生变化 &#125; //储户的名称，假设可以唯一区别的 public string Name &#123; get &#123; return _name; &#125; private set &#123; this._name = value; &#125; &#125; public int Balance &#123; get &#123; return this._balance; &#125; &#125; //取钱 public void GetMoney(int num) &#123; if (num &lt;= this._balance &amp;&amp; num &gt; 0) &#123; this._balance = this._balance - num; this._isChanged = true; OperationDateTime = DateTime.Now; &#125; &#125; //账户操作时间 public DateTime OperationDateTime &#123; get; set; &#125; //账户是否发生变化 public bool AccountIsChanged &#123; get &#123; return this._isChanged; &#125; set &#123; this._isChanged = value; &#125; &#125; //更新储户状态 public abstract void Update(int currentBalance, DateTime dateTime); &#125; //北京的具体储户--相当于具体观察者角色ConcreteObserver public sealed class BeiJingDepositor : Depositor &#123; public BeiJingDepositor(string name, int total) : base(name, total) &#123; &#125; public override void Update(int currentBalance, DateTime dateTime) &#123; Console.WriteLine(Name + ":账户发生了变化，变化时间是" + dateTime.ToString() + ",当前余额是" + currentBalance.ToString()); &#125; &#125; // 客户端（Client） class Program &#123; static void Main(string[] args) &#123; //我们有了三位储户，都是武林高手，也比较有钱 Depositor huangFeiHong = new BeiJingDepositor("黄飞鸿", 3000); Depositor fangShiYu = new BeiJingDepositor("方世玉", 1300); Depositor hongXiGuan = new BeiJingDepositor("洪熙官", 2500); BankMessageSystem beijingBank = new BeiJingBankMessageSystem(); //这三位开始订阅银行短信业务 beijingBank.Add(huangFeiHong); beijingBank.Add(fangShiYu); beijingBank.Add(hongXiGuan); //黄飞鸿取100块钱 huangFeiHong.GetMoney(100); beijingBank.Notify(); //黄飞鸿和方世玉都取了钱 huangFeiHong.GetMoney(200); fangShiYu.GetMoney(200); beijingBank.Notify(); //他们三个都取了钱 huangFeiHong.GetMoney(320); fangShiYu.GetMoney(4330); hongXiGuan.GetMoney(332); beijingBank.Notify(); Console.Read(); &#125; &#125;&#125; 实现要点 使用面向对象的抽象，Observer模式使得我们可以独立地改变目标与观察者（面向对象中的改变不是指改代码，而是指扩展、子类化、实现接口），从而使二者之间的依赖关系达致松耦合。 目标发送通知时，无需指定观察者，通知（可以携带通知信息作为参数）会自动传播。观察者自己决定是否需要订阅通知，目标对象对此一无所知。 在C#的event中，委托充当了抽象的Observer接口，而提供事件的对象充当了目标对象。委托是比抽象Observer接口更为松耦合的设计。 优缺点优点 观察者模式实现了表示层和数据逻辑层的分离，并定义了稳定的更新消息传递机制，并抽象了更新接口，使得可以有各种各样不同的表示层，即观察者。 观察者模式在被观察者和观察者之间建立了一个抽象的耦合，被观察者并不知道任何一个具体的观察者，只是保存着抽象观察者的列表，每个具体观察者都符合一个抽象观察者的接口。 观察者模式支持广播通信。被观察者会向所有的注册过的观察者发出通知。 缺点 如果一个被观察者有很多直接和间接的观察者时，将所有的观察者都通知到会花费很多时间。 虽然观察者模式可以随时使观察者知道所观察的对象发送了变化，但是观察者模式没有相应的机制使观察者知道所观察的对象是怎样发生变化的。 如果在被观察者之间有循环依赖的话，被观察者会触发它们之间进行循环调用，导致系统崩溃，在使用观察者模式应特别注意这点。 .net中委托与观察者模式在Net里面实现的观察者模式做了一些改变，用委托或者说是事件来实现观察者模式。事件我们都很明白，我们可以注册控件的事件，当触发控件的动作时候，相应的事件就会执行，在事件的执行过程中我们就可以做相关的提醒业务。]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
        <tag>行为型</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[设计模式之迭代器模式]]></title>
    <url>%2Fhexo-blog-deploy%2F2018%2F11%2F21%2F2018-11-design-pattern-iterator-pattern-note%2F</url>
    <content type="text"><![CDATA[简介迭代器模式（Iterator Pattern）是 Java 和 .Net 编程环境中非常常用的设计模式。这种模式用于顺序访问集合对象的元素，不需要知道集合对象的底层表示。迭代器模式属于行为型模式。 动机在软件构建过程中，集合对象内部结构常常变化各异。但对于这些集合对象，我们希望在不暴露其内部结构的同时，可以让外部客户代码透明地访问其中包含的元素；同时这种“透明遍历”也为“同一种算法在多种集合对象上进行操作”提供了可能。使用面向对象技术将这种遍历机制抽象为“迭代器对象”为“应对变化中的集合对象”提供了一种优雅的方式 意图提供一种方法顺序访问一个聚合对象中的各个元素，而又不暴露该对象的内部表示。 结构图 组成1.抽象迭代器(Iterator)抽象迭代器定义了访问和遍历元素的接口，一般声明如下方法：用于获取第一个元素的first()，用于访问下一个元素的next()，用于判断是否还有下一个元素的hasNext()，用于获取当前元素的currentItem()，在其子类中将实现这些方法。 2.具体迭代器(ConcreteIterator)具体迭代器实现了抽象迭代器接口，完成对集合对象的遍历，同时在对聚合进行遍历时跟踪其当前位置。 3.抽象聚合类(Aggregate)抽象聚合类用于存储对象，并定义创建相应迭代器对象的接口，声明一个createIterator()方法用于创建一个迭代器对象。 4.具体聚合类(ConcreteAggregate)具体聚合类实现了创建相应迭代器的接口，实现了在抽象聚合类中声明的createIterator()方法，并返回一个与该具体聚合相对应的具体迭代器ConcreteIterator实例。 代码实现实现要点123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105namespace 迭代器模式的实现&#123; // 部队队列的抽象聚合类--该类型相当于抽象聚合类Aggregate public interface ITroopQueue &#123; Iterator GetIterator(); &#125; // 迭代器抽象类 public interface Iterator &#123; bool MoveNext(); Object GetCurrent(); void Next(); void Reset(); &#125; //部队队列具体聚合类--相当于具体聚合类ConcreteAggregate public sealed class ConcreteTroopQueue:ITroopQueue &#123; private string[] collection; public ConcreteTroopQueue() &#123; collection = new string[] &#123; "黄飞鸿","方世玉","洪熙官","严咏春" &#125;; &#125; public Iterator GetIterator() &#123; return new ConcreteIterator(this); &#125; public int Length &#123; get &#123; return collection.Length; &#125; &#125; public string GetElement(int index) &#123; return collection[index]; &#125; &#125; // 具体迭代器类 public sealed class ConcreteIterator : Iterator &#123; // 迭代器要集合对象进行遍历操作，自然就需要引用集合对象 private ConcreteTroopQueue _list; private int _index; public ConcreteIterator(ConcreteTroopQueue list) &#123; _list = list; _index = 0; &#125; public bool MoveNext() &#123; if (_index &lt; _list.Length) &#123; return true; &#125; return false; &#125; public Object GetCurrent() &#123; return _list.GetElement(_index); &#125; public void Reset() &#123; _index = 0; &#125; public void Next() &#123; if (_index &lt; _list.Length) &#123; _index++; &#125; &#125; &#125; // 客户端（Client） class Program &#123; static void Main(string[] args) &#123; Iterator iterator; ITroopQueue list = new ConcreteTroopQueue(); iterator = list.GetIterator(); while (iterator.MoveNext()) &#123; string ren = (string)iterator.GetCurrent(); Console.WriteLine(ren); iterator.Next(); &#125; Console.Read(); &#125; &#125;&#125; 实现要点 迭代抽象：访问一个聚合对象的内容而无需暴露它的内部表示。 迭代多态：为遍历不同的集合结构提供一个统一的接口，从而支持同样的算法在不同的集合结构上进行操作。 迭代器的健壮性考虑：遍历的同时更改迭代器所在的集合结构，会导致问题。 优缺点优点 迭代器模式使得访问一个聚合对象的内容而无需暴露它的内部表示，即迭代抽象。 迭代器模式为遍历不同的集合结构提供了一个统一的接口，从而支持同样的算法在不同的集合结构上进行操作 缺点 迭代器模式在遍历的同时更改迭代器所在的集合结构会导致出现异常。所以使用foreach语句只能在对集合进行遍历，不能在遍历的同时更改集合中的元素。 使用场景 访问一个聚合对象的内容而无需暴露它的内部表示。 支持对聚合对象的多种遍历。 为遍历不同的聚合结构提供一个统一的接口(即, 支持多态迭代)。]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
        <tag>行为型</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[设计模式之命令模式]]></title>
    <url>%2Fhexo-blog-deploy%2F2018%2F11%2F21%2F2018-11-design-pattern-command-pattern-note%2F</url>
    <content type="text"><![CDATA[简介命令模式（Command Pattern）是一种数据驱动的设计模式，它属于行为型模式。请求以命令的形式包裹在对象中，并传给调用对象。调用对象寻找可以处理该命令的合适的对象，并把该命令传给相应的对象，该对象执行命令。 动机在软件构建过程中，行为请求者与行为实现者通常呈现一种“紧耦合”。但在某些场合——比如需要对行为进行“记录、撤销/重做（undo/redo）、事务”等处理，这种无法抵御变化的紧耦合是不合适的。在这种情况下，如何将“行为请求者”与“行为实现者”解耦？将一组行为抽象为对象，可以实现二者之间的松耦合。 意图将一个请求封装为一个对象，从而使你可用不同的请求对客户（客户程序，也是行为的请求者）进行参数化；对请求排队或记录请求日志，以及支持可撤销的操作。 结构图 模式的组成客户角色（Client）创建具体的命令对象，并且设置命令对象的接收者。注意这个不是我们常规意义上的客户端，而是在组装命令对象和接收者，或许，把这个Client称为装配者会更好理解，因为真正使用命令的客户端是从Invoker来触发执行。 命令角色（Command）声明了一个给所有具体命令类实现的抽象接口。 具体命令角色（ConcreteCommand）命令接口实现对象，是“虚”的实现；通常会持有接收者，并调用接收者的功能来完成命令要执行的操作。 请求者角色（Invoker）要求命令对象执行请求，通常会持有命令对象，可以持有很多的命令对象。这个是客户端真正触发命令并要求命令执行相应操作的地方，也就是说相当于使用命令对象的入口。 接受者角色（Receiver）接收者，真正执行命令的对象。任何类都可能成为一个接收者，只要它能够实现命令要求实现的相应功能 代码实现12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879namespace 命令模式的实现&#123; /// &lt;summary&gt; /// 俗话说：“好吃不如饺子，舒服不如倒着”。今天奶奶发话要吃他大孙子和孙媳妇包的饺子。今天还拿吃饺子这件事来说说命令模式的实现吧。 /// &lt;/summary&gt; class Client &#123; static void Main(string[] args) &#123; //奶奶想吃猪肉大葱馅的饺子 PatrickLiuAndWife liuAndLai = new PatrickLiuAndWife();//命令接受者 Command command = new MakeDumplingsCommand(liuAndLai);//命令 PaPaInvoker papa = new PaPaInvoker(command); //命令请求者 //奶奶发布命令 papa.ExecuteCommand(); Console.Read(); &#125; &#125; //这个类型就是请求者角色--也就是我爸爸的角色，告诉奶奶要吃饺子 public sealed class PaPaInvoker &#123; //我爸爸从奶奶那里接受到的命令 private Command _command; //爸爸开始接受具体的命令 public PaPaInvoker(Command command) &#123; this._command = command; &#125; //爸爸给我们下达命令 public void ExecuteCommand() &#123; _command.MakeDumplings(); &#125; &#125; //该类型就是抽象命令角色--Commmand，定义了命令的抽象接口，任务是包饺子 public abstract class Command &#123; //真正任务的接受者 protected PatrickLiuAndWife _worker; protected Command(PatrickLiuAndWife worker) &#123; _worker = worker; &#125; //该方法就是抽象命令对象Command的Execute方法 public abstract void MakeDumplings(); &#125; //该类型是具体命令角色--ConcreteCommand，这个命令完成制作“猪肉大葱馅”的饺子 public sealed class MakeDumplingsCommand : Command &#123; public MakeDumplingsCommand(PatrickLiuAndWife worker) : base(worker) &#123; &#125; //执行命令--包饺子 public override void MakeDumplings() &#123; //执行命令---包饺子 _worker.Execute("今天包的是农家猪肉和农家大葱馅的饺子"); &#125; &#125; //该类型是具体命令接受角色Receiver，具体包饺子的行为是我们夫妻俩来完成的 public sealed class PatrickLiuAndWife &#123; //这个方法相当于Receiver类型的Action方法 public void Execute(string job) &#123; Console.WriteLine(job); &#125; &#125;&#125; 实现要点 Command模式的根本目的在于将行为请求者与行为实现者解耦，在面向对象语言中，常见的实现手段是“将行为抽象为对象”。 实现Command接口的具体命令对象ConcreteCommand有时候根据需要可能会保存一些额外的状态信息。 通过使用Composite组合模式，可以将多个命令封装为一个“复合命令”MacroCommand。 Command模式与C#中的Delegate有些类似。但两者定义行为接口的规范有所区别：Command以面向对象中的“接口-实现”来定义行为接口规范，更严格，更符合抽象原则；Delegate以函数签名来定义行为接口规范，更灵活，但抽象能力比较弱。 使用命令模式会导致某些系统有过多的具体命令类。某些系统可能需要几十个，几百个甚至几千个具体命令类，这会使命令模式在这样的系统里变得不实际。 优缺点优点 命令模式使得新的命令很容易被加入到系统里。 可以设计一个命令队列来实现对请求的Undo和Redo操作。 可以较容易地将命令写入日志。 可以把命令对象聚合在一起，合成为合成命令。合成命令式合成模式的应用。 缺点 使用命令模式可能会导致系统有过多的具体命令类。这会使得命令模式在这样的系统里变得不实际。 使用场景 系统需要支持命令的撤销（undo）。命令对象可以把状态存储起来，等到客户端需要撤销命令所产生的效果时，可以调用undo方法把命令所产生的效果撤销掉。命令对象还可以提供redo方法，以供客户端在需要时，再重新实现命令效果。 系统需要在不同的时间指定请求、将请求排队。一个命令对象和原先的请求发出者可以有不同的生命周期。意思为：原来请求的发出者可能已经不存在了，而命令对象本身可能仍是活动的。这时命令的接受者可以在本地，也可以在网络的另一个地址。命令对象可以串行地传送到接受者上去。 如果一个系统要将系统中所有的数据消息更新到日志里，以便在系统崩溃时，可以根据日志里读回所有数据的更新命令，重新调用方法来一条一条地执行这些命令，从而恢复系统在崩溃前所做的数据更新。 系统需要使用命令模式作为CallBack(回调)在面向对象系统中的替代。Callback即是先将一个方法注册上，然后再以后调用该方法。 .net的实现由于.NET有了Delegate，它很少很少用到Command。它只要需要用到行为抽象，它都用Delegate去做。]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
        <tag>行为型</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[设计模式之模板方法模式]]></title>
    <url>%2Fhexo-blog-deploy%2F2018%2F11%2F19%2F2018-11-design-pattern-template-method-pattern-note%2F</url>
    <content type="text"><![CDATA[简介在模板模式（Template Pattern）中，一个抽象类公开定义了执行它的方法的方式/模板。它的子类可以按需要重写方法实现，但调用将以抽象类中定义的方式进行。这种类型的设计模式属于行为型模式。 动机在软件构建过程中，“行为请求者”与“行为实现者”通常呈现一种“紧耦合”。但在某些场合——比如需要对行为进行“记录、撤销/重做（undo/redo）、事务”等处理，这种无法抵御变化的紧耦合是不合适的。在这种情况下，如何将“行为请求者”与“行为实现者”解耦？将一组行为抽象为对象，可以实现二者之间的松耦合。 意图将一个请求封装为一个对象，从而使你可用不同的请求对客户（客户程序，也是行为的请求者）进行参数化；对请求排队或记录请求日志，以及支持可撤销的操作。 结构图 模式的组成抽象类角色（AbstractClass）定义一个模板方法（TemplateMethod），在该方法中包含着一个算法的骨架，具体的算法步骤是PrimitiveOperation1方法和PrimitiveOperation2方法，该抽象类的子类将重定义PrimitiveOperation1和PrimitiveOperation2操作。 具体类角色（ConcreteClass）实现PrimitiveOperation1方法和PrimitiveOperation2方法以完成算法中与特定子类（Client）相关的内容。 Notes在模板方法模式中，AbstractClass中的TemplateMethod提供了一个标准模板，该模板包含PrimitiveOperation1和PrimitiveOperation2两个方法，这两个方法的内容Client可以根据自己的需要重写。 代码实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100namespace 模板方法模式的实现&#123; /// &lt;summary&gt; /// 好吃不如饺子，舒服不如倒着，我最喜欢吃我爸爸包的饺子，今天就拿吃饺子这件事来看看模板方法的实现吧 /// &lt;/summary&gt; class Client &#123; static void Main(string[] args) &#123; //现在想吃绿色面的，猪肉大葱馅的饺子 AbstractClass fan = new ConcreteClass(); fan.EatDumplings(); Console.WriteLine(); //过了段时间，我开始想吃橙色面的，韭菜鸡蛋馅的饺子 fan = new ConcreteClass2(); fan.EatDumplings(); Console.Read(); &#125; &#125; //该类型就是抽象类角色--AbstractClass，定义做饺子的算法骨架，这里有三步骤，当然也可以有多个步骤，根据实际需要而定 public abstract class AbstractClass &#123; //该方法就是模板方法，方法里面包含了做饺子的算法步骤，模板方法可以返回结果，也可以是void类型，视具体情况而定 public void EatDumplings() &#123; //和面 MakingDough(); //包馅 MakeDumplings(); //煮饺子 BoiledDumplings(); Console.WriteLine("饺子真好吃！"); &#125; //要想吃饺子第一步肯定是“和面”---该方法相当于算法中的某一步 public abstract void MakingDough(); //要想吃饺子第二部是“包饺子”---该方法相当于算法中的某一步 public abstract void MakeDumplings(); //要想吃饺子第三部是“煮饺子”---该方法相当于算法中的某一步 public abstract void BoiledDumplings(); &#125; //该类型是具体类角色--ConcreteClass，我想吃绿色面皮，猪肉大葱馅的饺子 public sealed class ConcreteClass : AbstractClass &#123; //要想吃饺子第一步肯定是“和面”---该方法相当于算法中的某一步 public override void MakingDough() &#123; //我想要面是绿色的，绿色健康嘛，就可以在此步定制了 Console.WriteLine("在和面的时候加入芹菜汁，和好的面就是绿色的"); &#125; //要想吃饺子第二部是“包饺子”---该方法相当于算法中的某一步 public override void MakeDumplings() &#123; //我想吃猪肉大葱馅的，在此步就可以定制了 Console.WriteLine("农家猪肉和农家大葱，制作成馅"); &#125; //要想吃饺子第三部是“煮饺子”---该方法相当于算法中的某一步 public override void BoiledDumplings() &#123; //我想吃大铁锅煮的饺子，有家的味道，在此步就可以定制了 Console.WriteLine("用我家的大铁锅和大木材煮饺子"); &#125; &#125; //该类型是具体类角色--ConcreteClass2，我想吃橙色面皮，韭菜鸡蛋馅的饺子 public sealed class ConcreteClass2 : AbstractClass &#123; //要想吃饺子第一步肯定是“和面”---该方法相当于算法中的某一步 public override void MakingDough() &#123; //我想要面是橙色的，加入胡萝卜汁就可以。在此步定制就可以了。 Console.WriteLine("在和面的时候加入胡萝卜汁，和好的面就是橙色的"); &#125; //要想吃饺子第二部是“包饺子”---该方法相当于算法中的某一步 public override void MakeDumplings() &#123; //我想吃韭菜鸡蛋馅的，在此步就可以定制了 Console.WriteLine("农家鸡蛋和农家韭菜，制作成馅"); &#125; //要想吃饺子第三部是“煮饺子”---该方法相当于算法中的某一步 public override void BoiledDumplings() &#123; //此处没要求 Console.WriteLine("可以用一般煤气和不粘锅煮就可以"); &#125; &#125;&#125; 实现要点 TemplateMethod模式是一种非常基础性的设计模式，在面向对象系统中大量应用。它用最简洁的机制（基础、多态）为很多应用程序框架提供了灵活的扩展点，是代码复用方面的基本实现结构。 在具体实现方面，被TemplateMethod调用的虚方法可以具有实现，也可以没有任何实现（抽象方法或虚方法）。但一般推荐将它们设置为protected方法使得只有子类可以访问它们。 模板方法模式通过对子类的扩展增加新的行为，符合“开闭原则”。 适用场景 一次性实现一个算法的不变部分，并将可变的行为留给子类来实现。 各子类中公共的行为应被提取出来并集中到一个公共父类中以避免代码重复。 控制子类扩展。模板方法只允许在特定点进行扩展，而模板部分则是稳定的。]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
        <tag>行为型</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[设计模式之代理模式]]></title>
    <url>%2Fhexo-blog-deploy%2F2018%2F11%2F17%2F2018-11-design-pattern-proxy-pattern-note%2F</url>
    <content type="text"><![CDATA[简介“代理”可以理解为“代替”，代替“主人”做一些事情，为什么需要“代理”，是因为某些原因（比如：安全方面的原因），不想让“主人”直接面对这些繁琐、复杂的问题，但是这些事情是经“主人”同意或者授意的，如同“主人”亲自完成的一样。 动机在面向对象系统中，有些对象由于某种原因（比如对象创建的开销很大，或者某些操作需要安全控制，或者需要进程外的访问等），直接访问会给使用者、或者系统结构带来很多麻烦。如何在不失去透明操作对象的同时来管理/控制这些对象特有的复杂性？增加一层间接层是软件开发中常见的解决方式。 意图为其他对象提供一种代理以控制对这个对象的访问 结构图 组成角色抽象主题角色（Subject）声明了真实主题和代理主题的公共接口，这样一来在使用真实主题的任何地方都可以使用代理主题。 代理主题角色（Proxy）代理主题角色内部含有对真实主题的引用，从而可以操作真实主题对象；代理主题角色负责在需要的时候创建真实主题对象；代理角色通常在将客户端调用传递到真实主题之前或之后，都要执行一些其他的操作，而不是单纯地将调用传递给真实主题对象。 真实主题角色（RealSubject）定义了代理角色所代表的真实对象。 Notes在WCF或者WebService的开发过程中，我们在客户端添加服务引用的时候，在客户程序中会添加一些额外的类，在客户端生成的类扮演着代理主题角色，我们客户端也是直接调用这些代理角色来访问远程服务提供的操作。这个是远程代理的一个典型例子。 代理模式的类型 远程（Remote）代理：为一个位于不同的地址空间的对象提供一个局域代表对象。这个不同的地址空间可以是本电脑中，也可以在另一台电脑中。最典型的例子就是——客户端调用Web服务或WCF服务。 虚拟（Virtual）代理：根据需要创建一个资源消耗较大的对象，使得对象只在需要时才会被真正创建。 Copy-on-Write代理：虚拟代理的一种，把复制（或者叫克隆）拖延到只有在客户端需要时，才真正采取行动。 保护（Protect or Access）代理：控制一个对象的访问，可以给不同的用户提供不同级别的使用权限。 防火墙（Firewall）代理：保护目标不让恶意用户接近。 智能引用（Smart Reference）代理：当一个对象被引用时，提供一些额外的操作，比如将对此对象调用的次数记录下来等。 Cache代理：为某一个目标操作的结果提供临时的存储空间，以便多个客户端可以这些结果。 实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869namespace 代理模式的实现&#123; /// &lt;summary&gt; /// 大明星都有钱，有钱了，就可以请自己的经纪人了，有了经纪人，很多事情就不用自己亲力亲为。弄点绯闻，炒作一下子通过经纪人就可以名正言顺的的操作了，万一搞不好，自己也可以否认。 /// &lt;/summary&gt; class Client &#123; static void Main(string[] args) &#123; //近期，Fan姓明星关注度有点下降，来点炒作 AgentAbstract fan = new AgentPerson(); fan.Speculation("偶尔出来现现身，为炒作造势"); Console.WriteLine(); //过了段时间，又不行了，再炒作一次 fan.Speculation("这段时间不火了，开始离婚炒作"); Console.Read(); &#125; &#125; //该类型就是抽象Subject角色，定义代理角色和真实主体角色共有的接口方法 public abstract class AgentAbstract &#123; //该方法执行具体的炒作---该方法相当于抽象Subject的Request方法 public virtual void Speculation(string thing) &#123; Console.WriteLine(thing); &#125; &#125; //该类型是Fan姓明星，有钱有势，想炒什么炒什么---相当于具体的RealSubject角色 public sealed class FanStar : AgentAbstract &#123; //有钱有势，有背景啊 public FanStar() &#123; &#125; //要有名气，定期要炒作---就是RealSubject类型的Request方法 public override void Speculation(string thing) &#123; Console.WriteLine(thing); &#125; &#125; //该类型是代理类型----相当于具体的Proxy角色 public sealed class AgentPerson : AgentAbstract &#123; //这是背后的老板， private FanStar boss; //老板在后面发号施令 public AgentPerson() &#123; boss = new FanStar(); &#125; //炒作的方法，执行具体的炒作---就是Proxy类型的Request方法 public override void Speculation(string thing) &#123; Console.WriteLine("前期弄点绯闻，拍点野照"); base.Speculation(thing); Console.WriteLine("然后开发布会，伤心哭泣，继续捞钱"); &#125; &#125;&#125; 实现要点“增加一层间接层”是软件系统中对许多复杂问题的一种常见解决方法。在面向对象系统中，直接使用某些对象会来带很多问题，作为间接层的Proxy对象便是解决这一问题的常用手段。具体Proxy设计模式的实现方法、实现粒度都相差很大，有些可能对单个对象做细粒度的控制，如copy-on-write技术，有些可能对组件模块提供抽象代理层，在架构层次对对象做Proxy。Proxy并不一定要求保持接口的一致性，只要能够实现间接控制，有时候损及一些透明性是可以接受的。 优缺点优点 代理模式能够将调用用于真正被调用的对象隔离，在一定程度上降低了系统的耦合度； 代理对象在客户端和目标对象之间起到一个中介的作用，这样可以起到对目标对象的保护。代理对象可以在对目标对象发出请求之前进行一个额外的操作，例如权限检查等。 不同类型的代理模式也具有独特的优点，例如： 远程代理为位于两个不同地址空间对象的访问提供了一种实现机制，可以将一些消耗资源较多的对象和操作移至性能更好的计算机上，提高系统的整体运行效率。 虚拟代理通过一个消耗资源较少的对象来代表一个消耗资源较多的对象，可以在一定程度上节省系统的运行开销。 缓冲代理为某一个操作的结果提供临时的缓存存储空间，以便在后续使用中能够共享这些结果，优化系统性能，缩短执行时间。 保护代理可以控制对一个对象的访问权限，为不同用户提供不同级别的使用权限。 缺点 由于在客户端和真实主题之间增加了一个代理对象，所以会造成请求的处理速度变慢 实现代理类也需要额外的工作，从而增加了系统的实现复杂度。 使用场景代理模式的类型较多，不同类型的代理模式有不同的优缺点，它们应用于不同的场合： 当客户端对象需要访问远程主机中的对象时可以使用远程代理。 当需要用一个消耗资源较少的对象来代表一个消耗资源较多的对象，从而降低系统开销、缩短运行时间时可以使用虚拟代理，例如一个对象需要很长时间才能完成加载时。 当需要为某一个被频繁访问的操作结果提供一个临时存储空间，以供多个客户端共享访问这些结果时可以使用缓冲代理。通过使用缓冲代理，系统无须在客户端每一次访问时都重新执行操作，只需直接从临时缓冲区获取操作结果即可。 当需要控制对一个对象的访问，为不同用户提供不同级别的访问权限时可以使用保护代理。 当需要为一个对象的访问（引用）提供一些额外的操作时可以使用智能引用代理。 .net 的代理模式代理模式在Net的FCL中的实现也不少，框架级别的有，类级别的也有。框架级别的有WCF,Remoting,他们都需要生成本地的代理，然后通过代理访问进程外或者机器外的对象。类级别的有StringBuilder类型，StringBuilder其实就是一种代理，我们本意是想访问字符串的，StringBuilder就是一种可变字符串的代理，而且StringBuilder也没有和String保持接口的一致性。]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
        <tag>结构型</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[设计模式之工厂享元模式]]></title>
    <url>%2Fhexo-blog-deploy%2F2018%2F11%2F15%2F2018-11-design-pattern-flyweight-pattern-note%2F</url>
    <content type="text"><![CDATA[简介构成事物的最小单元我们称之为“元”，这些单元如果是大量、且重复出现，可以缓存重复出现的单元，达到节省内存的目的，换句说法就是享元是为了节省空间，对于计算机而言就是内存。面向对象很好地解决了系统抽象性的问题（系统抽象性指把系统里面的事物写成类，类可以实例化成为对象，用对象和对象之间的关系来设计系统），在大多数情况下，这样做是不会损及系统的性能的。但是，在某些特殊的应用中，由于对象的数量太大，并且这些大量的对象中有很多是重复的，如果每个对象都单独的创建（C#的语法是new）出来，会给系统带来难以承受的内存开销。比如图形应用中的图元等对象、字处理应用中的字符对象等。 动机在软件系统中，采用纯粹对象方案的问题在于大量细粒度的对象会很快充斥在系统中，从而带来很高的运行时代价——主要指内存需求方面的代价。如何在避免大量细粒度对象问题的同时，让外部客户程序仍然能够透明地使用面向对象的方式来进行操作。 意图运用共享技术有效地支持大量细粒度的对象。 结构图 模式的组成抽象享元角色（Flyweight）此角色是所有的具体享元类的基类，为这些类规定出需要实现的公共接口。那些需要外部状态的操作可以通过调用方法以参数形式传入。 具体享元角色（ConcreteFlyweight）实现抽象享元角色所规定的接口。如果有内部状态的话，可以在类内部定义。 享元工厂角色（FlyweightFactory）本角色负责创建和管理享元角色。本角色必须保证享元对象可以被系统适当地共享，当一个客户端对象调用一个享元对象的时候，享元工厂角色检查系统中是否已经有一个符合要求的享元对象，如果已经存在，享元工厂角色就提供已存在的享元对象，如果系统中没有一个符合的享元对象的话，享元工厂角色就应当创建一个合适的享元对象。 代码实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134namespace 享元模式的实现 &#123; /// &lt;summary&gt; /// 享元模式不是很难，但是有些状态需要单独处理，以下就是该模式的C#实现，有些辅助类，大家应该看得出吧，别混了。 /// &lt;/summary&gt; class Client &#123; static void Main(string[] args) &#123; //比如，我们现在需要10000个一般士兵，只需这样 SoldierFactory factory = new SoldierFactory(); AK47 ak47 = new AK47(); for (int i = 0; i &lt; 100; i++) &#123; Soldier soldier = null; if (i &lt;= 20) &#123; soldier = factory.GetSoldier("士兵" + (i + 1), ak47, SoldierType.Normal); &#125; else &#123; soldier = factory.GetSoldier("士兵" + (i + 1), ak47, SoldierType.Water); &#125; soldier.Fight(); &#125; //我们有这么多的士兵，但是使用的内存不是很多，因为我们缓存了。 Console.Read(); &#125; &#125; //这些是辅助类型 public enum SoldierType &#123; Normal, Water &#125; //该类型就是抽象战士Soldier--该类型相当于抽象享元角色 public abstract class Soldier &#123; //通过构造函数初始化士兵的名称 protected Soldier(string name) &#123; this.Name = name; &#125; //士兵的名字 public string Name &#123; get; private set; &#125; //可以传入不同的武器就用不同的活力---该方法相当于抽象Flyweight的Operation方法 public abstract void Fight(); public Weapen WeapenInstance &#123; get; set; &#125; &#125; //一般类型的战士，武器就是步枪---相当于具体的Flyweight角色 public sealed class NormalSoldier : Soldier &#123; //通过构造函数初始化士兵的名称 public NormalSoldier(string name) : base(name) &#123; &#125; //执行享元的方法---就是Flyweight类型的Operation方法 public override void Fight() &#123; WeapenInstance.Fire("士兵："+Name+" 在陆地执行击毙任务"); &#125; &#125; //这是海军陆战队队员，武器精良----相当于具体的Flyweight角色 public sealed class WaterSoldier : Soldier &#123; //通过构造函数初始化士兵的名称 public WaterSoldier(string name) : base(name) &#123; &#125; //执行享元的方法---就是Flyweight类型的Operation方法 public override void Fight() &#123; WeapenInstance.Fire("士兵："+Name+" 在海中执行击毙任务"); &#125; &#125; //此类型和享元没太大关系，可以算是享元对象的状态吧，需要从外部定义 public abstract class Weapen &#123; public abstract void Fire(string jobName); &#125; //此类型和享元没太大关系，可以算是享元对象的状态吧，需要从外部定义 public sealed class AK47:Weapen &#123; public override void Fire(string jobName) &#123; Console.WriteLine(jobName); &#125; &#125; //该类型相当于是享元的工厂---相当于FlyweightFactory类型 public sealed class SoldierFactory &#123; private static IList&lt;Soldier&gt; soldiers; static SoldierFactory() &#123; soldiers = new List&lt;Soldier&gt;(); &#125; Soldier mySoldier = null; //因为我这里有两种士兵，所以在这里可以增加另外一个参数，士兵类型，原模式里面没有， public Soldier GetSoldier(string name, Weapen weapen, SoldierType soldierType) &#123; foreach (Soldier soldier in soldiers) &#123; if (string.Compare(soldier.Name, name, true) == 0) &#123; mySoldier = soldier; return mySoldier; &#125; &#125; //我们这里就任务名称是唯一的 if (soldierType == SoldierType.Normal) &#123; mySoldier = new NormalSoldier(name); &#125; else &#123; mySoldier = new WaterSoldier(name); &#125; mySoldier.WeapenInstance = weapen; soldiers.Add(mySoldier); return mySoldier; &#125; &#125; &#125; 实现要点 面向对象很好地解决了抽象性的问题，但是作为一个运行在机器中的程序实体，我们需要考虑对象的代价问题。Flyweight设计模式主要解决面向对象的代价问题，一般不触及面向对象的抽象性问题。 Flyweight采用对象共享的做法来降低系统中对象的个数，从而降低细粒度对象给系统带来的内存压力。在具体实现方面，要注意对象状态的处理。 对象的数量太大从而导致对象内存开销加大——什么样的数量才算大？这需要我们仔细的根据具体应用情况进行评估，而不能凭空臆断。 优缺点优点 享元模式的优点在于它能够极大的减少系统中对象的个数。 享元模式由于使用了外部状态，外部状态相对独立，不会影响到内部状态，所以享元模式使得享元对象能够在不同的环境被共享。 缺点 由于享元模式需要区分外部状态和内部状态，使得应用程序在某种程度上来说更加复杂化了。 为了使对象可以共享，享元模式需要将享元对象的状态外部化，而读取外部状态使得运行时间变 使用场景 一个系统中有大量的对象； 这些对象耗费大量的内存； 这些对象中的状态大部分都可以被外部化 这些对象可以按照内部状态分成很多的组，当把外部对象从对象中剔除时，每一个组都可以仅用一个对象代替软件系统不依赖这些对象的身份， 满足上面的条件的系统可以使用享元模式。但是使用享元模式需要额外维护一个记录子系统已有的所有享元的表，而这也需要耗费资源，所以，应当在有足够多的享元实例可共享时才值得使用享元模式。]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
        <tag>结构型</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[微服务框架Surging之缓存中间件配置]]></title>
    <url>%2Fhexo-blog-deploy%2F2018%2F11%2F10%2F2018-11-surging-cache-middleware-config%2F</url>
    <content type="text"><![CDATA[通过指定CachingSettings.Class来选择配置的缓存中间件的上下文参数,当前Surging支持两种类型的缓存中间件: Redis MemoryCache 缓存中间件的配置项如下所述: 配置项 说明 备注 CachingSettings.Id 缓存中间件的唯一标识 CachingSettings.Class 缓存中间件的的上下文参数,格式为: 缓存中间件上下文,程序集名称 CachingSettings.InitMethod 指定初始化的方法 CachingSettings.Maps CachingSettings.Properties 配置缓存中间件上下文的参数 参数类型为数组 redis配置CachingSettings.Class 配置项的值为: Surging.Core.Caching.RedisCache.RedisContext,Surging.Core.Caching除此之外，通过CachingSettings.Properties 配置redis的链接、账号、密码、默认到期时间、连接超时等属性。 MemoryCache内存缓存，默认的缓存中间件，不支持分布式应用。 缓存中间件的扩展可以通过扩展CachingSettings.Class 和 ICacheProvider 来扩展指定类型的缓存中间件。]]></content>
      <categories>
        <category>微服务</category>
      </categories>
      <tags>
        <tag>微服务</tag>
        <tag>Surging</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[微服务框架Surging之消息中间件配置]]></title>
    <url>%2Fhexo-blog-deploy%2F2018%2F11%2F10%2F2018-11-surging-message-middleware-config%2F</url>
    <content type="text"><![CDATA[Surging框架支持RabbitMq和Kafka中间件。 RabbitMq中间件配置 配置项 说明 备注 EventBusConnection RabbitMq服务地址 EventBusUserName 用户名 EventBusPassword 密码 VirtualHost 虚拟主机 MessageTTL 消息过期时间，比如过期时间是30分钟就是1800000 RetryCount 重试次数 FailCount 处理失败流程重试次数，如果出现异常，会进行重试 PrefetchCount 设置均匀分配消费者消息的个数 BrokerName BrokerName Port RabbitMq服务端口号 RabbitMq参考资料: https://www.jianshu.com/p/cd15278fa38b http://rabbitmq.mr-ping.com/ Kafka中间件配置 配置项 说明 备注 Servers MaxQueueBuffering MaxSocketBlocking EnableAutoCommit LogConnectionClose OffsetReset GroupID Kafka参考资料: http://orchome.com/kafka/index]]></content>
      <categories>
        <category>微服务</category>
      </categories>
      <tags>
        <tag>微服务</tag>
        <tag>开源框架</tag>
        <tag>Surging</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[微服务框架Surging之服务注册中心配置]]></title>
    <url>%2Fhexo-blog-deploy%2F2018%2F11%2F10%2F2018-11-surging-service-registry-center-config%2F</url>
    <content type="text"><![CDATA[Surging 支持Consul和Zookeeper作为服务注册中心。 Consul配置 配置项 说明 备注 ConnectionString Consul服务注册中心地址 SessionTimeout 会话超时时间 RoutePath 服务组件地址 服务引擎会通过指定该地址扫描到相应的服务组件，并解析到相应的服务与命令 ReloadOnChange 当配置改变后是否重新加载 Zookeeper配置略]]></content>
      <categories>
        <category>微服务</category>
      </categories>
      <tags>
        <tag>微服务</tag>
        <tag>开源框架</tag>
        <tag>Surging</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[微服务框架Surging之组件配置]]></title>
    <url>%2Fhexo-blog-deploy%2F2018%2F11%2F08%2F2018-11-surging-config%2F</url>
    <content type="text"><![CDATA[微服务的配置项可以通过指定的环境变量改写。微服务的配置采用Json文件来编写，配置格式如下所示:1配置项:&quot;$&#123;环境变量名称&#125;|默认值&quot; Surging节点配置该节点主要配置微服务主机运行时的相关参数,包括主机IP、端口号、更新路由的心跳间隔、运行的最大并发量等参数。 如下表所述: 配置项 说明 备注 Surging.Address 配置微服务主机的Ip地址或域名 Surging.WatchInterval 设置向服务注册中心更新路由数据的心跳值 缺省值为20s Surging.Port 微服务主机运行的端口号 Surging.MappingIp 映射的Ip地址 暂不需要配置 Surging.MappingPort 映射的端口号 暂不需要配置 Surging.Token 是否验证Token 缺省值为True Surging.Libuv 是否开启Libuv 缺省值为false Surging.Protocol 配置微服务组件支持的协议 缺省值为: None; 可选的值: 1.None 2. Tcp 3.Http 4.Ws Surging.RootPath 指定服务引擎解析的业务模块路径 Surging.Ports.HttpPort 指定微服务对外提供的Http端口号 微服务组件必须依赖KestrelHttpModule才会对外提供Http服务，该配置项才有效 Surging.Ports.WsPort 指定微服务对外提供的Ws端口号 微服务组件必须依赖WSProtocolModule才会对外提供WS服务，该配置项才有效 除了上述配置项之外，Surging配置节点还支持对服务组件的命令进行缺省配置。Surging框架在解析命令时,会有优先采用命令的特性值，然后是Surging节点下的配置值，如果都不存在，则会使用缺省值。关于命令的配置参数请参考定义命令一节。 Swagger配置只有微服务组件对外提供了Http服务，才可能生成Swagger文档。微服务必须依赖KestrelHttpModule和安装了Surging.Core.Swagger组件包，并且配置了Swagger相关参数，才可能生成SwaggerApi文档。 Swagger配置参数如下表所述: 配置项 说明 备注 Swagger.Version Api文档的版本号 Swagger.Title Api文档标题 建议填写微服务组件的名称 Swagger.Contact.Name 联系人 建议填写微服务组件的开发责任人 Swagger.Contact.Uri 微服务组件的项目地址 Swagger.Contact.Email 联系人的Email 日志级别配置该节点主要配置日志组件输出日志的级别。日志组件的输出级别除了受该节点本身的影响之外，还受日志组件本身的配置文件影响。日志级别的配置与 Asp.Net Core 的配置一致，在此不做赘述。]]></content>
      <categories>
        <category>微服务</category>
      </categories>
      <tags>
        <tag>微服务</tag>
        <tag>开源框架</tag>
        <tag>Surging</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[微服务框架Surging通信之通知]]></title>
    <url>%2Fhexo-blog-deploy%2F2018%2F11%2F08%2F2018-11-surging-notice%2F</url>
    <content type="text"><![CDATA[Surging框架支持Netty与websocket进行通信。 应用场景WebSocket用于服务端向客户端向客户端推送消息。 用法构建ws服务主机请参考 定义服务与命令。Ws的服务与命令的定义与应用业务接口的定义一致，但是需要注意的是，命令的负载均衡算法必须选择哈希算法,命令的第一个参数必须为string类型,否则无法通过分布式部署ws服务(,Ws服务是通过命令接口的第一个参数的Hash值进行寻址的)。 例如:12345678910[ServiceBundle("v1/messagenotify/&#123;Service&#125;")]public interface IMessageNotify : IServiceKey&#123; /// &lt;summary&gt; /// 数字化放行评估过程中的消息 /// &lt;/summary&gt; /// &lt;returns&gt;&lt;/returns&gt; [Command(ShuntStrategy = AddressSelectorMode.HashAlgorithm)] Task&lt;bool&gt; EvalMessage(string flightId, EvalMessage evalMessage);&#125; 实现应用接口WS服务的应用类与一般业务应用类不同的是,继承的基类是WSServiceBase, OnOpen()会发生在客户端与Ws服务建立链接时触发(即：握手阶段),OnClose()会方法在客户端与服务端失去连接时触发。一般地，我们会在客户端与服务握手阶段，将客户端的标识与SessionId的对应关系保存在一个字典中，以方便确定推送到哪个客户端。 12345678910111213141516171819202122232425262728293031323334[ModuleName("MessageNotify")] public class MessageNotify : WSServiceBase, IMessageNotify &#123; private readonly ILogger&lt;MessageNotify&gt; _logger; private static readonly ConcurrentDictionary&lt;string, string&gt; _flightIds = new ConcurrentDictionary&lt;string, string&gt;(); public MessageNotify(ILogger&lt;MessageNotify&gt; logger) &#123; _logger = logger; &#125; // 注意：ws服务之间的调用只能通过基于routepath远程调用，不支持通过接口创建代理远程调用 public Task&lt;bool&gt; EvalMessage(string flightId, EvalMessage evalMessage) &#123; var sessionId = _flightIds[flightId]; if (string.IsNullOrEmpty(sessionId)) &#123; if (_logger.IsEnabled(Microsoft.Extensions.Logging.LogLevel.Debug)) _logger.LogDebug($"未建立与$&#123;flightId&#125;的会话"); return Task.FromResult(false); &#125; GetClient().SendTo(evalMessage.Message, sessionId); return Task.FromResult(true); &#125; protected override void OnOpen() &#123; var flightId = Context.QueryString["flightId"]; if (!string.IsNullOrEmpty(flightId)) &#123; _flightIds[flightId] = ID; &#125; &#125; &#125; 推送消息需要注意的是, ws服务之间的调用只能通过基于routepath远程调用，不支持通过接口创建代理远程调用。一般情况下，建议在通用的业务组件，创建一个调用ws的服务，这样方便各个业务组件的消息推送。 12345678910111213141516public class NotifyMessageProxy : ITransientDependency&#123; private const string NotifyApi = "v1/messagenotify//evalmessage"; public Task&lt;bool&gt; NotifyEvalMessage(string flightId, string message) &#123; var rpcParams = new Dictionary&lt;string, object&gt;(); rpcParams.Add("flightId", flightId); rpcParams.Add("evalMessage", new &#123; Message = message &#125;); return ServiceLocator.GetService&lt;IServiceProxyProvider&gt;() .Invoke&lt;bool&gt;(rpcParams, NotifyApi, "MessageNotify"); &#125;&#125;]]></content>
      <categories>
        <category>微服务</category>
      </categories>
      <tags>
        <tag>微服务</tag>
        <tag>开源框架</tag>
        <tag>Surging</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[微服务框架Surging之事件总线(发布-订阅)]]></title>
    <url>%2Fhexo-blog-deploy%2F2018%2F11%2F06%2F2018-11-surging-publish-subscribe%2F</url>
    <content type="text"><![CDATA[消息中间件Surging服务引擎扩展了基于eventbus的rabbitmq和kafka事件总线，组件可以选择绑定 Normal，Retry(Dead letter)，Fail ，如下图所示: 使用场景流量削峰比较典型的案例是:商品秒杀和抢购, 购买/秒杀是如今很常见的一个应用场景，在高并发的流量访问下可以将用户放入到抢购队列中，购买成功则销毁消息。 最终数据的一致性在大型业务中，系统一般由多个独立的服务组成，在分布式调用时候把消息放入到rabbitmq 队列中，再通过消息的幂等性来解决数据的最终一致性 订单失效处理在购买商品/服务生成订单业务中，会设定支付时间，如果一直未支付，会直接关闭订单，而这个场景可以通过死信队列的来解决 用法 通过surgingsetting.json的配置文件的Surging.Packages节点指定使用的消息中间件的组件包,如果使用的是RabbitMq则指定EventBusRabbitMQModule模块,使用的是EventBusKafkaModule模块,并将相应的组件包安装到应用层。 通过eventBusSettings.json对使用的消息中间件进行配置如果使用的是RabbitMq消息中间件，则配置的案例为: 123456789101112&#123; "EventBusConnection": "$&#123;EventBusConnection&#125;|127.0.0.1", "EventBusUserName": "$&#123;EventBusUserName&#125;|guest", //用户名 "EventBusPassword": "$&#123;EventBusPassword&#125;|guest", //密码 "VirtualHost": "$&#123;VirtualHost&#125;|/", "MessageTTL": "$&#123;MessageTTL&#125;|30000", //消息过期时间，比如过期时间是30分钟就是1800000 "RetryCount": "$&#123;RetryCount&#125;|1", //重试次数，这里设置的延迟队列，只能设置为1 "FailCount": "$&#123;FailCount&#125;|3", //处理失败流程重试次数，如果出现异常，会进行重试 "PrefetchCount": "$&#123;PrefetchCount&#125;|0", //设置均匀分配消费者消息的个数 "BrokerName": "surging_demo", "Port": "$&#123;EventBusPort&#125;|5672"&#125; 如果使用的Kafka消息中间件，则配置的案例为： 123456789&#123; "Servers": "$&#123;EventBusConnection&#125;|127.0.0.1:9092", "MaxQueueBuffering": "$&#123;MaxQueueBuffering&#125;|10", "MaxSocketBlocking": "$&#123;MaxSocketBlocking&#125;|10", "EnableAutoCommit": "$&#123;EnableAutoCommit&#125;|false", "LogConnectionClose": "$&#123;LogConnectionClose&#125;|false", "OffsetReset": "$&#123;OffsetReset&#125;|earliest", "GroupID": "$&#123;EventBusGroupID&#125;|surgingdemo" &#125; 事件处理器是通过继承BaseIntegrationEventHandler或者IIntegrationEventHandler实现的，再通过QueueConsumer特性进行标识 12345678910111213141516171819202122232425262728[QueueConsumer("UserLoginDateChangeHandler",QueueConsumerMode.Normal)] public class UserLoginDateChangeHandler : BaseIntegrationEventHandler&lt;UserEvent&gt; &#123; private readonly IUserService _userService; public UserLoginDateChangeHandler() &#123; _userService = ServiceLocator.GetService&lt;IUserService&gt;("User"); &#125; public override async Task Handle(UserEvent @event) &#123; Console.WriteLine($"消费1。"); await _userService.Update(@event.UserId, new UserModel() &#123; Age = @event.Age, Name = @event.Name, UserId = @event.UserId &#125;); Console.WriteLine($"消费1失败。"); throw new Exception(); &#125; public override Task Handled(EventContext context) &#123; Console.WriteLine($"调用&#123;context.Count&#125;次。类型:&#123;context.Type&#125;"); var model = context.Content as UserEvent; return Task.CompletedTask; &#125; &#125; 消息时通过事件总线IEventBus 的 Publish方法发布的。 1234public void Publish(IntegrationEvent @event)&#123; GetService&lt;IEventBus&gt;().Publish(@event);&#125;]]></content>
      <categories>
        <category>微服务</category>
      </categories>
      <tags>
        <tag>微服务</tag>
        <tag>开源框架</tag>
        <tag>Surging</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[微服务框架Surging之请求响应通信]]></title>
    <url>%2Fhexo-blog-deploy%2F2018%2F11%2F06%2F2018-11-surging-request-response%2F</url>
    <content type="text"><![CDATA[微服务集群内部最主要的通信方式，应对微服务之间的绝大多数通信场景。该通信模式主要是采用基于netty的（IPC）进程通信，是基于请求/异步响应的IPC机制。Netty是一个非常优秀的通信框架,其用法和架构设计可参考Netty 实战(精髓) 。 服务之间的调用方式主要有两种方式： 通过接口代理方式 基于routepath的RPC远程调用 接口代理方式适用场景微服务之间有强的依赖关系。例如：微服务组件A强依赖微服务B,那么，微服务组件A是可以通过引用微服务组件B的应用接口层，通过服务代理工厂IServiceProxyFactory创建微服务组件B的业务接口的代理，通过代理对象直接调用微服务组件B的业务方法。 优缺点优点 用法简单、直接；通过接口代理访问与一般的调用方法一致。 缺点 微服务组件有着强耦合的关系，不满足高内聚、低耦合的编程原则。如果微服务之间有强的依赖关系，建议采用该种通信方式，否则建议使用RPC录用调用的方式进行通信。 WS服务不支持通过接口创建代理远程调用 用法 在A服务组件中引用B服务组件的应用接口层。 在构建微服务主机时显示声明使用代理方法。 123456789101112var host = new ServiceHostBuilder() .RegisterServices(builder =&gt; &#123; builder.AddMicroService(option =&gt; &#123; option // 其他方法略 .AddClientProxy() builder.Register(p =&gt; new CPlatformContainer(ServiceLocator.Current)); &#125;); &#125;) .UseProxy() // 其他方法略 .Build(); 通过服务代理工厂创建B服务组件的业务接口 12345678// 调用天气保障服务评估当前天气是否可放行 var weatherEvalProxy = GetService&lt;IServiceProxyFactory&gt;() .CreateProxy&lt;IWeatherEvalApplication&gt;(); var weatherResult = await weatherEvalProxy.WeatherEval(new FlightInfoInput() &#123; FlightDate = flightInfo.FlightDate, FlightId = flightInfo.FlightId &#125;); 基于routepath的RPC远程调用适用场景微服务组件A与微服务组件B之间的关系是并列的，例如：两个不同业务模块之间的微服务组件之间的通信，建议采用该种方式进行通信。 优缺点优点 服务与服务之间没有引用关系，不产生耦合性。 构造微服务主机时无需声明使用代理类。 缺点 需要自己构建参数，用法较麻烦。 无法指定返回的数据类型，默认返回的是object类型，建议使用dynamic作为返回结果。 用法 使用字典类构建请求参数Dictionary&lt;string, object&gt;,请求参数的名称必须与应用接口的名称一致。 通过服务代理提供者IServiceProxyProvider调用接口，传入请求参数和接口的路由地址。 123456var requestParams = new Dictionary&lt;string, object&gt;() &#123; &#123; "input", new &#123; flightDate = flightInfo.FlightDate, flightId = flightInfo.FlightId &#125; &#125; &#125;;var weatherResult = await GetService&lt;IServiceProxyProvider&gt;().Invoke&lt;bool&gt;(requestParams, "v1/weathereval//weathereval"); Notes 实际编码过程中，应当避免硬编码,每个服务组件调用的接口地址都应当维护到一个静态类中,请参考。]]></content>
      <categories>
        <category>微服务</category>
      </categories>
      <tags>
        <tag>微服务</tag>
        <tag>开源框架</tag>
        <tag>Surging</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[微服务框架Surging之编写业务代码]]></title>
    <url>%2Fhexo-blog-deploy%2F2018%2F11%2F05%2F2018-11-surging-business-coding%2F</url>
    <content type="text"><![CDATA[本节主要描述了如何编写业务代码，当前，每个微服务组件主要通过领域设计分层设计,下面的每个小节都给出了每一层的目录结构，建议开发过程中严格按照给定的目录结构进行编写业务代码。特别是对领域设计不是很熟悉的情况下，对快速上手开发是很有帮助的。领域设计秉承了高内聚、低耦合的原则。特别不建议在不熟悉领域设计的情况下，对目录结构进行创新。否则，后期项目将会变得非常混乱，且难以维护。 应用层接口层在定义服务接口之前，我们需要安装Surging.Core.CPlatform组件包。 定义服务一般情况下,编写某一个业务模块的Api时,我们需要在应用接口层定义一个接口,该接口继承自IServiceKey，并通过ServiceBundle特性来标识该服务的路由模板(类似MVC中的特性路由)。例如: 12345[ServiceBundle("v1/demo/&#123;service&#125;")]public interface IDemoApplication : IServiceKey&#123; &#125; 定义命令在定义服务之后，就需要在服务内部定义命令，每一个命令就是一个接口方法。服务与命令的关系就类似与MVC框架中的Controller和Action。 所有命令都应当是异步的。可以通过CommandAttribute对命令进行注解,从而影响命令在运行时的行为，如果不对命令进行注解,那么运行时解析命令将会以缺省值进行标记。 命令的声明如下所示: 12[Command(Strategy = StrategyType.Injection, ShuntStrategy = AddressSelectorMode.HashAlgorithm, ExecutionTimeoutInMilliseconds = 2500, BreakerRequestVolumeThreshold = 3, Injection = @"return 1;", RequestCacheEnabled = false)]Task&lt;string&gt; SayHello(string name); CommandAttribute配置相关参数列表: 参数 作用 备注 FailoverCluster 故障转移次数 默认为3次 CircuitBreakerForceOpen 是否强制开启熔断 默认为false Strategy 容错策略 系统提供三种容错策略: 1.Failover, 失败切换远程服务机制 2. Injection,失败执行注入脚本(通过Injection属性注入) 3. FallBack,失败执行指定回调方法，指定的方法必须要集成自IFallbackInvoker接口 ExecutionTimeoutInMilliseconds 执行超时时间 默认值：1000 RequestCacheEnabled 是否开启缓存 默认关闭 Injection 脚本注入 InjectionNamespaces 注入命名空间 称为程序集名称更恰当 BreakeErrorThresholdPercentage 错误率达到多少开启熔断保护 默认值：50 BreakeSleepWindowInMilliseconds 熔断多少秒后去尝试请求 默认值：60000 BreakerForceClosed 是否强制关闭熔断 BreakerRequestVolumeThreshold 10秒钟内至少多少请求失败，熔断器才发挥起作用 默认值：20 MaxConcurrentRequests 最大并发数 10 DTO对象DTO对象英文名称为: Data Transfer Object,中文名为:数据传输对象。那么，为什么要使用DTO对象呢?,简而言之，DTO对象不同于领域层的中实体(Entity)和值对象(Model),领域层中的实体对象和值对象是面向业务的，而DTO对象是面向UI的。另外，我们将DTO对象定义在应用接口层是因为，如果微服务组件之间有强的依赖关系，这个时候我们可以通过接口代理的方式访问其他微服务组件，将DTO对象定义在应用接口层而不是应用层是为了方便引用DTO对象。 一般而言,DTO对象可以加动词前缀和形容词后缀,例如: GetXxxxOutput、QueryXxxxInput、XxxxDto等均为合法的DTO命名规范。 应用接口层的项目结构一个理想的应用层接口的目录结构应当如下所示: 123456|-- ModuleName|-- |-- IModuleApplication.cs|-- |-- Dto|------ |-- GetModuleOutput.cs|------ |-- CreateModuleInput.cs|------ |-- ModuleDto.cs 应用层应用层是对应用接口层定义的接口进行实现的，是一层很薄的一层，只应当包含工作流控制逻辑，不包含业务逻辑。 一般地，微服务之间的通信只应当发生在该层,如果微服务之间具有强的依赖关系，例如A服务组件强依赖B服务，那么A服务可以引用B服务的应用接口层，并且可以通过接口代理的方式访问B服务组件的接口。如果服务与服务之间并没有依赖关系的话，那么服务之间的通信就应当采用RPC的方式进行通信。关于微服务之间的通信请参考通信一节 如果需要使用接口代理的方式访问其他微服务组件接口，那么在应用层需要安装Surging.Core.ProxyGenerator组件包，并且需要在构建微服务主机的时候指明使用代理,请参考构建微服务主机一节；如果只需要通过RPC代理的方式访问其他微服务组件接口，那么在应用层只需要安装Surging.Core.CPlatform组件包。 一般的，应用类需要继承ProxyServiceBase基类。如果应用是提供的基于WebSocket服务的话,那么应用层需要安装Surging.Core.Protocol.WS组件包,并且应用类需要继承的是WSServiceBase基类,且对应的命令的负载均衡算法必须显示的标注为哈希算法,且第一个参数必须为string类型(原因: Ws服务通过第一个参数进行hash的)。例如: 123456/// &lt;summary&gt;/// 数字化放行评估过程中的消息/// &lt;/summary&gt;/// &lt;returns&gt;&lt;/returns&gt;[Command(ShuntStrategy = AddressSelectorMode.HashAlgorithm)]Task&lt;bool&gt; EvalMessage(string key,EvalMessage evalMessage); 除此之外,ws服务之间的调用只能通过基于routepath远程(RPC调用)调用，不支持通过接口创建代理远程调用。 特别要注意的是:千万不要在应用层加入业务逻辑，应用层应当只包括工作流程控制逻辑，如果涉及业务逻辑，那么应当分析是否是该微服务领域内的业务，如果是，业务实现逻辑应当在该微服务组件的领域层，如果不是，应当调用其他微服务组件的接口，通过接口访问执行相关业务或获取相关业务数据。换句话说，应用层关注的仅仅是:第一步做什么，第二步做什么,而不关心应该怎么做;该怎么做，如何做，应当是领域层关心的事。如果是做简单的查询，不包含任何的业务逻辑，请直接通过实体或聚合根的仓储类查询数据。 除此之外，应用层往往还需要一个单独的静态类用于定义引用到其他微服务组件的接口名称。 一般情况下，应用层的目录结构如下所示:123|-- ModuleName|---- |-- ModuleApplication.cs|-- WebApiConfig.cs 领域层领域层是具体的业务实现的一层，关注的是业务功能的实现。领域层应当根据业务模块进行建模,更多领域知识，请参考汤雪华博客:DDD理论积累 领域层需要安装Surging.Core.CPlatform组件包。领域层需要注意的是，需要定义一个模块类,将定义的对象注入到相关的Ioc容器中，并且在surgingsetting.json中显示配置引用该模块。例如:模块类定义为:1234567891011121314151617public class OperationRestrictionDomainModule : BusinessModule&#123; protected override void RegisterBuilder(ContainerBuilderWrapper builder) &#123; // 该部分待重构,真实项目中通过标识接口实现自动注册 builder.RegisterType&lt;FlightInfoRepository&gt;() .As&lt;IRepository&lt;FlightInfoEntity&gt;&gt;() .AsSelf() .InstancePerDependency(); builder.RegisterType&lt;FlightInfoManager&gt;() .As&lt;IFlightInfoManager&gt;() .InstancePerDependency(); builder.RegisterType&lt;OperationRestricEvalManager&gt;() .As&lt;IOperationRestricEvalManager&gt;() .InstancePerDependency(); &#125;&#125; 主机服务中需要设置:12345678910"Packages": [ &#123; "TypeName": "EnginePartModule", "Using": "$&#123;UseEngineParts&#125;|DotNettyModule;NLogModule;ConsulModule;WSProtocolModule;EventBusRabbitMQModule;CachingModule;KestrelHttpModule" &#125;, &#123; "TypeName": "BusinessModule", "Using": "OperationRestrictionDomainModule;DemoCoreModule;" &#125;] Notes 该部分后期会优化, 领域层的组件注册设计为通过继承标识接口ITransientDependency和ISingletonDependency来自动注入到Ioc容器中。 一般地，领域层的目录结构可能如下所示(领域对象采用贫血模式):1234567891011121314151617|-- ModuleName|---- |-- IModuleManager.cs|---- |-- ModuleManager.cs|---- |-- XxxPolicy.cs|---- |-- OtherBusinessClass.cs // 代表其他业务类代码,例如：某个模块采用了命令模式,该部分可以看做是Commands的集合|---- |-- Entities|---- |----- |---- Xxx1Aggregate.cs // 每一个模块仅有只有仅有一个聚合根，但可以有多个实体对象，多个值对象|---- |----- |---- Xxx1Repository.cs|---- |----- |---- Xxx2Entity.cs|---- |----- |---- Xxx2Repository.cs|---- |----- |---- Xxx3Entity.cs|---- |----- |---- Xxx3Repository.cs|---- |-- ValueObjects|---- |----- |---- XxxModel.cs|---- |----- |---- XxxValueObject.cs|---- |----- |---- XxxEnum.cs|-- ModuleNameModule.cs Notes 一般情况下，如果封装的好，在ModuleManager对象中直接引用仓储的泛型接口,除非对仓储进行扩展，否则并不需要定义仓储类。 ModuleManager是该领域内的具体的业务实现的执行者。 一般的，Entities目录下定义聚合根，实体对象，ValueObjects目录下定义值对象、枚举值等 公共的领域层一个解决方案(业务模块)，有可能需要抽象出一个公共的领域层，用于处理该业务模块的公共业务。例如: 事件处理、消息代理、服务代理等等。除此之外，我们还会定义一个公共的基础实施层、和公共的model层。 运行项目在运行项目之前，必须保证运行环境已经提供了服务注册中心(Consul或Zookeeper)，消息中间件(RabbitMq或Kafka)，以及缓存中间件。一般地，如果不同团队之间需要联调微服务，应当在局域网内部部署相应的服务或中间件；而在独立开发的场景下，建议采用docker-compose编排微服务。]]></content>
      <categories>
        <category>微服务</category>
      </categories>
      <tags>
        <tag>微服务</tag>
        <tag>Surging</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[微服务框架Surging之编排微服务]]></title>
    <url>%2Fhexo-blog-deploy%2F2018%2F11%2F05%2F2018-11-surging-orchestration-microservice%2F</url>
    <content type="text"><![CDATA[编排微服务使用docker-compose 编排微服务，可以简化开发环境的搭建，方便开发调试与docker镜像的构建与持续集成。但是在开发过程中，并不是必须使用docker-compose进行微服务的编排。 不使用docker-compose编排微服务如果不使用docker-compose编排微服务，那么要求在开始运行微服务主机之前，运行环境必须提供consul服务和rabbitmq、redis中间件。其中，consul作为服务注册中心；rabbitmq作为事件总线的消息中间件;redis作为缓存中间件。当然，作为注册中心的consul也可以使用zookeeper替换，rabbitmq也可以使用kafka替换。 如果在开发过程中，团队需要对微服务进行联调，那么consul和rabbitmq必须部署在一台可访问的内部服务器。在开发和测试环境中可以搭建单个节点的服务提供开发和测试，但是为提高consul、rabbitmq的可用性，在生成环境中要求consul、rabbitmq必须搭建集群。consul的使用和部署请参考consul使用手册,rabbitmq的集群部署请参考搭建 RabbitMQ Server 高可用集群。如果是单人进行开发或测试，可以consul、rabbitmq安装到本地环境，或使用docker-compose进行编排。 使用docker-compose编排微服务如果开发者在进行某个模块的业务开发，而在该模块下存在多个微服务组件，在该场景下，建议使用docker-compose编排微服务。使用docker-compose编排微服务的好处在于将开发环境使用到服务或中间件都可以编排到微服务集群中，以减少对开发环境的部署和调试的时间。例如：我们完全可以将使用到consul服务和rabbitmq、redis中间件等通过docker-compose编排到微服务组件的集群中。但是如果调试不同模块之间的微服务组件，则无法采用该种模式，因为微服务集群必须要有统一的服务注册中心。 关于docker-compose的编写请参考官方文档。 一般地，使用docker-compose编排微服务我们通过如下步骤来实现： 建立docker-compose.dcproj 项目文件,并在 &lt;/ItemGroup&gt;节点中指定要引用的docker-compose 编排文件 1234567891011121314151617&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;Project ToolsVersion="15.0" Sdk="Microsoft.Docker.Sdk"&gt; &lt;PropertyGroup Label="Globals"&gt; &lt;ProjectGuid&gt;fea0c318-ffed-4d39-8781-265718ca43dd&lt;/ProjectGuid&gt; &lt;DockerTargetOS&gt;Linux&lt;/DockerTargetOS&gt; &lt;ProjectVersion&gt;2.1&lt;/ProjectVersion&gt; &lt;DockerLaunchAction&gt;LaunchBrowser&lt;/DockerLaunchAction&gt; &lt;/PropertyGroup&gt; &lt;ItemGroup&gt; &lt;None Include=".dockerignore" /&gt; &lt;None Include="docker-compose.override.yml"&gt; &lt;DependentUpon&gt;docker-compose.yml&lt;/DependentUpon&gt; &lt;/None&gt; &lt;None Include="docker-compose.yml" /&gt; &lt;/ItemGroup&gt;&lt;/Project&gt; 编写docker-compose.yml编排文件,一般地，该文件仅定义集群中各个微服务组件所使用的镜像，以及微服务组件构建的上下文,所使用到的环境变量一般在docker-compose.override.yml中定义。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788version: '3.4'services: consul: image: consul:latest networks: - surging_demo redis: image: bitnami/redis:latest networks: - surging_demo rabbitmq: image: rabbitmq:management networks: - surging_demo dgitalreleaseeval: image: surgingdemo/dgitalreleaseeval:$&#123;TAG:-latest&#125; build: context: . dockerfile: Sample/Services/DigitalReleaseEval/Surging.Demo.DigitalReleaseEvalHost/Dockerfile networks: - surging_demo depends_on: - consul - redis - rabbitmq - airportguaranteeeval - meteorologicaleval - operationrestrictioneval surgingserver_ws: image: surgingdemo/surgingserver_ws:$&#123;TAG:-latest&#125; build: context: . dockerfile: Sample/Services/WebSocketServer/Surging.Demo.WebSocketHost/Dockerfile networks: - surging_demo depends_on: - consul - redis - rabbitmq airportguaranteeeval: image: surgingdemo/airportguaranteeeval:$&#123;TAG:-latest&#125; build: context: . dockerfile: Sample/Services/AirportGuaranteeEval/Surging.Demo.AirportGuaranteeEvalHost/Dockerfile networks: - surging_demo depends_on: - consul - redis - rabbitmq - meteorologicaleval meteorologicaleval: image: surgingdemo/meteorologicaleval:$&#123;TAG:-latest&#125; build: context: . dockerfile: Sample/Services/MeteorologicalEval/Surging.Demo.MeteorologicalEvalHost/Dockerfile networks: - surging_demo depends_on: - consul - redis - rabbitmq operationrestrictioneval: image: surgingdemo/operationrestrictioneval:$&#123;TAG:-latest&#125; build: context: . dockerfile: Sample/Services/OperationRestrictionEval/Surging.Demo.OperationRestrictionEvalHost/Dockerfile networks: - surging_demo depends_on: - consul - redis - rabbitmqnetworks: surging_demo: driver: bridge ipam: driver: default config: - subnet: 172.18.0.1/16 定义docker-compose.override.yml，对集群中所使用到的各个组件所使用到的环境变量、卷、端口映射等进行定义，其中，默认的环境变量可以在.evn中的设置覆盖。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697version: '3.4'services: consul: ports: - "18400:8400" - "18500:8500" - "18600:8600" - "18600:8600/udp" command: "agent -server -bootstrap-expect 1 -ui -client 0.0.0.0" redis: ports: - "16379:6379" rabbitmq: environment: RABBITMQ_ERLANG_COOKIE: "SWQOKODSQALRPCLNMEQG" RABBITMQ_DEFAULT_USER: "rabbitmq" RABBITMQ_DEFAULT_PASS: "rabbitmq" RABBITMQ_DEFAULT_VHOST: "/" ports: - "15673:15672" - "5673:5672" dgitalreleaseeval: environment: Surging_Server_Address: $&#123;DGITALRELASE_Surging_SERVER_ADDRESS:-dgitalreleaseeval&#125; Register_Conn: $&#123;REGISTER_CONN:-consul:8500&#125; Register_SessionTimeout: $&#123;REGISTER_SESSION_TIMEOUT:-50&#125; UseEngineParts: "DotNettyModule;NLogModule;ConsulModule;EventBusRabbitMQModule;CachingModule;KestrelHttpModule" EventBusConnection: $&#123;RABBITMQ_CONNECTION:-rabbitmq&#125; EventBusUserName: $&#123;RABBITMQ_USERNAME:-rabbitmq&#125; EventBusPassword: $&#123;RABBITMQ_PASSWORD:-rabbitmq&#125; EventBusPort: $&#123;RABBITMQ_PORT:-5672&#125;# volumes:# - $&#123;DIGITALRELEASE_SERVER_LOG_DIR:-./logs/d&#125;:/app/logs ports: - "101:100" - "8081:8080" surgingserver_ws: environment: Surging_Server_Address: $&#123;DGITALRELASEWS_Surging_SERVER_ADDRESS:-surgingserver_ws&#125; Register_Conn: $&#123;REGISTER_CONN:-consul:8500&#125; Register_SessionTimeout: $&#123;REGISTER_SESSION_TIMEOUT:-50&#125; UseEngineParts: "DotNettyModule;NLogModule;ConsulModule;EventBusRabbitMQModule;CachingModule;WSProtocolModule" EventBusConnection: $&#123;RABBITMQ_CONNECTION:-rabbitmq&#125; EventBusUserName: $&#123;RABBITMQ_USERNAME:-rabbitmq&#125; EventBusPassword: $&#123;RABBITMQ_PASSWORD:-rabbitmq&#125; EventBusPort: $&#123;RABBITMQ_PORT:-5672&#125;# volumes:# - $&#123;DIGITALRELEASE_WSSERVER_LOG_DIR:-./logs/d_ws&#125;:/app/logs ports: - "102:100" - "96:96" airportguaranteeeval: environment: Surging_Server_Address: $&#123;AIRPORTGUARANTE_Surging_SERVER_ADDRESS:-airportguaranteeeval&#125; Register_Conn: $&#123;REGISTER_CONN:-consul:8500&#125; Register_SessionTimeout: $&#123;REGISTER_SESSION_TIMEOUT:-50&#125; EventBusConnection: $&#123;RABBITMQ_CONNECTION:-rabbitmq&#125; EventBusUserName: $&#123;RABBITMQ_USERNAME:-rabbitmq&#125; EventBusPassword: $&#123;RABBITMQ_PASSWORD:-rabbitmq&#125; EventBusPort: $&#123;RABBITMQ_PORT:-5672&#125;# volumes:# - $&#123;AIRPORTGUARANTEE_SERVER_LOG_DIR:-./logs/a&#125;:/app/logs ports: - "103:100" - "8082:8080" meteorologicaleval: environment: Surging_Server_Address: $&#123;METEOROGICAL_Surging_SERVER_ADDRESS:-meteorologicaleval&#125; Register_Conn: $&#123;REGISTER_CONN:-consul:8500&#125; Register_SessionTimeout: $&#123;REGISTER_SESSION_TIMEOUT:-50&#125; EventBusConnection: $&#123;RABBITMQ_CONNECTION:-rabbitmq&#125; EventBusUserName: $&#123;RABBITMQ_USERNAME:-rabbitmq&#125; EventBusPassword: $&#123;RABBITMQ_PASSWORD:-rabbitmq&#125; EventBusPort: $&#123;RABBITMQ_PORT:-5672&#125;# volumes:# - $&#123;METEOROLOGICCAL_SERVER_LOG_DIR:-./logs/m&#125;:/app/logs ports: - "104:100" - "8083:8080" operationrestrictioneval: environment: Surging_Server_Address: $&#123;OPERTIONRESTRICTION_Surging_SERVER_ADDRESS:-operationrestrictioneval&#125; Register_Conn: $&#123;REGISTER_CONN:-consul:8500&#125; Register_SessionTimeout: $&#123;REGISTER_SESSION_TIMEOUT:-50&#125; EventBusConnection: $&#123;RABBITMQ_CONNECTION:-rabbitmq&#125; EventBusUserName: $&#123;RABBITMQ_USERNAME:-rabbitmq&#125; EventBusPassword: $&#123;RABBITMQ_PASSWORD:-rabbitmq&#125; EventBusPort: $&#123;RABBITMQ_PORT:-5672&#125;# volumes:# - $&#123;OPERATIONRESTRICTION_SERVER_LOG_DIR:-./logs/o&#125;:/app/logs ports: - "105:100" - "8084:8080"]]></content>
      <categories>
        <category>微服务</category>
      </categories>
      <tags>
        <tag>微服务</tag>
        <tag>开源框架</tag>
        <tag>Surging</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[微服务框架Surging之创建微服务项目]]></title>
    <url>%2Fhexo-blog-deploy%2F2018%2F11%2F05%2F2018-11-surging-setup-microservice%2F</url>
    <content type="text"><![CDATA[建立微服务项目一般地，我们通过DDD领域设计来构建一个微服务组件。在开发过程中，我们可以单独为某个微服务组件建立解决方案，针对某个微服务进行独立的开发;但是更多的场景是将多个互相依赖的微服务建立为同一个解决方案，然后通过docker-compose进行编排微服务，方便业务开发和调试。 当然，除此之外，也可以通过普通的三层或是CQRS模式来构建微服务,这里不展开讨论。 建立微服务项目(组件)根据领域设计架构模型，我们一般将微服务组件分为如下四层: Host Layer: 主机服务层, 该层主要是用于寄宿(托管)微服务主机,在该层构建、配置和微服务微服务主机本身。 IApplication Layer：应用接口层， 该层主要定义微服务组件的服务和命令(概念类似于MVC中的Controller和Action的概念),并通过特性来标识服务与命令的相关属性(更多知识点，请参考配置)。除此之外,每个服务对应的DTO对象，也在该层定义。 Application Layer: 应用层, 很薄的一层，IApplication的实现层,只包含工作流控制逻辑，不包含业务逻辑。 Domain Layer: 领域层,包含整个应用的所有业务逻辑。 当然，除了上述的四层之外，一般领域设计还可能包含: Infrastructure Layer: 基础设施层, 提供整个应用的基础服务； ORM Layer: 数据访问层, 提供统一的仓储接口和对数据库的访问； 一般地，在一个产品(解决方案)中，我们会将基础设施层和数据访问层抽象出来，每个微服务组件只需要关注微服务自身的业务。除此之外，一个产品(解决方案)中,还会抽象出: 公共的业务组件(相当于公共的领域层): 用于封装产品的通用业务。 公共的Model组件: 用于封装通用的值对象、枚举等。 一个通用的产品的解决方案结构应当如下图所示,其中,Services目录下为该解决方案(产品)的所有微服务组件: 如果一个微服务组件作为一个单一的项目在开发，只需要定义 1~4 层即可,我们通过 Nuget 服务来安装使用到的组件包,换句话说，每个微服务只需要关注微服务自身的业务，而不需要关注除了本身之外的知识点,每个微服务组件的开发都应当满足：高内聚、低耦合的编程理念。 一般情况下，在开发过程中，往往一个大的产品可能会被分解为多个模块进行开发，相应的，一个模块会对应着一个解决方案，在这个解决方案内部定义了该模块的微服务组件，往往这些微服务组件具有较强的依赖关系，配合着完成该模块的业务，在这种场景下，微服务之间的通信建议采用通过接口代理的方式进行通信;而不同的模块之间的微服务之间通信，往往采用RPC的方式进行通信。更多内容,请参考微服务通信方式一节。 单个微服务组件的项目结构: Notes: 在开发过程中,我们应当把用于websocket通知的服务组件单独抽象出来。 构建微服务主机在建立完项目后，下一步并开始着手构建微服务主机。Surging使用ServiceHostBuilder构建微服务主机, 在微服务主机构建完成后，执行 Run()方法。下面通过实例来描述如何构建微服务主机: 安装Surging组件包在安装Surging组件包之前，首先需要配置内网的Nuget服务,内网的Nuget仓储地址为: http://192.168.0.202/nuget。 一般情况下，以下组件包是必须安装的：Surging.Core.CPlatform、Surging.Core.Common、Surging.Core.DotNetty、Surging.Core.Caching; 如果选择Consul作为服务注册中心,需要安装: Surging.Core.Consul组件包; 如果选择Zookeeper作为服务注册中心,则需要安装: Surging.Core.Zookeeper组件包; 如果选择NLog作为日志记录组件，需要安装: Surging.Core.NLog组件包,如果选择log4net作为日志记录组件,则需要安装: Surging.Core.Log4net组件; 如果微服务组件需要对外提供Http服务，则需要安装Surging.Core.KestrelHttpServer组件包。一般情况下，如果微服务组件提供Http服务，则需要通过Swagger生成在线API文档，需要安装Surging.Core.Swagger组件包。 如果微服务主机作为 WebSocket服务主机，则需要安装Surging.Core.Protocol.WS组件包。 编码器的选择: Surging默认使用Json格式作为消息序列化格式,性能无法达到最优,所以Surging提供了Surging.Core.Codec.MessagePack和Surging.Core.Codec.ProtoBuffer组件包作为消息序列化的编解码器,以提高性能，可以根据实际情况选择合适的消息编解码器。 编写配置文件Surging架构采用Json格式编写配置文件，配置文件可以分为如下几类： Surging平台配置文件:surgingSettings.json, 主要针对微服务主机自身的Ip、端口号、通信采用的协议、加载的模块，以及Swagger文档，日志输出级别进行配置。 服务注册中心配置文件: consul.json或zookeeper.json，主要针对微服务的注册中心进行配置。 消息中间件配置文件: eventBusSettings.json，针对微服务内部之间采用事件总线的中间件进行配置。 缓存中间件配置文件: cacheSettings.json，针对微服务采用的缓存中间件进行配置。 日志配置文件: NLog.config或log4net.config，日志配置文件按NLog 或 log4net组件的要求进行配置即可。 配置文件的模板可以通过Surging的案例进行拷贝,针对微服务配置的相关知识，请参考配置一节。 微服务主机类型微服务主机的构建过程基本差不多，只是因为加载的模块不同(通过surgingSettings.json配置文档中的Packages节点)具有提供不同服务的能力，我们可以将微服务分为如下几种类型: 业务微服务主机： 该类型的微服务主机不对外提供服务，只针对微服务内部集群提供服务,只要微服务主机注册到服务中心后,其他微服务主机可以通过接口代理或是RPC远程调用该主机的提供的接口。 对外提供Http服务的微服务主机: 对客户端提供Http访问的能力,与第一类主机基本一致,只需要针对配置surgingSettings.json配置Ports.HttpPort端口号,并且在Packages节点下的EnginePartModule增加对KestrelHttpModule引用,如果需要生产Swagger文档,则需要安装Surging.Core.Swagger组件,并在surgingSettings.json中对Swagger节点进行配置。 WebSocket服务的微服务主机: 针对客户端提供websocket服务,该类型的主机在构建过程与第一类主机一致,但是必须要安装Surging.Core.Protocol.WS组件包，并且需要针对配置surgingSettings.json配置Ports.WSPort端口号，并且在Packages节点下的EnginePartModule增加对WSProtocolModule引用,需要注意的是： 实现服务接口时,应用层需要继承的基类是WSServiceBase; 与ws服务之间的调用只能通过RPC的方式调用，不支持通过接口创建代理远程调用; 定时任务调度的微服务主机: 暂未实现 构建微服务主机的代码如下: 1234567891011121314151617181920212223242526272829303132333435363738var host = new ServiceHostBuilder() .RegisterServices(builder =&gt; &#123; // 注册服务 builder.AddMicroService(option =&gt; &#123; // 增加微服务 option.AddServiceRuntime() // 增加服务运行时必要的组件 .AddRelateServiceRuntime() // 增加关联服务运行时必要的组件,如健康检查组件、地址选择器、远程调用服务组件等等 .AddClientProxy() // 如果需要支持通过接口代理进行其他微服务,则必须添加 .AddServiceEngine(typeof(SurgingServiceEngine));// 指定服务引擎,用于解析微服务的服务与命令 builder.Register(p =&gt; new CPlatformContainer(ServiceLocator.Current)); &#125;); &#125;) .ConfigureLogging(loggging =&gt; &#123; loggging.AddConfiguration( AppConfig.GetSection("Logging")); &#125;) // .UseNLog("NLog.config") // 指定日志中间件，可以不显示指明,直接在surgingSettings中进行配置日志组件即可 .UseServer(options =&gt; &#123; &#125;) .UseConsoleLifetime() // 指定控制台输出日志 .Configure(build =&gt; &#123; // 指定配置文件 build.AddCacheFile("$&#123;cachepath&#125;|Configs/cacheSettings.json", optional: false, reloadOnChange: true); build.AddCPlatformFile("$&#123;surgingpath&#125;|Configs/surgingSettings.json", optional: false, reloadOnChange: true); build.AddEventBusFile("Configs/eventBusSettings.json", optional: false); build.AddConsulFile("Configs/consul.json", optional: false, reloadOnChange: true); &#125;) .UseProxy() // 声明可以使用接口代理方式访问服务 .UseStartup&lt;Startup&gt;() //指定启动类 .Build(); //构建微服务主机 using (host.Run()) &#123; Console.WriteLine($"服务端启动成功，&#123;DateTime.Now&#125;。"); &#125; 在构建过程中，需要指定SurgingServiceEngine用于解析服务组件,Surging采用Sidecar模式设计,如果未显示的引用应用组件,微服务可以通过服务引擎在指定的目录下扫描相应的dll，从而解析到相应的服务与命令。 必须指定Startup类。 需要注意的是注意Configs目录的大小写,Windows系统对目录的大小写不敏感,而Linux系统对大小写是敏感的。 编写Dockerfile如果需要使用docker-compose或k8s来编排微服务，则必须要构建微服务的镜像,可以通过如下脚本来构建微服务组件的Docker镜像。 123456789101112131415161718192021FROM microsoft/dotnet:2.1-runtime AS baseWORKDIR /appARG rpc_port=100ARG http_port=8080ARG ws_port=96EXPOSE $&#123;rpc_port&#125; $&#123;http_port&#125; $&#123;ws_port&#125;FROM microsoft/dotnet:2.1-sdk AS buildWORKDIR /srcCOPY . .WORKDIR &lt;micro_service_project_path&gt;RUN dotnet restore &amp;&amp; \ dotnet build --no-restore -c Release -o /appFROM build AS publishRUN dotnet publish --no-restore -c Release -o /appFROM base AS finalWORKDIR /appCOPY --from=publish /app .ENTRYPOINT ["dotnet", "&lt;micro_service_name.dll&gt;"]]]></content>
      <categories>
        <category>微服务</category>
      </categories>
      <tags>
        <tag>微服务</tag>
        <tag>开源框架</tag>
        <tag>Surging</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[设计模式之外观模式]]></title>
    <url>%2Fhexo-blog-deploy%2F2018%2F11%2F04%2F2018-11-design-pattern-facade-pattern-note%2F</url>
    <content type="text"><![CDATA[简介外观模式（Facade Pattern）,又称作门面模式，隐藏系统的复杂性，并向客户端提供了一个客户端可以访问系统的接口。这种类型的设计模式属于结构型模式，它向现有的系统添加一个接口，来隐藏系统的复杂性。Facade设计模式更注重从架构的层次去看整个系统，而不是单个类的层次。Facade很多时候更是一种架构设计模式。这种模式涉及到一个单一的类，该类提供了客户端请求的简化方法和对现有系统类方法的委托调用。 动机在软件系统开发的过程中，当组件的客户（即外部接口，或客户程序）和组件中各种复杂的子系统有了过多的耦合，随着外部客户程序和各子系统的演化，这种过多的耦合面临很多变化的挑战。如何简化外部客户程序和系统间的交互接口？如何将外部客户程序的演化和内部子系统的变化之间的依赖相互解耦？ 意图为子系统中的一组接口提供一个一致的界面，Facade模式定义了一个高层接口，这个接口使得这一子系统更加容易使用。 结构图 角色 外观角色（Facade）：在客户端可以调用它的方法，在外观角色中可以知道相关的（一个或者多个）子系统的功能和责任；在正常情况下，它将所有从客户端发来的请求委派到相应的子系统去，传递给相应的子系统对象处理。 子系统角色（SubSystem）：在软件系统中可以有一个或者多个子系统角色，每一个子系统可以不是一个单独的类，而是一个类的集合，它实现子系统的功能；每一个子系统都可以被客户端直接调用，或者被外观角色调用，它处理由外观类传过来的请求；子系统并不知道外观的存在，对于子系统而言，外观角色仅仅是另外一个客户端而已。 实现12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970namespace 外观模式的实现&#123; /// &lt;summary&gt; /// 不使用外观模式的情况 /// 此时客户端与三个子系统都发送了耦合，使得客户端程序依赖与子系统 /// 为了解决这样的问题，我们可以使用外观模式来为所有子系统设计一个统一的接口 /// 客户端只需要调用外观类中的方法就可以了，简化了客户端的操作 /// 从而让客户和子系统之间避免了紧耦合 /// &lt;/summary&gt; class Client &#123; static void Main(string[] args) &#123; var facade=new SystemFacade(); facade.Buy(); Console.Read(); &#125; &#125; // 身份认证子系统A public class AuthoriationSystemA &#123; public void MethodA() &#123; Console.WriteLine("执行身份认证"); &#125; &#125; // 系统安全子系统B public class SecuritySystemB &#123; public void MethodB() &#123; Console.WriteLine("执行系统安全检查"); &#125; &#125; // 网银安全子系统C public class NetBankSystemC &#123; public void MethodC() &#123; Console.WriteLine("执行网银安全检测"); &#125; &#125; //更高层的Facade public class SystemFacade &#123; private AuthoriationSystemA auth; private SecuritySystemB security; private NetBankSystemC netbank; public SystemFacade() &#123; auth=new AuthoriationSystemA(); security=new SecuritySystemB(); netbank=new NetBankSystemC(); &#125; public void Buy() &#123; auth.MethodA();//身份认证子系统 security.MethodB();//系统安全子系统 netbank.MethodC();//网银安全子系统 Console.WriteLine("我已经成功购买了！"); &#125; &#125;&#125; 实现要点 一个系统可以有几个门面类 在门面模式中，通常只需要一个门面类，并且此门面类只有一个实例，换言之它是一个单例类。当然这并不意味着在整个系统里只有一个门面类，而仅仅是说对每一个子系统只有一个门面类。或者说，如果一个系统有好几个子系统的话，每一个子系统都有一个门面类，整个系统可以有数个门面类。 为子系统增加新行为 初学者往往以为通过继承一个门面类便可在子系统中加入新的行为，这是错误的。 门面模式的用意是为子系统提供一个集中化和简化的沟通管道，而不能向子系统加入新的行为。比如医院中的接待员并不是医护人员，接待员并不能为病人提供医疗服务。 Facade有助于建立层次结构的系统，实现了子系统与客户之间的松耦合关系，子系统内部的功能组件往往是紧耦合的。松耦合关系使得子系统的组件变化不会影响到它的客户。Facade消除了复杂的循环依赖关系。这一点在客户程序与子系统分别实现的时候格外重要。 从客户程序的角度来看，Facade模式不仅简化了整个组件系统的接口，同时对于组件内部与外部客户程序来说，从某种程度上也达到了一种“解耦”的效果——内部子系统的任何变化不会影响到Facade接口的变化。 优缺点优点 外观模式对客户屏蔽了子系统组件，从而简化了接口，减少了客户处理的对象数目并使子系统的使用更加简单。 外观模式实现了子系统与客户之间的松耦合关系，而子系统内部的功能组件是紧耦合的。松耦合使得子系统的组件变化不会影响到它的客户。 缺点 如果增加新的子系统可能需要修改外观类或客户端的源代码，这样就违背了开——闭原则（不过这点也是不可避免）。 使用场景 对外一个复杂的子系统提供一个简单的接口 提供子系统的独立性 在层次化结构中，可以使用外观模式定义系统中每一层的入口。其中三层架构就是这样的一个例子。 模式比较注意区分Facade模式、Adapter模式、Bridge模式与Decorator模式： Facade模式注重简化接口 Adapter模式注重转换接口 Bridge模式注重分离接口（抽象）与其实现 Decorator模式注重稳定接口的前提下为对象扩展功能]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
        <tag>结构型</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[微服务框架Surging之开发环境]]></title>
    <url>%2Fhexo-blog-deploy%2F2018%2F11%2F04%2F2018-11-surging-development-env%2F</url>
    <content type="text"><![CDATA[搭建开发环境安装开发工具–VS2017使用 visio studio 2017作为开发者工具，在安装vs2017时,请勾选.net core 开发必要的组件。如果已经安装了vs2017，通过Nuget服务仍无法安装 Surging 组件包时、或是无法通过编译时,请更新vs2017到最新版本，并勾选开发.net core必要的组件。 配置Nuget服务推荐搭建公司内部nuget环境，用于管理公司内的开发的组件包，关于Nuget服务的搭建请参考。Surging的架构通过内部的Nuget服务器进行发布和升级，所以，在安装完 vs2017 后，需要新增内部的Nuget服务的配置。通过下图对nuget进行配置: 安装Docker For Windows(推荐) 到docker官网下载 Docker for Windows Installer.exe 安装包,并安装到系统中。 将docker的registry-mirrors设置为国内地址: https://registry.docker-cn.com。 将使用到的镜像microsoft/dotnet:2.1-sdk、microsoft/dotnet:2.1-runtime、consul:latest、rabbitmq:latest、redis:latest等通过命令docker pull拉取到本地。 Notes 使用和下载docker都必须注册docker账号,请先到docker-store注册地址通过邮箱注册docker账号 docker在Windows系统中默认使用Hyper-V作为虚拟化组件,由于版本冲突,在Windows系统中安装docker后，将无法使用VmWare,如果要使用虚拟机可以通过Hyper-V或VirtualBox创建。 docker for windows 只支持 Windows 专业版及以上，不支持家庭版,如果是家庭版的操作系统，想使用docker的话，需要先更新]]></content>
      <categories>
        <category>微服务</category>
      </categories>
      <tags>
        <tag>微服务</tag>
        <tag>开源框架</tag>
        <tag>Surging</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[微服务框架Surging之简介]]></title>
    <url>%2Fhexo-blog-deploy%2F2018%2F11%2F03%2F2018-11-surging-brief-introduction%2F</url>
    <content type="text"><![CDATA[架构简介Surging是基于.net core2.1平台,在开源社区githubSurging的一个开源框架。 该框架提供高性能的RPC远程服务调用,服务引擎支持http、TCP、WS协议,采用Zookeeper或Consul作为服务的注册中心，集成了哈希、随机、轮询、压力最小优先作为负载均衡的算法，RPC集成采用的是高性能的netty通信框架，数据通信采用异步传输,具有高可用、高性能、可扩展的特性。每个微服务组件均可通过水平扩展来应对高并发。 Surging的简单案例Surging.Sample可以参考我的github。 快速开始 Surging框架的通信方式 Surging框架配置]]></content>
      <categories>
        <category>微服务</category>
      </categories>
      <tags>
        <tag>微服务</tag>
        <tag>开源框架</tag>
        <tag>Surging</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[设计模式之组合模式]]></title>
    <url>%2Fhexo-blog-deploy%2F2018%2F10%2F28%2F2018-10-design-pattern-composite-pattern-note%2F</url>
    <content type="text"><![CDATA[介绍组合模式（Composite Pattern），又叫部分整体模式，是用于把一组相似的对象当作一个单一的对象。组合模式依据树形结构来组合对象，用来表示部分以及整体层次。这种类型的设计模式属于结构型模式，它创建了对象组的树形结构。这种模式创建了一个包含自己对象组的类。该类提供了修改相同对象组的方式。在组合模式中,包含的这些东西或者说是对象，可以分为两类，一类是：容器对象，可以包含其他的子对象；另一类是：叶子对象，这类对象是不能在包含其他对象的对象了。 动机客户代码过多地依赖于对象容器（对象容器是对象的容器，细细评味）复杂的内部实现结构，对象容器内部实现结构（而非抽象接口）的变化将引起客户代码的频繁变化，带来了代码的维护性、扩展性等方面的弊端。如何将“客户代码与复杂的对象容器结构”解耦？如何让对象容器自己来实现自身的复杂结构，从而使得客户代码就像处理简单对象一样来处理复杂的对象容器？ 意图将对象组合成树形结构以表示“部分-整体”的层次结构。Composite使得用户对单个对象和组合对象的使用具有一致性。 结构图 角色 抽象构件角色（Component）：这是一个抽象角色，它给参加组合的对象定义出了公共的接口及默认行为，可以用来管理所有的子对象（在透明式的组合模式是这样的）。在安全式的组合模式里，构件角色并不定义出管理子对象的方法，这一定义由树枝结构对象给出。 树叶构件角色（Leaf）：树叶对象是没有下级子对象的对象，定义出参加组合的原始对象的行为。（原始对象的行为可以理解为没有容器对象管理子对象的方法，或者 【原始对象行为】+【管理子对象的行为（Add，Remove等）】=面对客户代码的接口行为集合） 树枝构件角色（Composite）：代表参加组合的有下级子对象的对象，树枝对象给出所有管理子对象的方法实现，如Add、Remove等。 notes组合模式实现的最关键的地方是——简单对象和复合对象必须实现相同的接口。 实现 透明式的组合模式 抽象构件角色 定义的接口行为集合包含两个部分，一部分是叶子对象本身所包含的行为（比如Operation），另外一部分是容器对象本身所包含的管理子对象的行为(Add,Remove)。这个抽象构件必须同时包含这两类对象所有的行为，客户端代码才会透明的使用，无论调用容器对象还是叶子对象，接口方法都是一样的，这就是透明 安全式的组合模式 只定义叶子对象的方法，确切的说这个抽象构件只定义两类对象共有的行为，然后容器对象的方法定义在“树枝构件角色”上，这样叶子对象有叶子对象的方法，容器对象有容器对象的方法，这样责任很明确，当然调用肯定不会抛出异常了。 透明诗的组合模式12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788namespace 透明式的组合模式的实现&#123; /// &lt;summary&gt; /// 该抽象类就是文件夹抽象接口的定义，该类型就相当于是抽象构件Component类型 /// &lt;/summary&gt; public abstract class Folder &#123; //增加文件夹或文件 public abstract void Add(Folder folder); //删除文件夹或者文件 public abstract void Remove(Folder folder); //打开文件或者文件夹--该操作相当于Component类型的Operation方法 public abstract void Open(); &#125; /// &lt;summary&gt; /// 该Word文档类就是叶子构件的定义，该类型就相当于是Leaf类型，不能在包含子对象 /// &lt;/summary&gt; public sealed class Word : Folder &#123; //增加文件夹或文件 public override void Add(Folder folder) &#123; throw new Exception("Word文档不具有该功能"); &#125; //删除文件夹或者文件 public override void Remove(Folder folder) &#123; throw new Exception("Word文档不具有该功能"); &#125; //打开文件--该操作相当于Component类型的Operation方法 public override void Open() &#123; Console.WriteLine("打开Word文档，开始进行编辑"); &#125; &#125; /// &lt;summary&gt; /// SonFolder类型就是树枝构件，由于我们使用的是“透明式”，所以Add,Remove都是从Folder类型继承下来的 /// &lt;/summary&gt; public class SonFolder : Folder &#123; //增加文件夹或文件 public override void Add(Folder folder) &#123; Console.WriteLine("文件或者文件夹已经增加成功"); &#125; //删除文件夹或者文件 public override void Remove(Folder folder) &#123; Console.WriteLine("文件或者文件夹已经删除成功"); &#125; //打开文件夹--该操作相当于Component类型的Operation方法 public override void Open() &#123; Console.WriteLine("已经打开当前文件夹"); &#125; &#125; public class Program &#123; static void Main() &#123; Folder myword = new Word(); myword.Open();//打开文件，处理文件 myword.Add(new SonFolder());//抛出异常 myword.Remove(new SonFolder());//抛出异常 Folder myfolder = new SonFolder(); myfolder.Open();//打开文件夹 myfolder.Add(new SonFolder());//成功增加文件或者文件夹 myfolder.Remove(new SonFolder());//成功删除文件或者文件夹 Console.Read(); &#125; &#125;&#125; 安全式的组合模式1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586namespace 安全式的组合模式的实现&#123; /// &lt;summary&gt; /// 该抽象类就是文件夹抽象接口的定义，该类型就相当于是抽象构件Component类型 /// &lt;/summary&gt; public abstract class Folder //该类型少了容器对象管理子对象的方法的定义，换了地方，在树枝构件也就是SonFolder类型 &#123; //打开文件或者文件夹--该操作相当于Component类型的Operation方法 public abstract void Open(); &#125; /// &lt;summary&gt; /// 该Word文档类就是叶子构件的定义，该类型就相当于是Leaf类型，不能在包含子对象 /// &lt;/summary&gt; public sealed class Word : Folder //这类型现在很干净 &#123; //打开文件--该操作相当于Component类型的Operation方法 public override void Open() &#123; Console.WriteLine("打开Word文档，开始进行编辑"); &#125; &#125; /// &lt;summary&gt; /// SonFolder类型就是树枝构件，现在由于我们使用的是“安全式”，所以Add,Remove都是从此处开始定义的 /// &lt;/summary&gt; public abstract class SonFolder : Folder //这里可以是抽象接口，可以自己根据自己的情况而定 &#123; //增加文件夹或文件 public abstract void Add(Folder folder); //删除文件夹或者文件 public abstract void Remove(Folder folder); //打开文件夹--该操作相当于Component类型的Operation方法 public override void Open() &#123; Console.WriteLine("已经打开当前文件夹"); &#125; &#125; /// &lt;summary&gt; /// NextFolder类型就是树枝构件的实现类 /// &lt;/summary&gt; public sealed class NextFolder : SonFolder &#123; //增加文件夹或文件 public override void Add(Folder folder) &#123; Console.WriteLine("文件或者文件夹已经增加成功"); &#125; //删除文件夹或者文件 public override void Remove(Folder folder) &#123; Console.WriteLine("文件或者文件夹已经删除成功"); &#125; //打开文件夹--该操作相当于Component类型的Operation方法 public override void Open() &#123; Console.WriteLine("已经打开当前文件夹"); &#125; &#125; public class Program &#123; static void Main() &#123; //这是安全的组合模式 Folder myword = new Word(); myword.Open();//打开文件，处理文件 Folder myfolder = new NextFolder(); myfolder.Open();//打开文件夹 //此处要是用增加和删除功能，需要转型的操作，否则不能使用 ((SonFolder)myfolder).Add(new NextFolder());//成功增加文件或者文件夹 ((SonFolder)myfolder).Remove(new NextFolder());//成功删除文件或者文件夹 Console.Read(); &#125; &#125;&#125; 实现要点 Composite模式采用树形结构来实现普遍存在的对象容器，从而将“一对多”的关系转化为“一对一”的关系，使得客户代码可以一致地处理对象和对象容器，无需关心处理的是单个的对象，还是组合的对象容器。 将“客户代码与复杂的对象容器结构”解耦是Composite模式的核心思想，解耦之后，客户代码将与纯粹的抽象接口——而非对象容器的复杂内部实现结构——发生依赖关系，从而更能“应对变化”。 Composite模式中，是将“Add和Remove等和对象容器相关的方法”定义在“表示抽象对象的Component类”中，还是将其定义在“表示对象容器的Composite类”中，是一个关乎“透明性”和“安全性”的两难问题，需要仔细权衡。这里有可能违背面向对象的“单一职责原则”，但是对于这种特殊结构，这又是必须付出的代价。ASP.Net控件的实现在这方面为我们提供了一个很好的示范。 Composite模式在具体实现中，可以让父对象中的子对象反向追朔；如果父对象有频繁的遍历需求，可使用缓存技巧来改善效率。 优缺点优点 组合模式使得客户端代码可以一致地处理对象和对象容器，无需关系处理的单个对象，还是组合的对象容器。 将”客户代码与复杂的对象容器结构“解耦。 可以更容易地往组合对象中加入新的构件。 缺点 使得设计更加复杂。客户端需要花更多时间理清类之间的层次关系。（这个是几乎所有设计模式所面临的问题）。 使用场景 需要表示一个对象整体或部分的层次结构。 希望用户忽略组合对象与单个对象的不同，用户将统一地使用组合结构中的所有对象。]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
        <tag>结构型</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[设计模式之装饰模式]]></title>
    <url>%2Fhexo-blog-deploy%2F2018%2F10%2F28%2F2018-10-design-pattern-decorator-pattern-note%2F</url>
    <content type="text"><![CDATA[介绍装饰器模式（Decorator Pattern）允许向一个现有的对象添加新的功能，同时又不改变其结构。这种类型的设计模式属于结构型模式，它是作为现有的类的一个包装。这种模式创建了一个装饰类，用来包装原有的类，并在保持类方法签名完整性的前提下，提供了额外的功能。 动机在软件系统中，要给某个类型或者对象增加功能，如果使用“继承”的方案来写代码，就会出现子类暴涨的情况。比如：IMarbleStyle是大理石风格的一个功能，IKeepWarm是保温的一个接口定义，IHouseSecurity是房子安全的一个接口，就三个接口来说，House是我们房子，我们的房子要什么功能就实现什么接口，如果房子要的是复合功能，接口不同的组合就有不同的结果，这样就导致我们子类膨胀严重，如果需要在增加功能，子类会成指数增长。 这个问题的根源在于我们“过度地使用了继承来扩展对象的功能”，由于继承为类型引入的静态特质（所谓静态特质，就是说如果想要某种功能，我们必须在编译的时候就要定义这个类，这也是强类型语言的特点。静态，就是指在编译的时候要确定的东西；动态，是指运行时确定的东西），使得这种扩展方式缺乏灵活性；并且随着子类的增多（扩展功能的增多），各种子类的组合（扩展功能的组合）会导致更多子类的膨胀（多继承）。 意图动态地给一个对象增加一些额外的职责。就增加功能而言，Decorator模式比生成子类更为灵活。 结构图 角色 抽象构件角色（Component）：给出一个抽象接口，以规范准备接收附加责任的对象。 具体构件角色（Concrete Component）：定义一个将要接收附加责任的类。 装饰角色（Decorator）：持有一个构件（Component）对象的实例，并实现一个与抽象构件接口一致的接口。 具体装饰角色（Concrete Decorator）：负责给构件对象添加上附加的责任。 实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107namespace 装饰模式的实现&#123; /********************************************/ // 抽象构件 /********************************************/ /// &lt;summary&gt; /// 该抽象类就是房子抽象接口的定义，该类型就相当于是Component类型，是饺子馅，需要装饰的，需要包装的 /// &lt;/summary&gt; public abstract class House &#123; //房子的装修方法--该操作相当于Component类型的Operation方法 public abstract void Renovation(); &#125; /********************************************/ // 装饰角色 /********************************************/ /// &lt;summary&gt; /// 该抽象类就是装饰接口的定义，该类型就相当于是Decorator类型，如果需要具体的功能，可以子类化该类型 /// &lt;/summary&gt; public abstract class DecorationStrategy:House //关键点之二，体现关系为Is-a，有这这个关系，装饰的类也可以继续装饰了 &#123; //通过组合方式引用Decorator类型，该类型实施具体功能的增加 //这是关键点之一，包含关系，体现为Has-a protected House _house; //通过构造器注入，初始化平台实现 protected DecorationStrategy(House house) &#123; this._house=house; &#125; //该方法就相当于Decorator类型的Operation方法 public override void Renovation() &#123; if(this._house!=null) &#123; this._house.Renovation(); &#125; &#125; &#125; /********************************************/ // 具体构件 /********************************************/ /// &lt;summary&gt; /// PatrickLiu的房子，我要按我的要求做房子，相当于ConcreteComponent类型，这就是我们具体的饺子馅，我个人比较喜欢韭菜馅 /// &lt;/summary&gt; public sealed class PatrickLiuHouse:House &#123; public override void Renovation() &#123; Console.WriteLine("装修PatrickLiu的房子"); &#125; &#125; /********************************************/ // 具体装饰者 /********************************************/ /// &lt;summary&gt; /// 具有安全功能的设备，可以提供监视和报警功能，相当于ConcreteDecoratorA类型 /// &lt;/summary&gt; public sealed class HouseSecurityDecorator:DecorationStrategy &#123; public HouseSecurityDecorator(House house):base(house)&#123;&#125; public override void Renovation() &#123; base.Renovation(); Console.WriteLine("增加安全系统"); &#125; &#125; /// &lt;summary&gt; /// 具有保温接口的材料，提供保温功能，相当于ConcreteDecoratorB类型 /// &lt;/summary&gt; public sealed class KeepWarmDecorator:DecorationStrategy &#123; public KeepWarmDecorator(House house):base(house)&#123;&#125; public override void Renovation() &#123; base.Renovation(); Console.WriteLine("增加保温的功能"); &#125; &#125; /********************************************/ // 客户端调用 /********************************************/ public class Program &#123; static void Main() &#123; //这就是我们需要装饰的房子 House myselfHouse=new PatrickLiuHouse(); DecorationStrategy securityHouse=new HouseSecurityDecorator(myselfHouse); securityHouse.Renovation(); //房子就有了安全系统了 //如果我既要安全系统又要保暖呢，继续装饰就行 DecorationStrategy securityAndWarmHouse=new HouseSecurityDecorator(securityHouse); securityAndWarmHouse.Renovation(); &#125; &#125;&#125; 要点 通过采用组合、而非继承的手法，Decorator模式实现了在运行时动态地扩展对象功能的能力，而且可以根据需要扩展多个功能。避免了单独使用继承带来的灵活性差和多子类衍生问题。 Component类在Decorator模式中充当抽象接口的角色，不应该去实现具体的行为。而且Decorator类对于Component类应该透明——换言之Component类无需知道Decorator类，Decorator类是从外部来扩展Component类的功能。 Decorator类在接口上表现为is-a Component的继承关系，即Decorator类继承了Component类所具有的接口。但在实现上又表现为has-a Component的组合关系，即Decorator类又使用了另外一个Component类。我们可以使用一个或者多个Decorator对象来“装饰”一个Component对象，且装饰后的对象仍然是一个Component对象。 Decorator模式并非解决“多子类衍生的多继承”问题，Decorator模式应用的要点在于解决主体类在多个方向上的扩展功能——是为“装饰”的含义。 优缺点优点 把抽象接口与其实现解耦。 抽象和实现可以独立扩展，不会影响到对方。 实现细节对客户透明，对用于隐藏了具体实现细节。 缺点 增加了系统的复杂度 使用场景 如果一个系统需要在构件的抽象化角色和具体化角色之间添加更多的灵活性，避免在两个层次之间建立静态的联系。 设计要求实现化角色的任何改变不应当影响客户端，或者实现化角色的改变对客户端是完全透明的。 需要跨越多个平台的图形和窗口系统上。 一个类存在两个独立变化的维度，且两个维度都需要进行扩展。 .net中的实现在Net框架中，有一个类型很明显的使用了“装饰模式”，这个类型就是Stream。Stream类型是一个抽象接口，它在System.IO命名空间里面，它其实就是Component。FileStream、NetworkStream、MemoryStream都是实体类ConcreteComponent。右边的BufferedStream、CryptoStream是装饰对象，它们都是继承了Stream接口的。]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
        <tag>结构型</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[设计模式之桥接模式]]></title>
    <url>%2Fhexo-blog-deploy%2F2018%2F10%2F24%2F2018-10-design-pattern-bridge-pattern-note%2F</url>
    <content type="text"><![CDATA[简介【桥接模式】，也有叫【桥模式】的，英文名称：Bridge Pattern。可以通过名称看出这个模式是根据名称猜肯定是连接什么东西的。因为桥在我们现实生活中经常是连接着A地和B地，再往后来发展，桥引申为一种纽带。 动机桥接（Bridge）是用于把抽象化与实现化解耦，使得二者可以独立变化。这种类型的设计模式属于结构型模式，它通过提供抽象化和实现化之间的桥接结构，来实现二者的解耦。这种模式涉及到一个作为桥接的接口，使得实体类的功能独立于接口实现类。这两种类型的类可被结构化改变而互不影响。桥是针对桥的使用环境来说的，解决了跨越和衔接的问题。 意图将抽象部分与实现部分分离，使它们都可以独立的变化。 结构图 模式的组成 抽象化角色(Abstraction)： 抽象化给出的定义，并保存一个对实现化对象（Implementor）的引用。 修正抽象化角色(Refined Abstraction)： 扩展抽象化角色，改变和修正父类对抽象化的定义。 实现化角色(Implementor)： 这个角色给出实现化角色的接口，但不给出具体的实现。必须指出的是，这个接口不一定和抽象化角色的接口定义相同，实际上，这两个接口可以非常不一样。实现化角色应当只给出底层操作，而抽象化角色应当只给出基于底层操作的更高一层的操作。 具体实现化角色(Concrete Implementor)： 这个角色给出实现化角色接口的具体实现。 实现案例: 以数据库为例来写该模式的实现。每种数据库都有自己的版本，但是每种数据库在不同的平台上实现又是不一样的。比如：微软的SqlServer数据库，该数据库它有2000版本、2005版本、2006版本、2008版本，后面还会有更新的版本。并且这些版本都是运行在Windows操作系统下的，如果要提供Lunix操作系统下的SqlServer怎么办呢？如果又要提供IOS操作系统下的SqlServer数据库该怎么办呢？这个情况就可以使用桥接模式，也就是Brige模式。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111namespace 桥接模式的实现&#123;//////////////////////////////////////////////////////////////// 抽象化角色///////////////////////////////////////////////////////////////// &lt;summary&gt;/// 该抽象类就是抽象接口的定义，该类型就相当于是Abstraction类型/// &lt;/summary&gt;public abstract class Database&#123; //通过组合方式引用平台接口，此处就是桥梁，该类型相当于Implementor类型 protected PlatformImplementor _implementor; //通过构造器注入，初始化平台实现 protected Database(PlatformImplementor implementor) &#123; this._implementor = implementor; &#125; //创建数据库--该操作相当于Abstraction类型的Operation方法 public abstract void Create();&#125;//////////////////////////////////////////////////////////////// 实现化角色///////////////////////////////////////////////////////////////// &lt;summary&gt;/// 该抽象类就是实现接口的定义，该类型就相当于是Implementor类型/// &lt;/summary&gt;public abstract class PlatformImplementor&#123; //该方法就相当于Implementor类型的OperationImpl方法 public abstract void Process();&#125;//////////////////////////////////////////////////////////////// 修正抽象化角色///////////////////////////////////////////////////////////////// &lt;summary&gt;/// SqlServer2000版本的数据库，相当于RefinedAbstraction类型/// &lt;/summary&gt;public class SqlServer2000 : Database&#123; //构造函数初始化 public SqlServer2000(PlatformImplementor implementor) : base(implementor) &#123; &#125; public override void Create() &#123; this._implementor.Process(); &#125;&#125;/// &lt;summary&gt;/// SqlServer2005版本的数据库，相当于RefinedAbstraction类型/// &lt;/summary&gt;public class SqlServer2005 : Database&#123; //构造函数初始化 public SqlServer2005(PlatformImplementor implementor) : base(implementor) &#123; &#125; public override void Create() &#123; this._implementor.Process(); &#125;&#125;//////////////////////////////////////////////////////////////// 具体实现化角色///////////////////////////////////////////////////////////////// &lt;summary&gt;/// SqlServer2000版本的数据库针对Unix操作系统具体的实现，相当于ConcreteImplementorA类型/// &lt;/summary&gt;public class SqlServer2000UnixImplementor : PlatformImplementor&#123; public override void Process() &#123; Console.WriteLine("SqlServer2000针对Unix的具体实现"); &#125;&#125;/// &lt;summary&gt;/// SqlServer2005版本的数据库针对Unix操作系统的具体实现，相当于ConcreteImplementorB类型/// &lt;/summary&gt;public sealed class SqlServer2005UnixImplementor : PlatformImplementor&#123; public override void Process() &#123; Console.WriteLine("SqlServer2005针对Unix的具体实现"); &#125;&#125;//////////////////////////////////////////////////////////////// 客户端////////////////////////////////////////////////////////////// public class Program &#123; static void Main() &#123; PlatformImplementor SqlServer2000UnixImp = new SqlServer2000UnixImplementor(); //还可以针对不同平台进行扩展，也就是子类化，这个是独立变化的 Database SqlServer2000Unix = new SqlServer2000(SqlServer2000UnixImp); //数据库版本也可以进行扩展和升级，也进行独立的变化。 //以上就是两个维度的变化。 //就可以针对Unix执行操作了 SqlServer2000Unix.Create(); &#125; &#125;&#125; 要点 Bridge模式使用“对象间的组合关系”解耦了抽象和实现之间固有的绑定关系，使得抽象和实现可以沿着各自的维度来变化。 所谓抽象和实现沿着各自维度的变化，即子类化它们，得到各个子类之后，便可以任意组合它们，从而获得不同平台上的不同型号。 Bridge模式有时候类似于多继承方案，但是多继承方案往往违背了类的单一职责原则（即一个类只有一个变化的原因），复用性比较差。Bridge模式是比多继承方案更好的解决方法。 Bridge模式的应用一般在两个非常强的变化维度，有时候即使有两个变化的维度，但是某个方向的变化维度并不剧烈——换言之两个变化不会导致纵横交错的结果，并不一定要使用Bridge模式。 优缺点优点 把抽象接口与其实现解耦。 抽象和实现可以独立扩展，不会影响到对方。 实现细节对客户透明，对用于隐藏了具体实现细节。 缺点增加了系统的复杂度 使用场景 如果一个系统需要在构件的抽象化角色和具体化角色之间添加更多的灵活性，避免在两个层次之间建立静态的联系。 设计要求实现化角色的任何改变不应当影响客户端，或者实现化角色的改变对客户端是完全透明的。 需要跨越多个平台的图形和窗口系统上。 一个类存在两个独立变化的维度，且两个维度都需要进行扩展。]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
        <tag>结构型</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[设计模式之适配器模式]]></title>
    <url>%2Fhexo-blog-deploy%2F2018%2F10%2F21%2F2018-10-design-pattern-adapter-pattern-note%2F</url>
    <content type="text"><![CDATA[介绍适配器模式实际上就是一个转换的过程,把不能一起工作的两样东西通过转换，让他们能够在一起工作。在现实中的例子比如:手机的充电器，充电器的接头，有的是把两相电转换为三相电的，当然也有把三相电转换成两相电的。使用笔记本电脑，笔记本电脑的工作电压和我们家里照明电压是不一致的，当然也就需要充电器把照明电压转换成笔记本的工作电压，只有这样笔记本电脑才可以正常工作。 动机在软件系统中，由于应用环境的变化，常常需要将一些现存的对象放在新的环境中应用，但是新环境要求的接口是这些现存对象所不满足的。如何应对这种“迁移的变化”？如何既能利用现有对象的良好实现，同时又能满足新的应用环境所要求的接口？ 意图将一个类的接口转换成客户希望的另一个接口。Adapter模式使得原本由于接口不兼容而不能一起工作的那些类可以一起工作。 结构图适配器有两种类型:一种是对象适配器，一种是类适配器,相对而言,对象适配器更为常用。 对象适配器对象适配器使用的是对象组合的方案，它的Adapter和Adaptee的关系是组合关系。OO中优先使用组合模式，组合模式不适用再考虑继承。因为组合模式更加松耦合，而继承是紧耦合的，父类的任何改动都要导致子类的改动。 类适配器类适配器使用的是继承的方案，Adapter和Adaptee的关系是继承关系。 角色组成 目标角色（Target）：定义Client使用的与特定领域相关的接口。 客户角色（Client）：与符合Target接口的对象协同。 被适配角色（Adaptee)：定义一个已经存在并已经使用的接口，这个接口需要适配。 适配器角色（Adapte)：适配器模式的核心。它将对被适配Adaptee角色已有的接口转换为目标角色Target匹配的接口。对Adaptee的接口与Target接口进行适配. 实现对象适配器的实现1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071namespace 对象的适配器模式&#123; //////////////////////////////////////////////////////// // 客户端调用 //////////////////////////////////////////////////////// ///&lt;summary&gt; ///家里只有两个孔的插座，也懒得买插线板了，还要花钱，但是我的手机是一个有3个小柱子的插头，明显直接搞不定，那就适配吧 ///&lt;/summary&gt; class Client &#123; static void Main(string[] args) &#123; //好了，现在就可以给手机充电了 TwoHoleTarget homeTwoHole = new ThreeToTwoAdapter(); homeTwoHole.Request(); Console.ReadLine(); &#125; &#125; //////////////////////////////////////////////////////// // 目标角色（Target） //////////////////////////////////////////////////////// /// &lt;summary&gt; /// 我家只有2个孔的插座，也就是适配器模式中的目标(Target)角色，这里可以写成抽象类或者接口 /// &lt;/summary&gt; public class TwoHoleTarget &#123; // 客户端需要的方法 public virtual void Request() &#123; Console.WriteLine("两孔的充电器可以使用"); &#125; &#125; //////////////////////////////////////////////////////// // 被适配角色（Adaptee) //////////////////////////////////////////////////////// /// &lt;summary&gt; /// 手机充电器是有3个柱子的插头，源角色——需要适配的类（Adaptee） /// &lt;/summary&gt; public class ThreeHoleAdaptee &#123; public void SpecificRequest() &#123; Console.WriteLine("我是3个孔的插头也可以使用了"); &#125; &#125; //////////////////////////////////////////////////////// // 适配器类 //////////////////////////////////////////////////////// /// &lt;summary&gt; /// 适配器类，TwoHole这个对象写成接口或者抽象类更好，面向接口编程嘛 /// &lt;/summary&gt; public class ThreeToTwoAdapter : TwoHoleTarget &#123; // 引用两个孔插头的实例,从而将客户端与TwoHole联系起来 private ThreeHoleAdaptee threeHoleAdaptee = new ThreeHoleAdaptee(); //这里可以继续增加适配的对象。。 /// &lt;summary&gt; /// 实现2个孔插头接口方法 /// &lt;/summary&gt; public override void Request() &#123; //可以做具体的转换工作 threeHoleAdaptee.SpecificRequest(); //可以做具体的转换工作 &#125; &#125;&#125; 类适配器的实现1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162namespace 设计模式之适配器模式&#123; //////////////////////////////////////////////////////// // 客户端调用 //////////////////////////////////////////////////////// /// &lt;summary&gt; /// 这里手机充电器为例，我们的家的插座是两相电的，但是手机的插座接头是三相电的 /// &lt;/summary&gt; class Client &#123; static void Main(string[] args) &#123; //好了，现在可以充电了 ITwoHoleTarget change = new ThreeToTwoAdapter(); change.Request(); Console.ReadLine(); &#125; &#125; //////////////////////////////////////////////////////// // 目标角色（Target） //////////////////////////////////////////////////////// /// &lt;summary&gt; /// 我家只有2个孔的插座，也就是适配器模式中的目标角色（Target），这里只能是接口，也是类适配器的限制 /// &lt;/summary&gt; public interface ITwoHoleTarget &#123; void Request(); &#125; //////////////////////////////////////////////////////// // 被适配角色（Adaptee) //////////////////////////////////////////////////////// /// &lt;summary&gt; /// 3个孔的插头，源角色——需要适配的类（Adaptee） /// &lt;/summary&gt; public abstract class ThreeHoleAdaptee &#123; public void SpecificRequest() &#123; Console.WriteLine("我是三个孔的插头"); &#125; &#125; //////////////////////////////////////////////////////// // 适配器角色（Adapte) //////////////////////////////////////////////////////// /// &lt;summary&gt; /// 适配器类，接口要放在类的后面，在此无法适配更多的对象，这是类适配器的不足 /// &lt;/summary&gt; public class ThreeToTwoAdapter:ThreeHoleAdaptee,ITwoHoleTarget &#123; /// &lt;summary&gt; /// 实现2个孔插头接口方法 /// &lt;/summary&gt; public void Request() &#123; // 调用3个孔插头方法 this.SpecificRequest(); &#125; &#125;&#125; 实现要点 Adapter模式主要应用于“希望复用一些现存的类，但是接口又与复用环境要求不一致的情况”，在遗留代码复用、类库迁移等方面非常有用。 GoF23定义了两种Adapter模式的实现结构：对象适配器和类适配器 类适配器采用多继承的实现方式，在C#语言中，如果被适配角色是类，Target的实现只能是接口，因为C#语言只支持接口的多继承的特性。在C#语言中类适配器也很难支持适配多个对象的情况，同时也会带来了不良的高耦合和违反类的职责单一的原则，所以一般不推荐使用。 对象适配器采用对象组合的方式，更符合松耦合精神，对适配的对象也没限制，可以一个，也可以多个，但是，使得重定义Adaptee的行为较困难，这就需要生成Adaptee的子类并且使得Adapter引用这个子类而不是引用Adaptee本身。 Adapter模式可以实现的非常灵活，不必拘泥于GoF23中定义的两种结构。例如，完全可以将Adapter模式中的“现存对象”作为新的接口方法参数，来达到适配的目的。 Adapter模式本身要求我们尽可能地使用“面向接口的编程”风格，这样才能在后期很方便地适配。 优缺点对象适配器的优缺点优点 可以在不修改原有代码的基础上来复用现有类，很好地符合 “开闭原则”（这点是两种实现方式都具有的） 采用 “对象组合”的方式，更符合松耦合。 缺点 使得重定义Adaptee的行为较困难，这就需要生成Adaptee的子类并且使得Adapter引用这个子类而不是引用Adaptee本身。 类适配器的优缺点优点 可以在不修改原有代码的基础上来复用现有类，很好地符合 “开闭原则” 可以重新定义Adaptee(被适配的类)的部分行为，因为在类适配器模式中，Adapter是Adaptee的子类 仅仅引入一个对象，并不需要额外的字段来引用Adaptee实例（这个即是优点也是缺点）。缺点 用一个具体的Adapter类对Adaptee和Target进行匹配，当如果想要匹配一个类以及所有它的子类时，类的适配器模式就不能胜任了。因为类的适配器模式中没有引入Adaptee的实例，光调用this.SpecificRequest方法并不能去调用它对应子类的SpecificRequest方法。 采用了 “多继承”的实现方式，带来了不良的高耦合。 适配器的使用场景 系统需要复用现有类，而该类的接口不符合系统的需求 想要建立一个可重复使用的类，用于与一些彼此之间没有太大关联的一些类，包括一些可能在将来引进的类一起工作。 对于对象适配器模式，在设计里需要改变多个已有子类的接口，如果使用类的适配器模式，就要针对每一个子类做一个适配器，而这不太实际。]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
        <tag>结构型</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[设计模式之原型模式]]></title>
    <url>%2Fhexo-blog-deploy%2F2018%2F10%2F21%2F2018-10-design-pattern-prototype-pattern-note%2F</url>
    <content type="text"><![CDATA[简介有很多人说原型设计模式会节省机器内存，他们说是拷贝出来的对象，这些对象其实都是原型的复制，不会使用内存。这是不对的，因为拷贝出来的每一个对象都是实际存在的，每个对象都有自己的独立内存地址，都会被GC回收。如果就浅拷贝来说，可能会公用一些字段，深拷贝是不会的，所以说原型设计模式会提高内存使用率，不一定。具体还要看当时的设计，如果拷贝出来的对象缓存了，每次使用的是缓存的拷贝对象，那就另当别论了，再说该模式本身解决的不是内存使用率的问题。 原型模式本身解决的并不是内存使用率的问题,那么原型模式要解决的是什么问题呢？在软件系统中，当创建一个类的实例的过程很昂贵或很复杂，并且我们需要创建多个这样类的实例时，如果我们用new操作符去创建这样的类实例，这就会增加创建类的复杂度和创建过程与客户代码复杂的耦合度。如果采用工厂模式来创建这样的实例对象的话，随着产品类的不断增加，导致子类的数量不断增多，也导致了相应工厂类的增加，维护的代码维度增加了，因为有产品和工厂两个维度了，反而增加了系统复杂程度，所以在这里使用工厂模式来封装类创建过程并不合适。由于每个类实例都是相同的，这个相同指的是类型相同，但是每个实例的状态参数会有不同，如果状态数值也相同就没意义了，有一个这样的对象就可以了。当我们需要多个相同的类实例时，可以通过对原来对象拷贝一份来完成创建，这个思路正是原型模式的实现方式。 动机在软件系统中，经常面临着某些结构复杂的对象的创建工作；由于需求的变化，这些对象经常面临着剧烈的变化，但是它们却拥有比较稳定一致的接口。如何应对这种变化？如何向“客户程序（使用这些对象的程序）”隔离出“这些易变对象”，从而使得“依赖这些易变对象的客户程序”不随着需求改变而改变？ 意图使用原型实例指定创建对象的种类，然后通过拷贝这些原型来创建新的对象。 结构图 角色在原型模式中，Prototype通常提供一个包含Clone方法的接口，具体的原型ConcretePrototype使用Clone方法完成对象的创建。 原型类（Prototype）：抽象原型类，声明一个Clone自身的接口； 具体原型类（ConcretePrototype）：实现一个Clone自身的操作。 实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103///////////////////////////////////////////////////////////////////////// 客户端///////////////////////////////////////////////////////////////////////// &lt;summary&gt;/// 原型设计模式，每个具体原型是一类对象的原始对象，通过每个原型对象克隆出来的对象也可以进行设置，在原型的基础之上丰富克隆出来的对象，所以要设计好抽象原型的接口/// &lt;/summary&gt;namespace 设计模式之原型模式&#123; /// &lt;summary&gt; /// 客户类 /// &lt;/summary&gt; class Customer &#123; static void Main(string[] args) &#123; Prototype xingZheSun = new XingZheSunPrototype(); Prototype xingZheSun2 = xingZheSun.Clone(); Prototype xingZheSun3 = xingZheSun.Clone(); Prototype sunXingZhe = new SunXingZhePrototype(); Prototype sunXingZhe2 = sunXingZhe.Clone(); Prototype sunXingZhe3 = sunXingZhe.Clone(); Prototype sunXingZhe4 = sunXingZhe.Clone(); Prototype sunXingZhe5 = sunXingZhe.Clone(); //1号孙行者打妖怪 sunXingZhe.Fight(); //2号孙行者去化缘 sunXingZhe2.BegAlms(); //战斗和化缘也可以分类，比如化缘，可以分：水果类化缘，饭食类化缘；战斗可以分为：天界宠物下界成妖的战斗，自然修炼成妖的战斗，大家可以自己去想吧，原型模式还是很有用的 Console.Read(); &#125; &#125;///////////////////////////////////////////////////////////////////////// 抽象原型类，需要定义一个Clone接口////////////////////////////////////////////////////////////////////// /// &lt;summary&gt; /// 抽象原型，定义了原型本身所具有特征和动作，该类型就是至尊宝 /// &lt;/summary&gt; public abstract class Prototype &#123; // 战斗--保护师傅 public abstract void Fight(); // 化缘--不要饿着师傅 public abstract void BegAlms(); // 吹口仙气--变化一个自己出来 public abstract Prototype Clone(); &#125;///////////////////////////////////////////////////////////////////////// 具体原型类,实现一个Clone自身的操作。////////////////////////////////////////////////////////////////////// /// &lt;summary&gt; /// 具体原型，例如：行者孙，他只负责化斋饭食和与天界宠物下界的妖怪的战斗 /// &lt;/summary&gt; public sealed class XingZheSunPrototype:Prototype &#123; // 战斗--保护师傅--与自然修炼成妖的战斗 public override void Fight() &#123; Console.WriteLine("腾云驾雾，各种武艺"); &#125; // 化缘--不要饿着师傅--饭食类 public override void BegAlms() &#123; Console.WriteLine("什么都能要来"); &#125; // 吹口仙气--变化一个自己出来 public override Prototype Clone() &#123; return (XingZheSunPrototype)this.MemberwiseClone(); &#125; &#125; /// &lt;summary&gt; /// 具体原型，例如：孙行者，他只负责与自然界修炼成妖的战斗和化斋水果 /// &lt;/summary&gt; public sealed class SunXingZhePrototype : Prototype &#123; // 战斗--保护师傅-与天界宠物战斗 public override void Fight() &#123; Console.WriteLine("腾云驾雾，各种武艺"); &#125; // 化缘--不要饿着师傅---水果类 public override void BegAlms() &#123; Console.WriteLine("什么都能要来"); &#125; // 吹口仙气--变化一个自己出来 public override Prototype Clone() &#123; return (SunXingZhePrototype)this.MemberwiseClone(); &#125; &#125;&#125; 实现要点Prototype模式同样用于隔离类对象的使用者和具体类型（易变类）之间的耦合关系，它同样要求这些易变类拥有稳定的接口。 Prototype模式对于“如何创建易变类的实体对象”（创建型模式除了Singleton模式以外，都是用于解决创建易变类的实体对象的问题的）采用原型克隆的方法来做，它使得我们可以非常灵活地动态创建拥有某些稳定接口的新对象——所需工作仅仅是注册一个新类的对象（即原型），然后在任何需要的地方不断地Clone。 Prototype模式中的Clone方法可以利用.NET中的Object类的MemberwiseClone()方法或者序列化来实现深拷贝。 优缺点优点 原型模式向客户隐藏了创建新实例的复杂性 原型模式允许动态增加或较少产品类。 原型模式简化了实例的创建结构，工厂方法模式需要有一个与产品类等级结构相同的等级结构，而原型模式不需要这样。 产品类不需要事先确定产品的等级结构，因为原型模式适用于任何的等级结构 缺点 每个类必须配备一个克隆方法 配备克隆方法需要对类的功能进行通盘考虑，这对于全新的类不是很难，但对于已有的类不一定很容易，特别当一个类引用不支持串行化的间接对象，或者引用含有循环结构的时候。 使用场景在实际项目中，原型模式很少单独出现，一般是和工厂方法模式一起出现，通过clone的方法创建一个对象，然后由工厂方法提供给调用者。 资源优化场景 类初始化需要消化非常多的资源，这个资源包括数据、硬件资源等。 性能和安全要求的场景 通过new产生一个对象需要非常繁琐的数据准备或访问权限，则可以使用原型模式。一个对象多个修改者的场景 一个对象需要提供给其他对象访问，而且各个调用者可能都需要修改其值时，可以考虑使用原型模式拷贝多个对象供调用者使用。 NET中的ICloneable接口微软已经为我们提供了原型模式的接口实现，该接口就是ICloneable，其实这个接口就是抽象原型，提供克隆方法，相当于与上面代码中Prototype抽象类，其中的Clone()方法来实现原型模式，如果我们想我们自定义的类具有克隆的功能，首先定义类实现ICloneable接口的Clone方法。]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>创建型</tag>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[设计模式之建造者模式]]></title>
    <url>%2Fhexo-blog-deploy%2F2018%2F10%2F20%2F2018-10-design-pattern-builder-pattern-note%2F</url>
    <content type="text"><![CDATA[简介建造者模式也叫做生成器模式。在构建一个复杂的物品时,例如：电脑，它就是一个复杂的物品，它主要是由CPU、主板、硬盘、显卡、机箱等组装而成的。但是对于这样的产品，组装流水线是固定的，不变的，但是把不同的主板和其他组件组装在一起就会生产出不同型号的电脑。 在软件系统中我们也会遇到类似的复杂对象，并且这个复杂对象的各个部分按照一定的算法组合在一起，此时该对象的创建工作就可以使用Builder模式。 动机在软件系统中，有时候面临着一个复杂对象的创建工作，其通常由各个部分的子对象用一定的算法构成；由于需求的变化，这个复杂对象的各个部分经常面临着剧烈的变化，但是将它们组合在一起的算法却相对稳定。 使用场景一些基本部件不会变，而其组合经常变化的时候,在构建这个复杂产品(对象)的时候，就可以考虑使用建造者模式。 意图将一个复杂对象的构建与其表示相分离，使得同样的构建过程可以创建不同的表示(产品)。 结构图 模式的组成 抽象建造者角色（Builder）：为创建一个Product对象的各个部件指定抽象接口，以规范产品对象的各个组成成分的建造。一般而言，此角色规定要实现复杂对象的哪些部分的创建，并不涉及具体的对象部件的创建。 具体建造者（ConcreteBuilder） 实现Builder的接口以构造和装配该产品的各个部件。即实现抽象建造者角色Builder的方法。 定义并明确它所创建的表示，即针对不同的商业逻辑，具体化复杂对象的各部分的创建 提供一个检索产品的接口 构造一个使用Builder接口的对象即在指导者的调用下创建产品实例 指导者（Director）：调用具体建造者角色以创建产品对象的各个部分。指导者并没有涉及具体产品类的信息，真正拥有具体产品的信息是具体建造者对象。它只负责保证对象各部分完整创建或按某种顺序创建。 产品角色（Product）：建造中的复杂对象。它要包含那些定义组件的类，包括将这些组件装配成产品的接口。 模式的代码实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165using System;using System.Collections.Generic;using System.Linq;using System.Text;/// &lt;summary&gt;/// 现在人们的生活水平都提高了，有钱了，我今天就以汽车组装为例子/// 每台汽车的组装过程都是一致的，所以我们使用同样的构建过程可以创建不同的表示(即可以组装成不同型号的汽车，不能像例子这样，一会别克，一会奥迪的)/// 组装汽车、电脑、手机、电视等等负责对象的这些场景都可以应用建造者模式来设计/// &lt;/summary&gt;namespace 设计模式之建造者模式&#123; /////////////////////////////////////////////////////////// /// 客户端 ////////////////////////////////////////////////////////// /// &lt;summary&gt; /// 客户类 /// &lt;/summary&gt; class Customer &#123; static void Main(string[] args) &#123; Director director = new Director(); Builder buickCarBuilder = new BuickBuilder(); Builder aoDiCarBuilder = new AoDiBuilder(); director.Construct(buickCarBuilder); //组装完成，我来驾驶别克了 Car buickCar = buickCarBuilder.GetCar(); buickCar.Show(); // 我老婆就要奥迪了，她比较喜欢大品牌 director.Construct(aoDiCarBuilder); Car aoDiCar = aoDiCarBuilder.GetCar(); aoDiCar.Show(); Console.Read(); &#125; &#125; /////////////////////////////////////////////////////////// /// 指导者 ////////////////////////////////////////////////////////// /// &lt;summary&gt; /// 这个类型才是组装的，Construct方法里面的实现就是创建复杂对象固定算法的实现，该算法是固定的，或者说是相对稳定的 /// 这个人当然就是老板了，也就是建造者模式中的指挥者 /// &lt;/summary&gt; public class Director &#123; // 组装汽车 public void Construct(Builder builder) &#123; builder.BuildCarDoor(); builder.BuildCarWheel(); builder.BuildCarEngine(); &#125; &#125; /////////////////////////////////////////////////////////// /// 具体产品 ////////////////////////////////////////////////////////// /// &lt;summary&gt; /// 汽车类 /// &lt;/summary&gt; public sealed class Car &#123; // 汽车部件集合 private IList&lt;string&gt; parts = new List&lt;string&gt;(); // 把单个部件添加到汽车部件集合中 public void Add(string part) &#123; parts.Add(part); &#125; public void Show() &#123; Console.WriteLine("汽车开始在组装......."); foreach (string part in parts) &#123; Console.WriteLine("组件" + part + "已装好"); &#125; Console.WriteLine("汽车组装好了"); &#125; &#125; /////////////////////////////////////////////////////////// /// 抽象的建造者 ////////////////////////////////////////////////////////// /// &lt;summary&gt; /// 抽象建造者，它定义了要创建什么部件和最后创建的结果，但是不是组装的的类型，切记 /// &lt;/summary&gt; public abstract class Builder &#123; // 创建车门 public abstract void BuildCarDoor(); // 创建车轮 public abstract void BuildCarWheel(); //创建车引擎 public abstract void BuildCarEngine(); // 当然还有部件，大灯、方向盘等，这里就省略了 // 获得组装好的汽车 public abstract Car GetCar(); &#125; /////////////////////////////////////////////////////////// /// 具体的建造者 ////////////////////////////////////////////////////////// /// &lt;summary&gt; /// 具体创建者，具体的车型的创建者，例如：别克 /// &lt;/summary&gt; public sealed class BuickBuilder : Builder &#123; Car buickCar = new Car(); public override void BuildCarDoor() &#123; buickCar.Add("Buick's Door"); &#125; public override void BuildCarWheel() &#123; buickCar.Add("Buick's Wheel"); &#125; public override void BuildCarEngine() &#123; buickCar.Add("Buick's Engine"); &#125; public override Car GetCar() &#123; return buickCar; &#125; &#125; /// &lt;summary&gt; /// 具体创建者，具体的车型的创建者，例如：奥迪 /// &lt;/summary&gt; public sealed class AoDiBuilder : Builder &#123; Car aoDiCar = new Car(); public override void BuildCarDoor() &#123; aoDiCar.Add("Aodi's Door"); &#125; public override void BuildCarWheel() &#123; aoDiCar.Add("Aodi's Wheel"); &#125; public override void BuildCarEngine() &#123; aoDiCar.Add("Aodi's Engine"); &#125; public override Car GetCar() &#123; return aoDiCar; &#125; &#125;&#125; 实现要点在【建造者模式】中，指挥者是直接与客户端打交道的，指挥者将客户端创建产品的请求划分为对各个部件的建造请求，再将这些请求委派到具体建造者角色，具体建造者角色是完成具体产品的构建工作的，却不为客户所知道。 建造者模式主要用于分步骤来构建一个复杂的对象，其中: 分步骤是一个固定的组合过程,通过指挥者来组装实现。 复杂对象的各个部分是经常变化的,产品不需要抽象类，由于建造模式的创建出来的最终产品可能差异很大，所以不大可能提炼出一个抽象产品类。 优缺点优点 使用建造者模式可以使客户端不必知道产品内部组成的细节。 具体的建造者类之间是相互独立的，容易扩展。 由于具体的建造者是独立的，因此可以对建造过程逐步细化，而不对其他的模块产生任何影响。 缺点 产生多余的Build对象以及Dirextor类。 创建者模式的使用场景 当创建复杂对象的算法应该独立于该对象的组成部分以及它们的装配方式时。 相同的方法，不同的执行顺序，产生不同的事件结果时。 多个部件或零件,都可以装配到一个对象中，但是产生的运行结果又不相同时。 产品类非常复杂，或者产品类中的调用顺序不同产生了不同的效能。 创建一些复杂的对象时，这些对象的内部组成构件间的建造顺序是稳定的，但是对象的内部组成构件面临着复杂的变化。]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>创建型</tag>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[设计模式之抽象工厂模式]]></title>
    <url>%2Fhexo-blog-deploy%2F2018%2F10%2F16%2F2018-10-design-pattern-abstractfatory-note%2F</url>
    <content type="text"><![CDATA[动机(Motivate) 在软件系统中，经常面临着一系列相互依赖的对象的创建工作：同时，由于需求的变化，往往存在更多系列对象的创建工作。如何应对这种变化？ 意图(Intent)提供一个创建一系列相关或相互依赖对象的接口，而无需指定它们具体的类。 主要解决的问题主要解决接口选择的问题。 结构图（Structure） 模式的组成 抽象产品类角色（AbstractProduct）：为抽象工厂中相互依赖的每种产品定义抽象接口对象，也可以这样说，有几种产品，就要声明几个抽象角色，每一个抽象产品角色和一种具体的产品相匹配。 具体产品类（ConcreteProduct）：具体产品类实现了抽象产品类，是针对某个具体产品的实现的类型。 抽象工厂类角色（Abstract Factory）：定义了创建一组相互依赖的产品对象的接口操作，每种操作和每种产品一一对应。 具体工厂类角色（ConcreteFactory）：实现抽象类里面的所有抽象接口操作，可以创建某系列具体的产品，这些具体的产品是“抽象产品类角色”的子类。 代码实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241/////////////////////////////////////////////////////////////// 客户端调用//////////////////////////////////////////////////////////////// &lt;summary&gt;/// 下面以不同系列房屋的建造为例子演示抽象工厂模式/// 因为每个人的喜好不一样，我喜欢欧式的，我弟弟就喜欢现代的/// 客户端调用/// &lt;/summary&gt;class Client&#123; static void Main(string[] args) &#123; // 哥哥的欧式风格的房子 AbstractFactory europeanFactory= new EuropeanFactory(); europeanFactory.CreateRoof().Create(); europeanFactory.CreateFloor().Create(); europeanFactory.CreateWindow().Create(); europeanFactory.CreateDoor().Create(); //弟弟的现代风格的房子 AbstractFactory modernizationFactory = new ModernizationFactory(); modernizationFactory.CreateRoof().Create(); modernizationFactory.CreateFloor().Create(); modernizationFactory.CreateWindow().Create(); modernizationFactory.CreateDoor().Create(); Console.Read(); &#125; &#125;/////////////////////////////////////////////////////////////// 抽象工厂 //////////////////////////////////////////////////////////////// &lt;summary&gt;/// 抽象工厂类，提供创建不同类型房子的接口/// &lt;/summary&gt;public abstract class AbstractFactory &#123; // 抽象工厂提供创建一系列产品的接口，这里作为例子，只给出了房顶、地板、窗户和房门创建接口 public abstract Roof CreateRoof(); public abstract Floor CreateFloor(); public abstract Window CreateWindow(); public abstract Door CreateDoor(); &#125;/////////////////////////////////////////////////////////////// 具体工厂类//////////////////////////////////////////////////////////////// &lt;summary&gt;/// 欧式风格房子的工厂，负责创建欧式风格的房子/// &lt;/summary&gt;public class EuropeanFactory : AbstractFactory&#123; // 制作欧式房顶 public override Roof CreateRoof() &#123; return new EuropeanRoof(); &#125; // 制作欧式地板 public override Floor CreateFloor() &#123; return new EuropeanFloor(); &#125; // 制作欧式窗户 public override Window CreateWindow() &#123; return new EuropeanWindow(); &#125; // 制作欧式房门 public override Door CreateDoor() &#123; return new EuropeanDoor(); &#125;&#125;/// &lt;summary&gt;/// 现在风格房子的工厂，负责创建现代风格的房子/// &lt;/summary&gt;public class ModernizationFactory : AbstractFactory&#123; // 制作现代房顶 public override Roof CreateRoof() &#123; return new ModernizationRoof(); &#125; // 制作现代地板 public override Floor CreateFloor() &#123; return new ModernizationFloor(); &#125; // 制作现代窗户 public override Window CreateWindow() &#123; return new ModernizationWindow(); &#125; // 制作现代房门 public override Door CreateDoor() &#123; return new ModernizationDoor(); &#125;&#125; /////////////////////////////////////////////////////////////// 抽象产品类角色//////////////////////////////////////////////////////////////// &lt;summary&gt;/// 房顶抽象类，子类的房顶必须继承该类/// &lt;/summary&gt;public abstract class Roof &#123; /// &lt;summary&gt; /// 创建房顶 /// &lt;/summary&gt; public abstract void Create();&#125;/// &lt;summary&gt;/// 地板抽象类，子类的地板必须继承该类/// &lt;/summary&gt;public abstract class Floor &#123; /// &lt;summary&gt; /// 创建地板 /// &lt;/summary&gt; public abstract void Create();&#125;/// &lt;summary&gt;/// 窗户抽象类，子类的窗户必须继承该类/// &lt;/summary&gt; public abstract class Window &#123; /// &lt;summary&gt; /// 创建窗户 /// &lt;/summary&gt; public abstract void Create(); &#125; /// &lt;summary&gt; /// 房门抽象类，子类的房门必须继承该类 /// &lt;/summary&gt; public abstract class Door &#123; /// &lt;summary&gt; /// 创建房门 /// &lt;/summary&gt; public abstract void Create(); &#125;/////////////////////////////////////////////////////////////// 具体产品类//////////////////////////////////////////////////////////////// &lt;summary&gt;/// 欧式地板类/// &lt;/summary&gt;public class EuropeanFloor : Floor &#123; public override void Create() &#123; Console.WriteLine("创建欧式的地板"); &#125;&#125; /// &lt;summary&gt; /// 欧式的房顶 /// &lt;/summary&gt; public class EuropeanRoof : Roof &#123; public override void Create() &#123; Console.WriteLine("创建欧式的房顶"); &#125; &#125;/// &lt;summary&gt;///欧式的窗户/// &lt;/summary&gt;public class EuropeanWindow : Window &#123; public override void Create() &#123; Console.WriteLine("创建欧式的窗户"); &#125;&#125;/// &lt;summary&gt;/// 欧式的房门/// &lt;/summary&gt;public class EuropeanDoor : Door &#123; public override void Create() &#123; Console.WriteLine("创建欧式的房门"); &#125;&#125;/// &lt;summary&gt;/// 现代的房顶/// &lt;/summary&gt;public class ModernizationRoof : Roof &#123; public override void Create() &#123; Console.WriteLine("创建现代的房顶"); &#125;&#125;/// &lt;summary&gt;/// 现代的地板/// &lt;/summary&gt;public class ModernizationFloor : Floor&#123; public override void Create() &#123; Console.WriteLine("创建现代的地板"); &#125;&#125; /// &lt;summary&gt;/// 现代的窗户/// &lt;/summary&gt;public class ModernizationWindow : Window&#123; public override void Create() &#123; Console.WriteLine("创建现代的窗户"); &#125; &#125;/// &lt;summary&gt;/// 现代的房门/// &lt;/summary&gt;public class ModernizationDoor : Door&#123; public override void Create() &#123; Console.WriteLine("创建现代的房门"); &#125;&#125; 抽象工厂的实现要点 如果没有应对“多系列对象创建”的需求变化，则没有必要使用AbstractFactory模式，这时候使用简单的静态工厂完全可以。 “系列对象”指的是这些对象之间有相互依赖、或作用的关系，例如游戏开发场景中“道路”与“房屋”的依赖，“道路”与“地道”的依赖。 AbstractFactory模式主要在于应对新系列的需求变动。其缺点在于难以应对“新对象”的需求变动。 AbstractFactory模式经常和FactoryMethod模式共同组合来应对“对象创建”的需求变化。 抽象工厂的优缺点优点【抽象工厂】模式将系列产品的创建工作延迟到具体工厂的子类中，我们声明工厂类变量的时候是使用的抽象类型，同理，我们使用产品类型也是抽象类型，这样做就尽可能的可以减少客户端代码与具体产品类之间的依赖，从而降低了系统的耦合度。耦合度降低了，对于后期的维护和扩展就更有利，这也就是【抽象工厂】模式的优点所在。我们通过配置文件来指定具体的工厂类,把依赖关系放到配置文件中。如果有新的需求我们只需要修改配置文件，根本就不需要修改代码了，让客户代码更稳定。 缺点【抽象工厂】模式很难支持增加新产品的变化，这是因为抽象工厂接口中已经确定了可以被创建的产品集合，如果需要添加新产品，此时就必须去修改抽象工厂的接口，这样就涉及到抽象工厂类的以及所有子类的改变，这样也就违背了“开发——封闭”原则。 使用场景如果系统需要多套的代码解决方案，并且每套的代码方案中又有很多相互关联的产品类型，并且在系统中我们可以相互替换的使用一套产品的时候可以使用该模式，客户端不需要依赖具体实现。比较典型的场景是：例如某个产品支持sql server、oracle、mysql数据库时,就可以考虑使用使用抽象工厂模式。典型的案例是.net中的System.Data.Common.DbProviderFactory,这个类位于System.Data.dll程序集中。该类扮演抽象工厂模式中抽象工厂的角色。]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>创建型</tag>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[YAML语言]]></title>
    <url>%2Fhexo-blog-deploy%2F2018%2F10%2F14%2F2018-10-yaml-note%2F</url>
    <content type="text"><![CDATA[简介YAML是一个可读性高，用来表达资料序列的文件格式。YAML是YAML Ain’t a Markup Language（YAML不是一种标记语言）的缩写 。在开发的这种语言时，YAML 的意思其实是：Yet Another Markup Language（仍是一种标记语言），但为了强调这种语言以数据做为中心，而不是以标记语言为重点，而用反向缩略语重新命名。实际上，它是JSON的一个超集，因此，在使用的时候，你可能需要采用JSON风格的语法来跳出空格流。 YAML的发音为 /ˈjæməl/ ）,设计目标是方便人类读写。它实质上是一种通用的数据串行化格式。YAML主要的作用是用来写配置文件(例如：docker-compose编排文件,string-boot配置文件等),非常简洁和强大。 基本语法规则 大小写敏感 使用缩进表示层级关系 缩进时不允许使用Tab键，只允许使用空格。 缩进的空格数目不重要，只要相同层级的元素左侧对齐即可 Notes # 表示注释，从这个字符一直到行尾，都会被解析器忽略 YAML 支持的数据结构YAML支持的数据结构有三种： 对象：键值对的集合，又称为映射（mapping）/ 哈希（hashes） / 字典（dictionary） 数组：一组按次序排列的值，又称为序列（sequence） / 列表（list） 纯量（scalars）：单个的、不可再分的值 对象对象的一组键值对，使用冒号:结构表示。 1animal: pets Yaml也允许另一种写法，将所有键值对写成一个行内对象:1hash: &#123; name: Steve, foo: bar &#125; 数组一组连词线开头的行，构成一个数组:123- Cat- Dog- Goldfish 数组也可以采用行内表示法:1animal: [Cat, Dog] 数据结构的子成员是一个数组，则可以在该项下面缩进空格:12345- - Cat - Dog - Goldfish# 解析为: [[Cat, Dog, Goldfish]] 复合结构对象和数组可以结合使用，形成复合结构:123456789languages: - Ruby - Perl - Python websites: YAML: yaml.org Ruby: ruby-lang.org Python: python.org Perl: use.perl.org 纯量纯量是最基本的、不可再分的值。 数值数值直接以字面量的形式表示。1number: 12.30 布尔值布尔值用true和false表示。1isSet: true 空值null用~表示。1parent: ~ 日期和时间时间和时间均采用 ISO8601 格式。12iso8601: 2001-12-14t21:59:43.10-05:00 date: 1976-07-31 字符串字符串是最常见，也是最复杂的一种数据类型。 字符串默认不使用引号表示。 1str: 这是一行字符串 如果字符串之中包含空格或特殊字符，需要放在引号之中。 1str: '内容： 字符串' 单引号和双引号都可以使用，双引号不会对特殊字符转义。 123s1: '内容\n字符串's2: "内容\n字符串"# 转为js为: &#123; s1: '内容\\n字符串', s2: '内容\n字符串' &#125; 单引号之中如果还有单引号，必须连续使用两个单引号转义。 1str: 'labor''s day' 字符串可以写成多行，从第二行开始，必须有一个单空格缩进。换行符会被转为空格。 1234str: 这是一段 多行 字符串# 转为js为： &#123; str: '这是一段 多行 字符串' &#125; 多行字符串可以使用|保留换行符，也可以使用&gt;折叠换行。 1234567this: | Foo Barthat: &gt; Foo Bar# 转为js为： &#123; this: 'Foo\nBar\n', that: 'Foo Bar\n' &#125; +表示保留文字块末尾的换行，-表示删除字符串末尾的换行。 1234567891011s1: | Foos2: |+ Foos3: |- Foo# 转为js为： &#123; s1: 'Foo\n', s2: 'Foo\n\n\n', s3: 'Foo' &#125; 字符串之中可以插入 HTML 标记。 123456message: | &lt;p style="color: red"&gt; 段落 &lt;/p&gt;# 转为js为： &#123; message: '\n&lt;p style="color: red"&gt;\n 段落\n&lt;/p&gt;\n' &#125; 引用锚点&amp;和别名*，可以用来引用。&amp;用来建立锚点（defaults），&lt;&lt;表示合并到当前数据，*用来引用锚点1234567891011defaults: &amp;defaults adapter: postgres host: localhostdevelopment: database: myapp_development &lt;&lt;: *defaultstest: database: myapp_test &lt;&lt;: *defaults 等同于下面的代码: 12345678910111213defaults: adapter: postgres host: localhostdevelopment: database: myapp_development adapter: postgres host: localhosttest: database: myapp_test adapter: postgres host: localhost]]></content>
      <categories>
        <category>YAML</category>
      </categories>
      <tags>
        <tag>YAML</tag>
        <tag>配置文件</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[设计模式之工厂方法模式]]></title>
    <url>%2Fhexo-blog-deploy%2F2018%2F10%2F14%2F2018-10-design-pattern-factory-method-note%2F</url>
    <content type="text"><![CDATA[简介工厂方法模式之把具体产品的创建推迟到子类中，此时工厂类不再负责所有产品的创建，而只是给出具体工厂必须实现的接口，这样工厂方法模式就可以允许系统不修改工厂类逻辑的情况下来添加新产品，这样也就克服了简单工厂模式中缺点。 动机在软件系统的构建过程中，经常面临着某个对象的创建工作：由于需求的变化，这个对象（的具体实现）经常面临着剧烈的变化，但是它却拥有比较稳定的接口。如何应对这种变化？如何提供一种“封装机制”来隔离出“这个易变对象”的变化，从而保持系统中“其他依赖对象的对象”不随着需求改变而改变？ 意图定义一个用于创建对象的接口，让子类决定实例化哪一个类。Factory Method使得一个类的实例化延迟到子类。 结构图 模式组成抽象工厂角色Creator:充当抽象工厂角色，定义工厂类所具有的基本的操作，任何具体工厂都必须继承该抽象类。 具体工厂角色ConcreteCreator:充当具体工厂角色，该类必须继承抽象工厂角色，实现抽象工厂定义的方法，用来创建具体产品。 抽象产品角色Product:充当抽象产品角色，定义了产品类型所有具有的基本操作，具体产品必须继承该抽象类。 具体产品角色ConcreteProduct：充当具体产品角色，实现抽象产品类对定义的抽象方法，由具体工厂类创建，它们之间有一一对应的关系。 实现面向对象的重要原则原则就是: 1. 哪里有变化，就封装哪里;2. 面向抽象编程;3. 多组合，少继承。例子:12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394/************************************//***************产品类***************//***********************************//// &lt;summary&gt;/// 汽车抽象类/// &lt;/summary&gt;public abstract class Car&#123; // 开始行驶 public abstract void Go();&#125;/// &lt;summary&gt;/// 红旗汽车/// &lt;/summary&gt;public class HongQiCar : Car&#123; public override void Go() &#123; Console.WriteLine("红旗汽车开始行驶了！"); &#125;&#125;/// &lt;summary&gt;/// 奥迪汽车/// &lt;/summary&gt;public class AoDiCar : Car&#123; public override void Go() &#123; Console.WriteLine("奥迪汽车开始行驶了"); &#125;&#125;/************************************//***************工厂类***************//***********************************//// &lt;summary&gt;/// 抽象工厂类/// &lt;/summary&gt;public abstract class Factory&#123; // 工厂方法 public abstract Car CreateCar();&#125;/// &lt;summary&gt;/// 红旗汽车工厂类/// &lt;/summary&gt;public class HongQiCarFactory:Factory&#123; /// &lt;summary&gt; /// 负责生产红旗汽车 /// &lt;/summary&gt; /// &lt;returns&gt;&lt;/returns&gt; public override Car CreateCar() &#123; return new HongQiCar(); &#125;&#125; /// &lt;summary&gt;/// 奥迪汽车工厂类/// &lt;/summary&gt;public class AoDiCarFactory:Factory&#123; /// &lt;summary&gt; /// 负责创建奥迪汽车 /// &lt;/summary&gt; /// &lt;returns&gt;&lt;/returns&gt; public override Car CreateCar() &#123; return new AoDiCar(); &#125;&#125;/**************************//***********调用**********//************************//// &lt;summary&gt;/// 客户端调用/// &lt;/summary&gt;class Client&#123; static void Main(string[] args) &#123; // 初始化创建汽车的两个工厂 Factory hongQiCarFactory = new HongQiCarFactory(); Factory aoDiCarFactory = new AoDiCarFactory(); // 生产一辆红旗汽车 Car hongQi = hongQiCarFactory.CreateCar(); hongQi.Go(); //生产一辆奥迪汽车 Car aoDi = aoDiCarFactory.CreateCar(); aoDi.Go(); Console.Read(); &#125;&#125; 要点Factory Method模式主要用于隔离类对象的使用者和具体类型之间的耦合关系。面对一个经常变化的具体类型，紧耦合关系会导致软件的脆弱。Factory Method模式通过面向对象的手法，将所要创建的具体对象工作延迟到子类，从而实现一种扩展（而非更改）的策略，较好地解决了这种紧耦合关系。 构建者对象的比较 Factory Method模式解决单个对象的需求变化； AbstractFactory模式解决系列对象的需求变化； Builder模式解决对象部分的需求变化； 优缺点优点 在工厂方法中，用户只需要知道所要产品的具体工厂，无须关系具体的创建过程，甚至不需要具体产品类的类名。 在系统增加新的产品时，我们只需要添加一个具体产品类和对应的实现工厂，无需对原工厂进行任何修改，很好地符合了开闭原则。缺点 每次增加一个产品时，都需要增加一个具体类和对象实现工厂，是的系统中类的个数成倍增加，在一定程度上增加了系统的复杂度，同时也增加了系统具体类的依赖。这并不是什么好事。 工厂方法模式使用的场景 一个类不知道它所需要的对象的类。在工厂方法模式中，我们不需要具体产品的类名，我们只需要知道创建它的具体工厂即可。 一个类通过其子类来指定创建那个对象。在工厂方法模式中，对于抽象工厂类只需要提供一个创建产品的接口，而由其子类来确定具体要创建的对象，在程序运行时，子类对象将覆盖父类对象，从而使得系统更容易扩展。 将创建对象的任务委托给多个工厂子类中的某一个，客户端在使用时可以无须关心是哪一个工厂子类创建产品子类，需要时再动态指定。]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>创建型</tag>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[设计模式之单例模式]]></title>
    <url>%2Fhexo-blog-deploy%2F2018%2F10%2F11%2F2018-10-design-pattern-singleton-note%2F</url>
    <content type="text"><![CDATA[介绍确保一个类只有一个实例,并提供一个全局访问点。 为什么要用单列模式单例模式的使用自然是当我们的系统中某个对象只需要一个实例的情况，例如:操作系统中只能有一个任务管理器,操作文件时,同一时间内只允许一个实例对其操作等,既然现实生活中有这样的应用场景,自然在软件设计领域必须有这样的解决方案了(因为软件设计也是现实生活中的抽象)，所以也就有了单例模式。 适用性 当类只能有一个实例而且客户可以从一个众所周知的访问点访问它时。 当这个唯一实例应该是通过子类化可扩展的，并且客户应该无需更改代码就能使用一个扩展的实例时。 实现思路懒汉式与饿汉式的根本区别在与是否在类内方法外创建自己的对象。并且声明对象都需要私有化，构造方法都要私有化，这样外部才不能通过 new 对象的方式来访问。饿汉式的话是声明并创建对象(因为他饿)，懒汉式的话只是声明对象，在调用该类的 getinstance() 方法时才会进行 new 对象。 单线程Singleton实现(懒汉式,线程不安全)123456789101112131415161718192021222324252627/// &lt;summary&gt; /// 单例模式的实现 /// &lt;/summary&gt; public class Singleton &#123; // 定义一个静态变量来保存类的实例 private static Singleton uniqueInstance; // 定义私有构造函数，使外界不能创建该类实例 private Singleton() &#123; &#125; /// &lt;summary&gt; /// 定义公有方法提供一个全局访问点,同时你也可以定义公有属性来提供全局访问点 /// &lt;/summary&gt; /// &lt;returns&gt;&lt;/returns&gt; public static Singleton GetInstance() &#123; // 如果类的实例不存在则创建，否则直接返回 if (uniqueInstance == null) &#123; uniqueInstance = new Singleton(); &#125; return uniqueInstance; &#125; &#125; 多线程实现(懒汉式,线程安全)12345678910111213141516171819202122232425262728293031323334353637383940/// &lt;summary&gt;/// 单例模式的实现/// &lt;/summary&gt;public class Singleton&#123; // 定义一个静态变量来保存类的实例 private static Singleton uniqueInstance; // 定义一个标识确保线程同步 private static readonly object locker = new object(); // 定义私有构造函数，使外界不能创建该类实例 private Singleton() &#123; &#125; /// &lt;summary&gt; /// 定义公有方法提供一个全局访问点,同时你也可以定义公有属性来提供全局访问点 /// &lt;/summary&gt; /// &lt;returns&gt;&lt;/returns&gt; public static Singleton GetInstance() &#123; // 当第一个线程运行到这里时，此时会对locker对象 "加锁"， // 当第二个线程运行该方法时，首先检测到locker对象为"加锁"状态，该线程就会挂起等待第一个线程解锁 // lock语句运行完之后（即线程运行完之后）会对该对象"解锁" // 双重锁定只需要一句判断就可以了 if (uniqueInstance == null) &#123; lock (locker) &#123; // 如果类的实例不存在则创建，否则直接返回 if (uniqueInstance == null) &#123; uniqueInstance = new Singleton(); &#125; &#125; &#125; return uniqueInstance; &#125;&#125; 静态实现(饿汉式)12345public class Singleton&#123; public static readonly Singleton instance = new Singleton(); private Singleton() &#123; &#125;&#125; 与下面的实现方式相同123456789class Singleton&#123; public static readonly Singleton instance; static Singleton() &#123; instance = new Singleton(); &#125; private Singleton() &#123; &#125;&#125;]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>创建型</tag>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Dotnetty笔记]]></title>
    <url>%2Fhexo-blog-deploy%2F2018%2F10%2F09%2F2018-10-dotnetty-note%2F</url>
    <content type="text"><![CDATA[DotNetty介绍DotNetty是微软的Azure团队，使用C#实现的Netty的版本发布。不但使用了C#和.Net平台的技术特点，并且保留了Netty原来绝大部分的编程接口。让我们在使用时，完全可以依照Netty官方的教程来学习和使用DotNetty应用程序。 dotNetty 是一个非阻塞、事件驱动的网络框架。dotNetty 实际上是使用 Threads（多线程）处理 I/O 事件,DotNetty是一个NIO客户端服务端框架，它使得快速而简单的开发像服务端客户端协议的网络应用成为了可能。它极大的简化并流线化了如TCP和UDP套接字服务器开发的网络编程。dotNetty成功找到了一个无需折衷妥协而让开发、性能、稳定性和灵活性相互协调的方法。 类库简介 DotNetty.Buffers 对内存缓冲区管理的封装。 DotNetty.Codecs 对编解码是封装，包括一些基础基类的实现，在项目中自定义的协议，都要继承该项目的特定基类和实现。 DotNetty.Codecs.Mqtt MQTT（消息队列遥测传输）编解码是封装，包括一些基础基类的实现。 DotNetty.Codecs.Protobuf Protobuf编解码是封装，包括一些基础基类的实现。 DotNetty.Codecs.ProtocolBuffers ProtocolBuffers编解码是封装，包括一些基础基类的实现。 DotNetty.Codecs.Redis Redis协议编解码是封装，包括一些基础基类的实现。 DotNetty.Common 是公共的类库项目，包装线程池，并行任务和常用帮助类的封装。 DotNetty.Handlers 封装了常用的管道处理器，比如Tls编解码，超时机制，心跳检查，日志等。 DotNetty.Transport 是DotNetty核心的实现，Socket基础框架，通信模式：异步非阻塞。 DotNetty.Transport.Libuv 是DotNetty自己实现基于Libuv （高性能的，事件驱动的I/O库） 核心的实现。 架构图 DotNetty核心概念BOOTSTRAPDotNetty 应用程序通过设置 Bootstrap（引导）类的开始，该类提供了一个用于应用程序网络层配置的容器。 CHANNEL底层网络传输API必须提供给应用 I/O操作的接口，如读，写，连接，绑定等等。对于我们来说，这是结构几乎总是会成为一个“socket”。DotNetty 中的接口Channel 定义了与 socket 丰富交互的操作集：bind, close, config, connect, isActive, isOpen, isWritable, read, write 等等。 DotNetty 提供大量的 Channel 实现来专门使用。这些包括 AbstractChannel，AbstractNioByteChannel，AbstractNioChannel，EmbeddedChannel， LocalServerChannel，NioSocketChannel 等等。 CHANNELHANDLERChannelHandler 支持很多协议，并且提供用于数据处理的容器。我们已经知道ChannelHandler 由特定事件触发。 ChannelHandler 可专用于几乎所有的动作，包括将一个对象转为字节（或相反），执行过程中抛出的异常处理。 常用的一个接口是 ChannelInboundHandler，这个类型接收到入站事件（包括接收到的数据）可以处理应用程序逻辑。当你需要提供响应时，你也可以从 ChannelInboundHandler 冲刷数据。一句话，业务逻辑经常存活于一个或者多个 ChannelInboundHandler。 CHANNELPIPELINEChannelPipeline 提供了一个容器给 ChannelHandler 链并提供了一个API 用于管理沿着链入站和出站事件的流动。每个 Channel 都有自己的ChannelPipeline，当Channel 创建时自动创建的。 ChannelHandler 是如何安装在 ChannelPipeline？ 主要是实现了ChannelHandler 的抽象 ChannelInitializer。ChannelInitializer子类 通过 ServerBootstrap 进行注册。当它的方法 InitChannel() 被调用时，这个对象将安装自定义的 ChannelHandler 集到 pipeline。当这个操作完成时，ChannelInitializer 子类则 从 ChannelPipeline 自动删除自身。 EVENTLOOPEventLoop 用于处理 Channel 的 I/O 操作。一个单一的 EventLoop通常会处理多个 Channel 事件。一个 EventLoopGroup 可以含有多于一个的EventLoop 和 提供了一种迭代用于检索清单中的下一个。 CHANNELFUTUREDotNetty 所有的 I/O 操作都是异步。因为一个操作可能无法立即返回，我们需要有一种方法在以后确定它的结果。出于这个目的，dotNetty 提供了接口 ChannelFuture,它的 AddListener 方法注册了一个 ChannelFutureListener ，当操作完成时，可以被通知（不管成功与否）。 引导Bootstrap 类型DotNetty的包括两种不同类型的引导。 两个引导实现自一个名为AbstractBootstrap的超类。 服务端引导“服务器”应用程序把一个“父”管道接受连接和创建“子”管道,ServerBootstrap 中的 ChildHandler(), ChildAttr() 和 ChildOption() 是常用的服务器应用的操作。具体来说,ServerChannel实现负责创建子 Channel,它代表接受连接。因此 引导 ServerChannel 的 ServerBootstrap ,提供这些方法来简化接收的 Channel 对 ChannelConfig 应用设置的任务。下图展示了服务端是如何工作的 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152// 主工作线程组，设置为1个线程 var bossGroup = new MultithreadEventLoopGroup(1); // 工作线程组，默认为内核数*2的线程数 var workerGroup = new MultithreadEventLoopGroup(); X509Certificate2 tlsCertificate = null; if (ServerSettings.IsSsl) //如果使用加密通道 &#123; tlsCertificate = new X509Certificate2(Path.Combine(ExampleHelper.ProcessDirectory, "dotnetty.com.pfx"), "password"); &#125; try &#123; //声明一个服务端Bootstrap，每个Netty服务端程序，都由ServerBootstrap控制， //通过链式的方式组装需要的参数 var bootstrap = new ServerBootstrap(); bootstrap .Group(bossGroup, workerGroup) // 设置主和工作线程组 .Channel&lt;TcpServerSocketChannel&gt;() // 设置通道模式为TcpSocket .Option(ChannelOption.SoBacklog, 100) // 设置网络IO参数等，这里可以设置很多参数，当然你对网络调优和参数设置非常了解的话，你可以设置，或者就用默认参数吧 .Handler(new LoggingHandler("SRV-LSTN")) //在主线程组上设置一个打印日志的处理器 .ChildHandler(new ActionChannelInitializer&lt;ISocketChannel&gt;(channel =&gt; &#123; //工作线程连接器 是设置了一个管道，服务端主线程所有接收到的信息都会通过这个管道一层层往下传输//同时所有出栈的消息 也要这个管道的所有处理器进行一步步处理 IChannelPipeline pipeline = channel.Pipeline; if (tlsCertificate != null) //Tls的加解密 &#123; pipeline.AddLast("tls", TlsHandler.Server(tlsCertificate)); &#125; //日志拦截器 pipeline.AddLast(new LoggingHandler("SRV-CONN"));//出栈消息，通过这个handler 在消息顶部加上消息的长度 pipeline.AddLast("framing-enc", new LengthFieldPrepender(2));//入栈消息通过该Handler,解析消息的包长信息，并将正确的消息体发送给下一个处理Handler，该类比较常用，后面单独说明 pipeline.AddLast("framing-dec", new LengthFieldBasedFrameDecoder(ushort.MaxValue, 0, 2, 0, 2));//业务handler ，这里是实际处理Echo业务的Handler pipeline.AddLast("echo", new EchoServerHandler()); &#125;)); // bootstrap绑定到指定端口的行为 就是服务端启动服务，同样的Serverbootstrap可以bind到多个端口 IChannel boundChannel = await bootstrap.BindAsync(ServerSettings.Port);//关闭服务 await boundChannel.CloseAsync(); &#125; finally &#123;//释放工作组线程 await Task.WhenAll( bossGroup.ShutdownGracefullyAsync(TimeSpan.FromMilliseconds(100), TimeSpan.FromSeconds(1)), workerGroup.ShutdownGracefullyAsync(TimeSpan.FromMilliseconds(100), TimeSpan.FromSeconds(1))); &#125; 创建要给新的 ServerBootstrap 来创建新的 SocketChannel 管道并绑定他们 指定 EventLoopGroup 用于从注册的 ServerChannel 中获取EventLoop 和接收到的管道 指定要使用的管道类 设置子处理器用于处理接收的管道的 I/O 和数据 通过配置引导来绑定管道 客户端引导“客户端”很可能只需要一个单一的、非“父”对所有网络交互的管道。 如何引导客户端？Bootstrap类负责创建管道给客户或应用程序，利用无连接协议和在调用 Bind() 或 Connect() 之后。下图展示了如何工作1234567891011121314151617181920212223242526272829303132var group = new MultithreadEventLoopGroup(); X509Certificate2 cert = null; string targetHost = null; if (ClientSettings.IsSsl) &#123; cert = new X509Certificate2(Path.Combine(ExampleHelper.ProcessDirectory, "dotnetty.com.pfx"), "password"); targetHost = cert.GetNameInfo(X509NameType.DnsName, false); &#125;var bootstrap = new Bootstrap(); bootstrap .Group(group) .Channel&lt;TcpSocketChannel&gt;() .Option(ChannelOption.TcpNodelay, true) .Handler(new ActionChannelInitializer&lt;ISocketChannel&gt;(channel =&gt; &#123; IChannelPipeline pipeline = channel.Pipeline; if (cert != null) &#123; pipeline.AddLast("tls", new TlsHandler(stream =&gt; new SslStream(stream, true, (sender, certificate, chain, errors) =&gt; true), new ClientTlsSettings(targetHost))); &#125; pipeline.AddLast(new LoggingHandler()); pipeline.AddLast("framing-enc", new LengthFieldPrepender(2)); pipeline.AddLast("framing-dec", new LengthFieldBasedFrameDecoder(ushort.MaxValue, 0, 2, 0, 2)); pipeline.AddLast("echo", new EchoClientHandler()); &#125;)); IChannel clientChannel = await bootstrap.ConnectAsync(new IPEndPoint(ClientSettings.Host, ClientSettings.Port)); await clientChannel.CloseAsync(); 创建一个新的 Bootstrap 来创建和连接到新的客户端管道 指定 EventLoopGroup 指定 Channel 实现来使用 设置处理器给 Channel 的事件和数据 连接到远端主机 参考 Netty 实战(精髓) Netty 4.x 用户指南 DotNetty项目基本了解和介绍 Netty源码解析]]></content>
      <categories>
        <category>网络框架</category>
      </categories>
      <tags>
        <tag>开源框架</tag>
        <tag>网络通信</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[设计原则]]></title>
    <url>%2Fhexo-blog-deploy%2F2018%2F10%2F06%2F2018-10-design-discipline-note%2F</url>
    <content type="text"><![CDATA[单一职责原则（Single Responsibility Principle）定义一个类只负责一个功能领域中的相应职责，或者可以定义为：就一个类而言，应该只有一个引起它变化的原因。 解析一个类不能太“累”！在软件系统中，一个类（大到模块，小到方法）承担的职责越多，它被复用的可能性就越小，而且一个类承担的职责过多，就相当于将这些职责耦合在一起，当其中一个职责变化时，可能会影响其他职责的运作，因此要将这些职责进行分离，将不同的职责封装在不同的类中，即将不同的变化原因封装在不同的类中，如果多个职责总是同时发生改变则可将它们封装在同一类中。 单一职责原则是实现高内聚、低耦合的指导方针，它是最简单但又最难运用的原则，需要设计人员发现类的不同职责并将其分离，而发现类的多重职责需要设计人员具有较强的分析设计能力和相关实践经验。 里氏替换原则（Liskov Substitution Principle）定义所有引用基类（父类）的地方必须能透明地使用其子类的对象。 Notes: 严格的表述为:如果对每一个类型为S的对象o1，都有类型为T的对象o2，使得以T定义的所有程序P在所有的对象o1代换o2时，程序P的行为没有变化，那么类型S是类型T的子类型。 解析在软件中将一个基类对象替换成它的子类对象，程序将不会产生任何错误和异常，反过来则不成立，如果一个软件实体使用的是一个子类对象的话，那么它不一定能够使用基类对象。里氏代换原则是实现开闭原则的重要方式之一，由于使用基类对象的地方都可以使用子类对象，因此在程序中尽量使用基类类型来对对象进行定义，而在运行时再确定其子类类型，用子类对象来替换父类对象。 好处增强程序的健壮性，即使增加了子类，原有的子类还可以继续运行。 需要注意的问题 子类的所有方法必须在父类中声明，或子类必须实现父类中声明的所有方法。根据里氏代换原则，为了保证系统的扩展性，在程序中通常使用父类来进行定义，如果一个方法只存在子类中，在父类中不提供相应的声明，则无法在以父类定义的对象中使用该方法。 我们在运用里氏代换原则时，尽量把父类设计为抽象类或者接口，让子类继承父类或实现父接口，并实现在父类中声明的方法，运行时，子类实例替换父类实例，我们可以很方便地扩展系统的功能，同时无须修改原有子类的代码，增加新的功能可以通过增加一个新的子类来实现。里氏代换原则是开闭原则的具体实现手段之一。 在编译阶段，Java、C#编译器会检查一个程序是否符合里氏代换原则，这是一个与实现无关的、纯语法意义上的检查，但编译器的检查是有局限的。 依赖倒置原则（Dependence Inversion Principle）定义抽象不应该依赖于细节，细节应当依赖于抽象。换言之，要针对接口编程，而不是针对实现编程。 解析依赖倒转原则要求我们在程序代码中传递参数时或在关联关系中，尽量引用层次高的抽象层类，即使用接口和抽象类进行变量类型声明、参数类型声明、方法返回类型声明，以及数据类型的转换等，而不要用具体类来做这些事情。为了确保该原则的应用，一个具体类应当只实现接口或抽象类中声明过的方法，而不要给出多余的方法，否则将无法调用到在子类中增加的新方法。 在引入抽象层后，系统将具有很好的灵活性，在程序中尽量使用抽象层进行编程，而将具体类写在配置文件中，这样一来，如果系统行为发生变化，只需要对抽象层进行扩展，并修改配置文件，而无须修改原有系源代码，在不修改的情况下来扩展系统的功能，满足开闭原则的要求。 实现在实现依赖倒转原则时，我们需要 针对抽象层编程，而将具体类的对象通过依赖注入(DependencyInjection, DI)的方式注入到其他对象中，依赖注入是指当一个对象要与其他对象发生依赖关系时，通过抽象来注入所依赖的对象。常用的注入方式有三种，分别是：构造注入，设值注入（Setter注入）和接口注入。构造注入是指通过构造函数来传入具体类的对象，设值注入是指通过Setter方法来传入具体类的对象，而接口注入是指通过在接口中声明的业务方法来传入具体类的对象。这些方法在定义时使用的是抽象类型，在运行时再传入具体类型的对象，由子类对象来覆盖父类对象。 接口隔离原则（Interface Segregation Principle）定义使用多个专门的接口，而不使用单一的总接口，即客户端不应该依赖那些它不需要的接口。 解析当一个接口太大时，我们需要将它分割成一些更细小的接口，使用该接口的客户端仅需知道与之相关的方法即可。每一个接口应该承担一种相对独立的角色，不干不该干的事，该干的事都要干。 接口的含义 一种是指一个类型所具有的方法特征的集合，仅仅是一种逻辑上的抽象； 当把接口理解成一个类型所提供的所有方法特征的集合的时候，这就是一种逻辑上的概念，接口的划分将直接带来类型的划分。可以把接口理解成角色，一个接口只能代表一个角色，每个角色都有它特定的一个接口，此时，这个原则可以叫做 角色隔离原则。 一种是指某种语言具体的“接口”定义，有严格的定义和结构，比如编程语言中的interface。 在面向对象编程语言中，实现一个接口就需要实现该接口中定义的所有方法，因此大的总接口使用起来不一定很方便，为了使接口的职责单一，需要将大接口中的方法根据其职责不同分别放在不同的小接口中，以确保每个接口使用起来都较为方便，并都承担某一单一角色。 接口应该尽量细化，同时接口中的方法应该尽量少，每个接口中只包含一个客户端（如子模块或业务逻辑类）所需的方法即可，这种机制也称为“定制服务”，即为不同的客户端提供宽窄不同的接口。 迪米特法则（Law Of Demeter）定义一个软件实体应当尽可能少地与其他实体发生相互作用。 解析如果一个系统符合迪米特法则，那么当其中某一个模块发生修改时，就会尽量少地影响其他模块，扩展会相对容易，这是对软件实体之间通信的限制，迪米特法则要求限制软件实体之间通信的宽度和深度。 迪米特法则可降低系统的耦合度，使类与类之间保持松散的耦合关系。 在设计系统时，应该尽量减少对象之间的交互，如果两个对象之间不必彼此直接通信，那么这两个对象就不应当发生任何直接的相互作用，如果其中的一个对象需要调用另一个对象的某一个方法的话，可以通过第三者转发这个调用。简言之，就是通过引入一个合理的第三者来降低现有对象之间的耦合度。 对象的朋友迪米特原则通俗的将就是:不要和陌生人说话、只与你的直接朋友通信等，在迪米特法则中，对于一个对象，其朋友包括以下几类： 当前对象本身(this)； 以参数形式传入到当前对象方法中的对象； 当前对象的成员对象； 如果当前对象的成员对象是一个集合，那么集合中的元素也都是朋友； 当前对象所创建的对象。 注意 在类的划分上，应当尽量创建松耦合的类，类之间的耦合度越低，就越有利于复用，一个处在松耦合中的类一旦被修改，不会对关联的类造成太大波及； 在类的结构设计上，每一个类都应当尽量降低其成员变量和成员函数的访问权限； 在类的设计上，只要有可能，一个类型应当设计成不变类； 在对其他类的引用上，一个对象对其他对象的引用应当降到最低。 开闭原则（Open Close Principle）定义一个软件实体应当对扩展开放，对修改关闭。即软件实体应尽量在不修改原有代码的情况下进行扩展。 解析尽量通过扩展软件实体来解决需求变化，而不是通过修改已有的代码来完成变化。一个软件产品在生命周期内，都会发生变化，既然变化是一个既定的事实，我们就应该在设计的时候尽量适应这些变化，以提高项目的稳定性和灵活性。 实现满足开闭原则，需要对系统进行抽象化设计，抽象化是开闭原则的关键。在Java、C#等编程语言中，可以为系统定义一个相对稳定的抽象层，而将不同的实现行为移至具体的实现层中完成。在很多面向对象编程语言中都提供了接口、抽象类等机制，可以通过它们定义系统的抽象层，再通过具体类来进行扩展。如果需要修改系统的行为，无须对抽象层进行任何改动，只需要增加新的具体类来实现新的业务功能即可，实现在不修改已有代码的基础上扩展系统的功能，达到开闭原则的要求。 组合/聚合复用原则（Composite/Aggregate Reuse Principle CARP）定义尽量使用（对象）组合(Has-A)，而非继承(Is-A)。 解析组合/聚合可以使系统更加灵活，降低类与类之间的耦合度，一个类的变化对其他类造成的影响相对较少；其次才考虑继承，在使用继承时，需要严格遵循里氏代换原则，有效使用继承会有助于对问题的理解，降低复杂度，而滥用继承反而会增加系统构建和维护的难度以及系统的复杂度，因此需要慎重使用继承复用。 由于组合或聚合关系可以将已有的对象（也可称为成员对象）纳入到新对象中，使之成为新对象的一部分，因此新对象可以调用已有对象的功能，这样做可以使得成员对象的内部实现细节对于新对象不可见，所以这种复用又称为“黑箱”复用，相对继承关系而言，其耦合度相对较低，成员对象的变化对新对象的影响不大，可以在新对象中根据实际需要有选择性地调用成员对象的操作；合成复用可以在运行时动态进行，新对象可以动态地引用与成员对象类型相同的其他对象。]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
        <tag>设计原则</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[事件总线]]></title>
    <url>%2Fhexo-blog-deploy%2F2018%2F10%2F04%2F2018-10-eventbus-note%2F</url>
    <content type="text"><![CDATA[简介事件总线是对 发布-订阅模式 的一种实现，他是一种集中式事件处理机制，允许不同的组件之间进行彼此通信而又不需要互相依赖，达到一种解耦的目的。 事件本质事件是由事件源和事件处理组成,是对消息的封装，是IDE编程环境为了简化编程而提供的有用的工具。 发布订阅模式定义定义对象间一种 一对多的依赖关系，使得每当一个对象改变状态，则所有依赖于它的对象都会得到通知并被自动更新。 角色 发布方（Publisher）: 也称为被观察者，当状态改变时负责通知所有订阅者。 订阅方（Subscriber）：也称为观察者，订阅事件并对接收到的事件进行处理。 实现方式 简单的实现方式：由Publisher维护一个订阅者列表，当状态改变时循环遍历列表通知订阅者。 委托的实现方式：由Publisher定义事件委托，Subscriber实现委托。 发布订阅模式中有两个关键字，通知和更新。 被观察者状态改变通知观察者做出相应更新。 解决的是当对象改变时需要通知其他对象做出相应改变的问题。 实现事件总线提取事件源抽象一个接口IEvent，用于封装事件。可以是一个空的标识接口，也可以包括EventSource和 EventTime。 123456789101112131415/// &lt;summary&gt;/// 定义事件源接口，所有的事件源都要实现该接口/// &lt;/summary&gt;public interface IEvent&#123; /// &lt;summary&gt; /// 事件发生的时间 /// &lt;/summary&gt; DateTime EventTime &#123; get; set; &#125; /// &lt;summary&gt; /// 触发事件的对象 /// &lt;/summary&gt; object EventSource &#123; get; set; &#125;&#125; 提取事件处理器需要抽象出一个IEventHandler,用于抽象事件处理器，包含一个Handler方法。123456789101112/// &lt;summary&gt; /// 泛型事件处理器接口 /// &lt;/summary&gt; /// &lt;typeparam name="TEventData"&gt;&lt;/typeparam&gt; public interface IEventHandler&lt;TEventData&gt; : IEventHandler where TEventData : IEvent &#123; /// &lt;summary&gt; /// 事件处理器实现该方法来处理事件 /// &lt;/summary&gt; /// &lt;param name="event"&gt;&lt;/param&gt; void HandleEvent(TEvent eventData); &#125; 实现事件总线 事件总线主要定义三个方法，注册、取消注册、事件触发。提供统一的事件注册、取消注册和触发接口 EventBus要接管所有事件的发布和订阅，那它则需要有一个容器来记录事件源和事件处理。那又如何触发呢？有了事件源，我们就自然能找到绑定的事件处理逻辑，通过反射触发,事件总线利用反射完成事件源与事件处理的初始化绑定。 事件总线采用单例设计模式，确保了事件中心的唯一入口。 事件总线维护一个事件源与事件处理的映射字典_eventAndHandlerMapping。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102/// &lt;summary&gt;/// 事件总线/// &lt;/summary&gt;public class EventBus&#123; public static EventBus Default =&gt; new EventBus(); /// &lt;summary&gt; /// 定义线程安全集合 /// &lt;/summary&gt; private readonly ConcurrentDictionary&lt;Type, List&lt;Type&gt;&gt; _eventAndHandlerMapping; public EventBus() &#123; _eventAndHandlerMapping = new ConcurrentDictionary&lt;Type, List&lt;Type&gt;&gt;(); MapEventToHandler(); &#125; /// &lt;summary&gt; ///通过反射，将事件源与事件处理绑定 /// &lt;/summary&gt; private void MapEventToHandler() &#123; Assembly assembly = Assembly.GetEntryAssembly(); foreach (var type in assembly.GetTypes()) &#123; if (typeof(IEventHandler).IsAssignableFrom(type))//判断当前类型是否实现了IEventHandler接口 &#123; Type handlerInterface = type.GetInterface("IEventHandler`1");//获取该类实现的泛型接口 if (handlerInterface != null) &#123; Type eventDataType = handlerInterface.GetGenericArguments()[0]; // 获取泛型接口指定的参数类型 if (_eventAndHandlerMapping.ContainsKey(eventDataType)) &#123; List&lt;Type&gt; handlerTypes = _eventAndHandlerMapping[eventDataType]; handlerTypes.Add(type); _eventAndHandlerMapping[eventDataType] = handlerTypes; &#125; else &#123; var handlerTypes = new List&lt;Type&gt; &#123; type &#125;; _eventAndHandlerMapping[eventDataType] = handlerTypes; &#125; &#125; &#125; &#125; &#125; /// &lt;summary&gt; /// 手动绑定事件源与事件处理 /// &lt;/summary&gt; /// &lt;typeparam name="TEventData"&gt;&lt;/typeparam&gt; /// &lt;param name="eventHandler"&gt;&lt;/param&gt; public void Register&lt;TEventData&gt;(Type eventHandler) &#123; List&lt;Type&gt; handlerTypes = _eventAndHandlerMapping[typeof(TEventData)]; if (!handlerTypes.Contains(eventHandler)) &#123; handlerTypes.Add(eventHandler); _eventAndHandlerMapping[typeof(TEventData)] = handlerTypes; &#125; &#125; /// &lt;summary&gt; /// 手动解除事件源与事件处理的绑定 /// &lt;/summary&gt; /// &lt;typeparam name="TEventData"&gt;&lt;/typeparam&gt; /// &lt;param name="eventHandler"&gt;&lt;/param&gt; public void UnRegister&lt;TEventData&gt;(Type eventHandler) &#123; List&lt;Type&gt; handlerTypes = _eventAndHandlerMapping[typeof(TEventData)]; if (handlerTypes.Contains(eventHandler)) &#123; handlerTypes.Remove(eventHandler); _eventAndHandlerMapping[typeof(TEventData)] = handlerTypes; &#125; &#125; /// &lt;summary&gt; /// 根据事件源触发绑定的事件处理 /// &lt;/summary&gt; /// &lt;typeparam name="TEventData"&gt;&lt;/typeparam&gt; /// &lt;param name="eventData"&gt;&lt;/param&gt; public void Trigger&lt;TEventData&gt;(TEventData eventData) where TEventData : IEventData &#123; List&lt;Type&gt; handlers = _eventAndHandlerMapping[eventData.GetType()]; if (handlers != null &amp;&amp; handlers.Count &gt; 0) &#123; foreach (var handler in handlers) &#123; MethodInfo methodInfo = handler.GetMethod("HandleEvent"); if (methodInfo != null) &#123; object obj = Activator.CreateInstance(handler); methodInfo.Invoke(obj, new object[] &#123; eventData &#125;); &#125; &#125; &#125; &#125;&#125;]]></content>
      <categories>
        <category>微服务</category>
      </categories>
      <tags>
        <tag>事件总线</tag>
        <tag>微服务</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Dockerfile笔记]]></title>
    <url>%2Fhexo-blog-deploy%2F2018%2F10%2F02%2F2018-10-docker-note-dockerfile%2F</url>
    <content type="text"><![CDATA[简介Dockerfile是由一系列命令和参数构成的脚本，这些命令应用于基础镜像并最终创建一个新的镜像。它们简化了从头到尾的流程并极大的简化了部署工作。Dockerfile从FROM命令开始，紧接着跟随者各种方法，命令和参数。其产出为一个新的可以用于创建容器的镜像。 使用Dockerfile定制镜像镜像的定制实际上就是定制每一层所添加的配置、文件。如果我们可以把每一层修改、安装、构建、操作的命令都写入一个脚本，用这个脚本来构建、定制镜像，那么无法重复的问题、镜像构建透明性的问题、体积的问题就都会解决。这个脚本就是Dockerfile。Dockerfile 是一个文本文件，其内包含了一条条的指令(Instruction)，每一条指令构建一层，因此每一条指令的内容，就是描述该层应当如何构建。 使用Dockerfile构建镜像指令详解FROM指定基础镜像所谓定制镜像，那一定是以一个镜像为基础，在其上进行定制。而FROM就是指定基础镜像，因此一个Dockerfile中FROM是必备的指令，并且 必须是第一条指令。 在Docker Store上有非常多的高质量的官方镜像，有可以直接拿来使用的服务类的镜像，如nginx 、 redis 、 mongo 、mysql 等；也有一些方便开发、构建、运行各种语言应用的镜像，如 node 、 openjdk 、 python 等。可以在其中寻找一个最符合我们最终目标的镜像为基础镜像进行定制。 官方镜像中还提供了一些更为基础的操作系统镜像，如ubuntu 、 debian 、 centos 等，这些操作系统的软件库为我们提供了更广阔的扩展空间。 scratch镜像Docker 还存在一个特殊的镜像，名为 scratch 。这个镜像是虚拟的概念，并不实际存在，它表示一个空白的镜像。以scratch为基础镜像的话，意味着你不以任何镜像为基础，接下来所写的指令将作为镜像第一层开始存在。对于 Linux 下静态编译的程序来说，并不需要有操作系统提供运行时支持，所需的一切库都已经在可执行文件里了，因此直接 FROM scratch会让镜像体积更加小巧。 RUN执行命令RUN 指令是用来执行命令行命令的。由于命令行的强大能力，RUN指令在定制镜像时是最常用的指令之一。 Dockerfile中每一个指令都会建立一层，RUN也不例外。每一个RUN的行为，就和刚才我们手工建立镜像的过程一样：新建立一层，在其上执行这些命令，执行结束后， commit 这一层的修改，构成新的镜像。 使用RUN指令的格式12RUN &lt;命令&gt; #shell 格式,这种方式就像直接在命令行中输入的命令一样。RUN ["可执行文件", "参数1", "参数2"] #exec 格式, 这种方式像是函数调用中的格式 需要注意的事项 在撰写Dockerfile的时候，要经常提醒自己，这并不是在写 Shell 脚本，而是在定义每一层该如何构建。Dockerfile 支持Shell 类的行尾添加 \ 的命令换行方式，以及行首#进行注释的格式。良好的格式，比如换行、缩进、注释等，会让维护、排障更为容易，这是一个比较好的习惯。 还可以看到这一组命令的最后添加了清理工作的命令，删除了为了编译构建所需要的软件，清理了所有下载、展开的文件，并且还清理了 apt 缓存文件。这是很重要的一步，之前有说过，镜像是多层存储，每一层的东西并不会在下一层被删除，会一直跟随着镜像。因此镜像构建时，一定要确保每一层只添加真正需要添加的东西，任何无关的东西都应该清理掉。(初学 Docker 制作出了很臃肿的镜像的原因之一，就是忘记了每一层构建的最后一定要清理掉无关文件。) COPY复制文件格式12COPY &lt;源路径&gt;... &lt;目标路径&gt; #命令行格式COPY ["&lt;源路径1&gt;",... "&lt;目标路径&gt;"] # 函数调用格式 &lt;源路径&gt; 可以是多个，甚至可以是 通配符- &lt;目标路径&gt; 可以是容器内的 绝对路径，也可以是相对于工作目录的相对路径（工作目录可以用WORKDIR指令来指定）。目标路径不需要事先创建，如果目录不存在会在复制文件前先行创建缺失目录。 Notes:还需要注意一点，使用COPY指令，源文件的各种元数据都会保留。比如读、写、执行权限、文件变更时间等。这个特性对于镜像定制很有用。特别是构建相关文件都在使用 Git进行管理的时候。 ADD更高级的复制文件ADD指令和COPY的格式和性质基本一致。但是在COPY基础上增加了一些功能。 &lt;源路径&gt; 可以是一个URL 下载后的文件权限自动设置为600 ，如果这并不是想要的权限，那么还需要增加额外的一层RUN进行权限调整。 如果下载的是个压缩包，需要解压缩，也一样还需要额外的一层RUN指令进行解压缩 如果 &lt;源路径&gt; 为一个tar压缩文件的话，压缩格式为gzip , bzip2 以及 xz 的情况下， ADD 指令将会自动解压缩这个压缩文件到 &lt;目标路径&gt; 选择COPY还是ADD指令?所有的文件复制均使用COPY指令，仅在需要自动解压缩的场合使用ADD。 Notes: 建议直接使用RUN指令，然后使用wget 或者curl 工具下载，处理权限、解压缩、然后清理无用文件更合理。 这个功能其实并不实用，而且不推荐使用, Docker 官方的Dockerfile最佳实践文档 中要求，尽可能的使用COPY ，因为 COPY 的语义很明确，就是复制文件而已，而ADD`则包含了更复杂的功能，其行为也不一定很清晰。最适合使用ADD的场合，就是所提及的需要自动解压缩的场合。 ADD指令会令镜像构建缓存失效，从而可能会令镜像构建变得比较缓慢。 CMD容器启动命令Docker 不是虚拟机，容器就是进程。既然是进程，那么在启动容器的时候，需要指定所运行的程序及参数。CMD指令就是用于指定默认的容器主进程的启动命令的。 在运行时可以指定新的命令来替代镜像设置中的这个默认命令。 使用命令 docker run -it ubuntu 的话，会直接进入bash。 可以在运行时指定运行别的命令，如 docker run -it ubuntu cat /etc/os-release 。这就是用 cat /etc/os-release 命令替换了默认的 /bin/bash 命令了，输出了系统版本信息。 CMD执行格式123CMD &lt;命令&gt; # shell 格式CMD ["可执行文件", "参数1", "参数2"...] # exec 格式CMD ["参数1", "参数2"...] # 参数列表格式：在指定了 ENTRYPOINT 指令后，用 CMD 指定具体的参数。 在指令格式上，一般推荐使用exec格式，这类格式在解析时会被解析为 JSON数组，因此一定要使用双引号 &quot; ，而不要使用单引号。 使用 shell 格式的话，实际的命令会被包装为 sh -c 的参数的形式进行执行。 例如:123CMD echo $HOME# 相当于CMD [ "sh", "-c", "echo $HOME" ] Notes: Docker不是虚拟机，容器中的应用都应该以前台执行，而不是像虚拟机、物理机里面那样，用 upstart/systemd 去启动后台服务，容器内没有后台服务的概念。 对于容器而言，其启动程序就是容器应用进程，容器就是为了主进程而存在的，主进程退出，容器就失去了存在的意义，从而退出，其它辅助进程不是它需要关心的东西。 例如:1CMD service nginx start # 容器并不会以守护态运行 正确的做法是直接执行nginx可执行文件，并且要求以前台形式运行1CMD ["nginx", "-g", "daemon off;"] 说明:使用service nginx start 命令，则是希望 systemd 来以后台守护进程形式启动nginx服务。而刚才说了CMD service nginx start 会被理解为 CMD [ &quot;sh&quot;, &quot;-c&quot;, &quot;service nginxstart&quot;] ，因此主进程实际上是 sh 。那么当 service nginx start 命令结束后， sh 也就结束了， sh 作为主进程退出了，自然就会令容器退出。 ENTRYPOINT入口点ENTRYPOINT的目的和CMD一样，都是在指定容器启动程序及参数。 ENTRYPOINT在运行时也可以替代，不过比CMD要略显繁琐，需要通过 docker run 的参数 –entrypoint 来指定。 ENTRYPOINT执行格式ENTRYPOINT 的格式和RUN指令格式一样，分为exec 格式和 shell 格式。12ENTRYPOINT &lt;命令&gt; # shell 格式ENTRYPOINT ["可执行文件", "参数1", "参数2"...] # exec 格式 ENTRYPOINT与CMD指令指定了ENTRYPOINT后，CMD 的含义就发生了改变，不再是直接的运行其命令，而是将CMD的内容作为参数传给ENTRYPOINT指令，换句话说实际执行时，将变为：1&lt;ENTRYPOINT&gt; "&lt;CMD&gt;" 有了CMD命令,为什么还要有ENTRYPOINT 呢？这种 &lt;ENTRYPOINT&gt; &quot;&lt;CMD&gt;&quot; 有什么好处么？ 场景一：让镜像变成像命令一样使用 场景二：应用运行前的准备工作启动容器就是启动主进程，但有些时候，启动主进程前，需要一些准备工作。比如mysql类的数据库，可能需要一些数据库配置、初始化的工作，这些工作要在最终的mysql服务器运行之前解决。 此外，可能希望避免使用root用户去启动服务，从而提高安全性，而在启动服务前还需要以root身份执行一些必要的准备工作，最后切换到服务用户身份启动服务。或者除了服务外，其它命令依旧可以使用root身份执行，方便调试等。 这些准备工作是和容器CMD无关的，无论CMD为什么，都需要事先进行一个预处理的工作。这种情况下，可以写一个脚本，然后放入ENTRYPOINT中去执行，而这个脚本会将接到的参数（也就是 ）作为命令，在脚本最后执行。 共同点 都可以指定shell或exec函数调用的方式执行命令； 当存在多个CMD指令或ENTRYPOINT指令时，只有最后一个生效 差异 CMD指令指定的容器启动时命令可以被docker run指定的命令覆盖，而ENTRYPOINT指令指定的命令不能被覆盖，而是将docker run指定的参数当做ENTRYPOINT指定命令的参数。 CMD指令可以为ENTRYPOINT指令设置默认参数，而且可以被docker run指定的参数覆盖； Notes:CMD指令为ENTRYPOINT指令提供默认参数是基于镜像层次结构生效的，而不是基于是否在同个Dockerfile文件中。意思就是说，如果Dockerfile指定的基础镜像中是ENTRYPOINT指定的启动命令，则该Dockerfile中的CMD依然是为基础镜像中的ENTRYPOINT设置默认参数。 ENV设置环境变量定义了环境变量，那么在后续的指令中，就可以使用这个环境变量。下列指令可以支持环境变量展开： ADD 、 COPY 、 ENV 、 EXPOSE 、 LABEL 、 USER 、 WORKDIR 、 VOLUME 、 STOPSIGNAL 、 ONBUILD 。 可以从这个指令列表里感觉到，环境变量可以使用的地方很多，很强大。通过环境变量，我们可以让一份Dockerfile 制作更多的镜像，只需使用不同的环境变量即可。 设置格式12ENV &lt;key&gt; &lt;value&gt;ENV &lt;key1&gt;=&lt;value1&gt; &lt;key2&gt;=&lt;value2&gt;... ARG构建参数构建参数和ENV的效果一样，都是设置环境变量。所不同的是，ARG 所设置的构建环境的环境变量，在将来容器运行时是不会存在这些环境变量的。但是不要因此就使用ARG保存密码之类的信息，因为 docker history 还是可以看到所有值的。 Dockerfile 中的ARG指令是定义参数名称，以及定义其默认值。该默认值可以在构建命令docker build 中用 --build-arg &lt;参数名&gt;=&lt;值&gt; 来覆盖。 VOLUME 定义匿名卷容器运行时应该尽量保持容器存储层不发生写操作，对于数据库类需要保存动态数据的应用，其数据库文件应该保存于卷(volume)中。为了防止运行时用户忘记将动态文件所保存目录挂载为卷，在 Dockerfile 中，我们可以事先指定某些目录挂载为匿名卷，这样在运行时如果用户不指定挂载，其应用也可以正常运行，不会向容器存储层写入大量数据。 设置格式12VOLUME ["&lt;路径1&gt;", "&lt;路径2&gt;"...]VOLUME &lt;路径&gt; 例子1VOLUME /data 说明:*/data 目录就会在运行时自动挂载为匿名卷，任何向/data中写入的信息都不会记录进容器存储层，从而保证了容器存储层的无状态化。当然，运行时可以覆盖这个挂载设置。 1docker run -d -v mydata:/data xxxx # 这行命令中，就使用了 mydata 这个命名卷挂载到了 /data 这个位置，替代了 Dockerfile 中定义的匿名卷的挂载配置 EXPOSE 声明端口EXPOSE指令是声明运行时容器提供服务端口，这只是一个声明，在运行时并不会因为这个声明应用就会开启这个端口的服务。 格式1EXPOSE &lt;端口1&gt; [&lt;端口2&gt;...] 端口映射要将EXPOSE和在运行时使用 -p &lt;宿主端口&gt;:&lt;容器端口&gt;区分开来。 -p ，是映射宿主端口和容器端口，换句话说，就是将容器的对应端口服务公开给外界访问，而EXPOSE仅仅是声明容器打算使用什么端口而已，并不会自动在宿主进行端口映射。 好处 帮助镜像使用者理解这个镜像服务的守护端口，以方便配置映射； 是在运行时使用随机端口映射时，也就是 docker run -P 时，会自动随机映射 EXPOSE 的端口。 WORKDIR 指定工作目录格式1WORKDIR &lt;工作目录路径&gt; 基本介绍使用WORKDIR指令可以来指定工作目录（或者称为当前目录），以后各层的当前目录就被改为指定的目录，如该目录不存在，WORKDIR 会帮你建立目录 如果需要改变以后各层的工作目录的位置，那么应该使用WORKDIR指令。 USER 指定当前用户格式1USER &lt;用户名&gt; 基本介绍USER指令和WORKDIR 相似，都是改变环境状态并影响以后的层。 WORKDIR是改变工作目录， USER 则是改变之后层的执行RUN ,CMD 以及 ENTRYPOINT 这类命令的身份。当然，和WORKDIR 一样， USER 只是帮助你切换到指定用户而已，这个用户必须是事先建立好的，否则无法切换。123RUN groupadd -r redis &amp;&amp; useradd -r -g redis redisUSER redisRUN [ "redis-server" ] HEALTHCHECK 健康检查格式12HEALTHCHECK [选项] CMD &lt;命令&gt; ：设置检查容器健康状况的命令HEALTHCHECK NONE ：如果基础镜像有健康检查指令，使用这行可以屏蔽掉其健康检查指令 基本介绍HEALTHCHECK指令是告诉 Docker 应该如何进行判断容器的状态是否正常，这是 Docker 1.12 引入的新指令。 和 CMD , ENTRYPOINT 一样，HEALTHCHECK 只可以出现一次，如果写了多个，只有最后一个生效。 选项 interval=&lt;间隔&gt; ：两次健康检查的间隔，默认为 30 秒； timeout=&lt;时长&gt; ：健康检查命令运行超时时间，如果超过这个时间，本次健康检查就被视为失败，默认 30 秒； retries=&lt;次数&gt; ：当连续失败指定次数后，则将容器状态视为 unhealthy ，默认 3 次。 ONBUILD 为他人做嫁衣裳格式1ONBUILD &lt;其它指令&gt; ONBUILD 是一个特殊的指令，它后面跟的是其它指令，比如 RUN , COPY 等，而这些指令，在当前镜像构建时并不会被执行。只有当以当前镜像为基础镜像，去构建下一级镜像的时候才会被执行]]></content>
      <categories>
        <category>docker</category>
      </categories>
      <tags>
        <tag>docker</tag>
        <tag>容器</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Ioc容器之Castle Windsor]]></title>
    <url>%2Fhexo-blog-deploy%2F2018%2F10%2F02%2F2018-10-ioc-castle-windosor-notes-one%2F</url>
    <content type="text"><![CDATA[概念Ioc和Ioc容器的区别IoC 是一个框架使用的设计原则，用来让开发者来扩展框架或使用它创建应用程序。其基本思路是，框架是知道程序员的对象，并对它们进行调用。IoC容器使用上面所述的（简言之）原则管理类。包括，它们的创建，销毁，生命期，配置和依赖关系。这样类并不需要获取并配置它们所依赖的类。这在系统中极大地减少了耦合，并且简化了重用和可测试性。 Notes:Ioc 与 Ioc容器不是同一个概念。那些认为IoC与IoC容器是一个同义词的人导致了一些混乱。如前所述，IoC是一个更广泛的原则。 服务、组件、依赖 服务服务是高等级的。它定义了某个功能、协议所需要的方面，但它不泄漏关于谁、如何、哪里准备了某个功能的任何细节。一般地，服务会被定义为接口。 组件组件和服务有关。服务是一个抽象的术语，但我们处理具体，真实的世界。组件一般是指实现了某个服务的具体的类。 依赖一个组件工作来完成它的服务不是空谈,一个组件完成某项工作（功能）可能会需要其他组件的服务协助，也就是说某个功能可能需要多个组件协同工作（例如: 咖啡店依赖于公用事业公司（电力）提供的服务、他的供应商（以得到豆类，牛奶等），大多数组件将最终委托它们的非必须方面给其他组件）。 组件的创建过程 定位处理器(Locating Handler) 它调用与它相关联的所有ComponentResolvingDelegate，让他们有机会在实际开始之前来影响它的决定。这里有个例子， 什么时候委托传递到Fluent注册API的DynamicParameters方法。（Fluent注册API） 如果未提供内嵌参数，它会检查该组件及其所有强制依赖是否能够解析。如果不能，抛出HandlerException异常。 最后，处理器要求生命期方式管理器解析该组件。 生命期方式管理器有一个它可以重复使用的组件实例，它获得并直接返回该实例返回到处理器。如果没有，它要求它的组件激活器创建一个。 组件激活器组件激活器负责创建组件的实例。各种激活器有各自的实现。当您通过UsingFactoryMethod创建组件时，您提供的委托将被调用以创建实例。工厂支持设施或远程设施有它们自己的一套激活器，用于执行组件的自定义初始化。 发布政策处理器调用发布政策以跟踪组件，然后将组件传递给容器，容器将组件返回给用户多数时候你应该使用 DefaultComponentActivator 依赖是如何解析的Windsor 中的组件很少是独立的。毕竟，Windsor 最主要的任务是查找和管理依赖。 依赖解析器（Dependency Resolver）Windsor 使用依赖解析器（实现IDependencyResolver接口的类型）解析组件的依赖。默认依赖解析器（DefaultDependencyResolver 类）。 创建上下文（Creation Context）首先依赖解析器为依赖调用CreationContext。创建上下文 首先尝试用名称解析依赖（传递给 Resolve 的参数: container.Resolve&lt;IFoo&gt;(new Arguments(new { inlineDependency = &quot;its value&quot; }));） 然后通过使用内联提供的依赖的类型(通过 Fluent 注册 API 的方法 DynamicParameters传递的参数)。 没有内联参数能够满足依赖，解析器询问处理器是否能够满足 首先尝试通过名字解析依赖 然后通过类型 上面那些地方都不能解析依赖，解析器询问它的每一个子解析器（实现(ISubDependencyResolver)）是否能够提供依赖 上面那些都不能解析依赖，容器尝试自己解析。根据依赖的类型，容器尝试下面的步骤 对于参数依赖，容器尝试检查 ComponentModel的 Parameters 集合以匹配依赖。包括 XML 提供的参数，或通过 Fluent API 的 Parameters 方法传递的参数。 对于 service override dependency，容器尝试通过指定关键字匹配组件。 对于服务依赖，容器将会尝试通过指定关键字匹配任意一个组件 如果上面都不行，抛出DependencyResolverException异常 使用容器三个容器调用模式IoC 框架与其他框架不同之处在于你不会在代码中看见许多对框架的调用，在大多数应用中（忽略它们的大小和复杂性）你仅在三个地方直接调用容器。该模式被称为 Three Calls。有时被称为 RRR - 注册，解析，释放（Register, Resolve, Release）。在应用中应用容器只需要在三个地方调用容器。更精确的说，在入口项目。 使用容器的一个非常重要的方面-在应用中有一个应用实例。你只需要一个单独的，容器的根容器实例。在一些非常罕见的高级场景，你可能会创建“子”容器，但是它们都与那个单一的无处不在的根容器栓在一起，作为子容器。 Call one - 引导程序（bootstrapper）在引导程序中创建和配置容器。 例如:123456789public IWindsorContainer BootstrapContainer()&#123; return new WindsorContainer() .Install( Configuration.FromAppConfig(), FromAssembly.This() //perhaps pass other installers here if needed );&#125; 在引导程序中需要做的事: 创建将要使用的容器。 需要的话自定义容器( 大多数时候你不会这样做，通常是从不)。 注册所有容器将要管理的所有组件。即上面代码中 Install 方法的调用。这里你传递 封装有关应用程序的特定组件的所有信息的安装器 。这就是你将要看到的大部分工作。 Call two - Resolve显式从容器解析的全部组件。容器然后构造它们的依赖和依赖的依赖等等的整个图。 123var container = BootstrapContainer();var shell = container.Resolve&lt;IShell&gt;();shell.Display(); Call three - Dispose容器管理组件的整个生命期，并且在关闭应用之前我们需要关闭容器，这将反过来停用它管理的所有组件（比如回收它们）。这就是为什么在关闭应用之前调用container.Dispose()是如此重要。 Windsor 安装器（Installers）简介Windsor使用安装器 (实现 IWindsorInstaller 接口的类型) 封装和分离你的注册逻辑，一些帮助类，比如 Configuration 和FromAssembly使得安装工作轻而易举。 IWindsorInstaller 接口安装器是实现了IWindsorInstaller接口的简单类型。 该接口只有一个Install方法。该方法获得容器的实例，然后就可以使用Fluent注册API注册组件。 12345678910public class RepositoriesInstaller : IWindsorInstaller&#123; public void Install(IWindsorContainer container, IConfigurationStore store) &#123; container.Register(AllTypes.FromAssemblyNamed("Acme.Crm.Data") .Where(type =&gt; type.Name.EndsWith("Repository")) .WithService.DefaultInterfaces() .Configure(c =&gt; c.LifeStyle.PerWebRequest)); &#125;&#125; 分离安装器: 通常一个单独的安装器安装相关服务的连续闭集（比如仓储，控制器，等等），每个集合都有一个独立的安装器。 使用安装器在创建安装器之后，你必须在启动程序中将它们安装到容器。为此，使用容器的Install方法 123456var container = new WindsorContainer();container.Install( new ControllersInstaller(), new RepositoriesInstaller(), // and all your other installers); FromAssembly帮助类通过使用FromAssembly 类，将事情留给 Windsor 完成。这个类有一些选择一个或多个程序集的方法，然后它会实例化那些程序集中的所有安装器类型。这样做的好处是，当你为这些程序集添加新的安装器时，它们会被 Windsor 自动选中，你不需要做额外的工作。 123456container.Install( FromAssembly.This(), FromAssembly.Named("Acme.Crm.Bootstrap"), FromAssembly.Containing&lt;ServicesInstaller&gt;(), FromAssembly.InDirectory(new AssemblyFilter("Extensions")), FromAssembly.Instance(this.GetPluginAssembly())); Notes 在使用FromAssembly时，你不应该依赖安装器将会被实例化或安装的顺序。它是不确定的，意味着你不会知道执行的顺序。 如果你需要以指定顺序安装安装器，使用 InstallerFactor InstallerFactory帮助类如果需要更严格的控制程序集的安装器（影响安装的顺序，改变实例化方式或只安装一部分，而不是全部），你可以从这个类派生，并提供你自己的实现去实现这些目标。 Configuration 类可以用它来访问AppDomain配置文件（的app.config或web.config文件）中的配置，或任意的XML文件12345container.Install( Configuration.FromAppConfig(), Configuration.FromXmlFile("settings.xml"), Configuration.FromXml(new AssemblyResource("assembly://Acme.Crm.Data/Configuration/services.xml"))); 注册 API 引用注册 API 提供注册和配置组件的Fluent方法。这是推荐的注册方式，比过细的XML注册更好。因为它是强类型的且容易被重构，它可以作为XML配置的替代方式或补充。和XML一起使用更为有利。 一个一个的注册组件 按照约定注册组件 使用XML配置 AOP，代理，和拦截器Windsor 可以通过使用拦截器DynamicProxy实现切面编程。 如何创建代理不需要显式指定希望一个组件成为代理。Windsor 将会自动创建代理，如果下面的任何一个条件被满足： 有为该组件指定的拦截器（即包含通过组件拦截器选择器动态选择的拦截器）。 有为该组件指定的 mixins 有为该组件指定的其他接口 指定拦截器 使用 Fluent 注册 API 使用 XML 配置 使用 Attributes (just for interceptors) – InterceptorAttribute 使用InterceptorAttribute需要注意的事项12345678910111213public interface IOrderRepository&#123; Order GetOrder(Guid id);&#125;[Interceptor("cache")][Interceptor(typeof(LoggingInterceptor))]public class OrderRepository: IOrderRepository&#123; Order GetOrder(Guid id) &#123; // some implementation &#125;&#125; 将特性放在组件类上，而不是接口。 可以通过类上面的多个特性指定多个拦截器。 可以通过类型或名称指定拦截器。 使用拦截器1234container.Register( Component.For&lt;LoggingInterceptor&gt;().Lifestyle.Transient, Component.For&lt;CacheInterceptor&gt;().Lifestyle.Transient.Named("cache"), Component.For&lt;IOrderRepository&gt;().ImplementedBy&lt;OrderRepository&gt;()); notes:拦截器应该是临时的： 强烈建议总是让拦截器是临时的。因为拦截器可以拦截多个使用不同生命期方式的组件，最好是让拦截器自身的寿命不超过它们拦截的组件。因此除非有充足的理由不这么做，总是让拦截器是临时的 组件的生命周期生命周期类型标准生命期类型: 常见类型 单例（Singleton）单例组件在一个容器中只有一个实例。实例将在第一次请求时被创建，随后每次需要时都进行重用。显式释放单例（通过调用container.Release(mySingleton)）什么都不会做。这个实例将会在它注册的容器销毁时释放。 Notes:单例是默认的生命期类型，将会在未显式指定的时候使用 瞬态(Transient)Transient组件不会绑定到任何作用域。每次需要Transient组件的实例时，容器都会产生一个新的实例，而不会重用它们。可以说Transient组件的作用域有它的使用者决定。因此当使用Transient组件的对象释放时，它们也被释放。 Notes: 为了确保正确的组件生命周期管理，Windsor 可能跟踪这些组件。 这意味着，除非你释放它们，否则垃圾收集器将无法收回它们，这最终导致事实上的内存泄漏,记住释放那些你显式解析的。 当你想控制组件的生命期时，transient是一个好选择。当你每次都需要全新的实例时。当然 transient组件不需要是线程安全的，除非你将在多线程条件下使用。在大多数程序中你会发现你大多数的组件最后都是transient的。 每次Web请求（PerWebRequest）组件的实例会在一个单一的Web请求范围内共享。该实例将在Web请求的范围第一次请求时创建。显式释放它是无效的。实例将在web请求结束时释放。 Notes: 注册PerWebRequestLifestyleModule: 为了PerWebRequest的正常运行需要将一个IHttpModule - Castle.MicroKernel.Lifestyle.PerWebRequestLifestyleModule注册到 web.config 文件中: 123&lt;httpModules&gt; &lt;add name="PerRequestLifestyle" type="Castle.MicroKernel.Lifestyle.PerWebRequestLifestyleModule, Castle.Windsor"/&gt;&lt;/httpModules&gt; 标准生命期类型: 不常见类型 范围（Scoped） Bound如果默认选项不能满足你的需求，你可以提供自定义方式以选择要绑定的组件，使用下面BoundTo方法的重载。 生命周期Windsor 是一个控制组件创建和销毁的工具。 创建 - 所有的事情都在container.Resolve 或类似的方法内发生 (查看组件是如何创建的以了解详情)。 使用 - 在你的代码中使用组件完成工作。 销毁 - 所有的事情在container.ReleaseComponent之内/或之后或组件的生命期范围结束时发生。 扩展容器设施(Facilities)设施是扩展容器的主要方式。使用设施 可以将外部框架与容器集成，比如WCF 或 NHibernate，为容器添加新的功能，比如事件连接（event wiring），事务支持（transaction support）……，或为组件（synchronization, startable semantics…） 如何使用设施在使用设施前需要将其注册到容器，通过代码（如下所示）或者XML 配置。1container.AddFacility&lt;TypedFactoryFacility&gt;();]]></content>
      <categories>
        <category>ioc容器</category>
      </categories>
      <tags>
        <tag>Ioc</tag>
        <tag>依赖注入</tag>
        <tag>开源组件</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Docker之基础]]></title>
    <url>%2Fhexo-blog-deploy%2F2018%2F10%2F01%2F2018-10-docker-note-summary%2F</url>
    <content type="text"><![CDATA[什么是Docker?Docker是一个开源的项目,它基于Go语言实现。 项目后来加入了 Linux 基金会，遵从了 Apache 2.0 协议，项目代码在 GitHub 上进行维护。Docker项目的 目标是 实现轻量级的操作系统虚拟化解决方案。 Docker 的基础是Linux容器（LXC）等技术。 在LXC的基础上 Docker 进行了进一步的封装，让用户不需要去关心容器的管理，使得操作更为简便。用户操作Docker的容器就像操作一个快速轻量级的虚拟机一样简单。 Docker和传统虚拟机的比较 虚拟机 Docker Docker适用的场景官网上还有这么一句话”Docker is an open platform for developers and sysadmins to build, ship, and run distributed applications, whetheron laptops, data center VMs, or the cloud.”， 可以概括为: Build Once,Run AnyWhere.(构建一次,在任意地方运行)，通常应用如下场景: web应用的自动化打包和发布； 自动化测试和持续集成、发布； 在服务型环境中部署和调整数据库或其他的后台应用； 从头编译或者扩展现有的OpenShift或Cloud Foundry平台来搭建自己的PaaS环境。 Docker版本Docker社区版(DockerCE)Docker社区版（Docker CE）是开发人员和小团队的理想选择，希望开始使用Docker并尝试使用基于容器的应用程序。Docker CE在许多平台上可用，从桌面到云端到服务器。Docker CE可用于macOS和Windows，并提供本地体验，以帮助您专注于学习Docker。您可以在单一环境中构建和共享容器并自动化开发管道。 Docker企业版(Docker EE)Docker企业版（Docker EE）专为企业开发和IT团队而设计，这些团队在规模生产中构建，运送和运行关键业务应用程序。Docker EE集成，认证和支持，为企业提供业界最安全的集装箱平台，使所有应用程序现代化。Docker CE具有稳定和边缘通道。 镜像介绍一个只读层被称为镜像(Image)，一个镜像是永久不变的。由于 Docker 使用一个统一文件系统，Docker 进程认为整个文件系统是以读写方式挂载的。 但是所有的变更都发生顶层的可写层，而下层的原始的只读镜像文件并未变化。由于镜像不 可写，所以镜像是无状态的。 父镜像每一个镜像都可能依赖于由一个或多个下层的组成的另一个镜像。我们有时说，下层那个镜像是上层镜像的父镜像。 基础镜像一个没有任何父镜像的镜像，谓之基础镜像。 镜像ID所有镜像都是通过一个 64 位十六进制字符串 （内部是一个 256 bit 的值）来标识的。 为简化使用，前 12 个字符可以组成一个短ID，可以在命令行中使用。短ID还是有一定的 碰撞机率，所以服务器(Docker Hub)总是返回长ID。 获取镜像可以使用 docker pull 命令来从仓库(Docker Hub)获取所需要的镜像。例如:1$ sudo docker pull ubuntu:12.04 由于防火长城的原因，如果从官方仓库中喜爱在较慢，可以从其他仓库下载。从其它仓库下载时需要指定完整的仓库注册服务器地址。 1$ sudo docker pull dl.dockerpool.com:5000/ubuntu:12.04 列出本地镜像使用 docker images 显示本地已有的镜像。例如:1234PS C:\Users\Administrator&gt; docker imagesREPOSITORY TAG IMAGE ID CREATED SIZEdemo lasted 66c0412035cd 18 hours ago 494MBdemo1 dev 6ed4d19a9352 18 hours ago 494MB 列出的镜像信息字段说明: REPOSITORY 来自于哪个仓库，比如 ubuntu TAG镜像的标记，比如 14.04 IMAGE ID它的 ID 号（唯一）,如果镜像Id相同，就说明是同一个镜像 CREATED创建时间 SIZE镜像大小 创建镜像通过现有的容器修改创建当修改了一个运行中的容器后，使用 docker commit 命令来提交更新后的副本。1sudo docker commit -m "Added json gem" -a "Docker Newbee" 0b2616b0e5a8 ouruser/sinatra:v2 -m 来指定提交的说明信息，跟我们使用的版本控制工具一样； -a 可以指定更新的用户信息；之后是用来创建镜像的容器的 ID； 最后指定目标镜像的仓库名和 tag 信息。 创建成功后会返回这个镜像的 ID 信息。 Notes 在开发过程中不推荐使用该种方式维护镜像，因为这么做修改镜像非常不方便，且不容易分享，在开发过程中，一般使用Dockerfile来维护Docker 镜像。 利用 Dockerfile 来创建镜像通过创建文件Dockerfile和指令维护镜像。 123456# This is a commentFROM ubuntu:14.04MAINTAINER Docker Newbee &lt;newbee@docker.com&gt;RUN apt-get -qq updateRUN apt-get -qqy install ruby ruby-devRUN gem install sinatra Dockerfile 中每一条指令都创建镜像的一层。编写完成 Dockerfile 后可以使用 docker build 来生成镜像。 1$sudo docker build -t="ouruser/sinatra:v2" . -t 标记来添加 tag，指定新的镜像的用户信息。 . 是 Dockerfile 所在的路径（当前目录），也可以替换为一个具体的 Dockerfile 的路径。 Notes注意一个镜像不能超过 127 层 从本地文件系统导入从本地文件系统导入一个镜像，可以使用 openvz（容器虚拟化的先锋技术）的模板来创建： openvz 的模板下载地址为 templates。例如:先下载了一个 ubuntu-14.04 的镜像，之后使用以下命令导入 1sudo cat ubuntu-14.04-x86_64-minimal.tar.gz |docker import - ubuntu:14.04 存入和载入镜像存出镜像如果要导出镜像到本地文件，可以使用 docker save 命令。 1$sudo docker save -o ubuntu_14.04.tar ubuntu:14.04 载入镜像可以使用 docker load 从导出的本地文件中再导入到本地镜像库,这将导入镜像以及其相关的元数据信息（包括标签等）123$ sudo docker load --input ubuntu_14.04.tar# 或$ sudo docker load &lt; ubuntu_14.04.tar 移除本地镜像使用 docker rmi 命令 Notes在删除镜像之前要先用 docker rm 删掉依赖于这个镜像的所有容器。 镜像的实现原理每个镜像都由很多层次构成，Docker 使用Union FS将这些不同的层结合到一个镜像中。通常 Union FS 有两个用途： 一方面可以实现不借助LVM、RAID 将多个 disk 挂到同一个目录下 另一个更常用的就是将一个只读的分支和一个可写的分支联合在一起，Live CD 正是基于此方法可以允许在镜像不变的基础上允许用户在其上进行一些写操作。 容器容器的核心为所执行的应用程序,所需要的资源都是应用程序运行所必需的。除此之外，并没有其它的资源。这种特点使得 Docker 对资源的利用率极高，是货真价实的轻量级虚拟化。 启动容器启动容器有两种方式: 新建并启动命令: docker run1sudo docker run ubuntu:14.04 /bin/echo 'Hello world' 启动并进入容器内部:1sudo docker run -t -i ubuntu:14.04 /bin/bash Notes: -t 选项让Docker分配一个伪终端（pseudo-tty）并绑定到容器的标准输入上 -i 则让容器的标准输入保持打开 使用docker run创建容器时,docker在后台的操作包括: 检查本地是否存在指定的镜像，不存在就从公有仓库下载 利用镜像创建并启动一个容器 分配一个文件系统，并在只读的镜像层外面挂载一层可读写层 从宿主主机配置的网桥接口中桥接一个虚拟接口到容器中去 从地址池配置一个 ip 地址给容器 执行用户指定的应用程序 执行完毕后容器被终止 启动已终止容器利用 docker start 命令，直接将一个已经终止的容器启动运行。利用 docker restart 命令会将一个运行态的容器终止，然后再重新启动它 守护态运行更多的时候，需要让 Docker 容器在后台以守护态（Daemonized）形式运行。此时，可以通过添加-d参数来实现。 终止容器 可以使用docker stop来终止一个运行中的容器。 当Docker容器中指定的应用终结时，容器也自动终止。 终止状态的容器可以用 docker ps -a 命令看到。 进入容器在使用 -d 参数时，容器启动后会进入后台。 某些时候需要进入容器进行操作。 Notes只用处于运行中的容器才可能进入到容器内部 利用attach命令进入容器内部docker attach 是Docker自带的命令，通过指定的容器Id、容器名称进入到容器内部。使用attach命令的缺陷: 当多个窗口同时attach到同一个容器的时候，所有窗口都会同步显示。当某个窗口因命令阻塞时,其他窗口也无法执行操作了 使用nsenter工具 如果系统中没有存在nsenter命令，需要先安装nsenter工具。 使用：nsenter 可以访问另一个进程的名字空间。nsenter 要正常工作需要有root权限。 为了连接到容器，你还需要找到容器的第一个进程的PID，可以通过下面的命令获取 1PID=$(docker inspect --format "&#123;&#123; .State.Pid &#125;&#125;" &lt;container&gt;) 通过这个 PID，就可以连接到这个容器： 1nsenter --target $PID --mount --uts --ipc --net --pid .bashrc_docker下载 .bashrc_docker，并将内容放到 .bashrc 中12$ wget -P ~ https://github.com/yeasy/docker_practice/raw/master/_local/.bashrc_docker;$ echo "[ -f ~/.bashrc_docker ] &amp;&amp; . ~/.bashrc_docker" &gt;&gt; ~/.bashrc; source ~/.bashrc 然后通过docker-enter可以进入容器或直接在容器内执行命令 导出和导入容器导出容器快照导出本地某个容器，可以使用docker export命令。1sudo docker export &lt;containerid&gt; &gt; ubuntu.tar 导入容器快照使用docker import从容器快照文件中再导入为镜像。123cat ubuntu.tar | sudo docker import - test/ubuntu:v1.0# 也可以通过指定 URL 或者某个目录来导入sudo docker import http://example.com/exampleimage.tgz example/imagerepo Notes:用户既可以使用 docker load 来导入镜像存储文件到本地镜像库，也可以使用 docker import 来导入一个容器快照到本地镜像库区别: 容器快照文件将丢弃所有的历史记录和元数据信息（即仅保存容器当时的快照状态），而镜像存储文件将保存完整记录，体积也要大。 从容器快照文件导入时可以重新指定标签等元数据信息 删除容器使用 docker rm 来删除一个处于终止状态的容器 Notes如果要删除一个运行中的容器，可以添加 -f参数。Docker 会发送 SIGKILL 信号给容器 Docker 注册表和仓库Docker Registry简介我们需要一个集中的存储、分发镜像的服务，Docker Registry就是这样的服务。 一个 Docker Registry 中可以包含多个仓库（Repository）；每个仓库可以包含多个标签（Tag）；每个标签对应一个镜像。 一个仓库会包含同一个软件不同版本的镜像，而标签就常用于对应该软件的各个版本。我们可以通过 &lt;仓库名&gt;:&lt;标签&gt; 的格式来指定具体是这个软件哪个版本的镜像。如果不给出标签，将以latest作为默认标签。 仓库名经常以 两段式路径 形式出现，比如 jwilder/nginx-proxy，前者往往意味着 Docker Registry 多用户环境下的用户名，后者则往往是对应的软件名。但这并非绝对，取决于所使用的具体 Docker Registry 的软件或服务。 Docker Registry 公开服务Docker Registry 公开服务是开放给用户使用、允许用户管理镜像的 Registry 服务。一般这类公开服务允许用户免费上传、下载公开的镜像，并可能提供收费服务供用户管理私有镜像。 Docker HubDocker是默认的Docker Registry，也是官方提供的默认Docker Registry，拥有大量的高质量的官方镜像。除此以外，还有 CoreOS 的 Quay.io，CoreOS 相关的镜像存储在这里。 国内的一些云服务商提供了针对 Docker Hub 的镜像服务（Registry Mirror），这些镜像服务被称为加速器。常见的有 阿里云加速器、DaoCloud 加速器 等。使用加速器会直接从国内的地址下载 Docker Hub 的镜像，比直接从 Docker Hub 下载速度会提高很多 修改默认的Docker Registry Linux系统 单次修改 1234# 格式docker pull registry.docker-cn.com/myname/myrepo:mytag# 例如docker pull registry.docker-cn.com/library/ubuntu:16.04 永久修改修改：/etc/docker/daemon.json增加如下内容 123&#123; "registry-mirrors": ["https://registry.docker-cn.com"]&#125; Windows系统 私有 Docker Registry用户还可以在本地搭建私有Docker Registry。Docker 官方提供了Docker Registry镜像，可以直接使用做为私有 Registry 服务]]></content>
      <categories>
        <category>docker</category>
      </categories>
      <tags>
        <tag>docker</tag>
        <tag>容器</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Ioc容器之Ninject]]></title>
    <url>%2Fhexo-blog-deploy%2F2018%2F09%2F29%2F2018-11-ioc-ninject-note%2F</url>
    <content type="text"><![CDATA[简介Ninject是一个快如闪电、超轻量级的基于.Net平台的IOC容器，主要用来解决程序中模块的耦合问题，它的 目的在于做到最少配置。 如果不喜欢配置，不喜欢重量级的IOC框架，在这种场景下就可以选择Ninject框架。 Ninject用法 使用Ninject需要通过nuget工具安装Ninject包 继承Ninject.Modules.NinjectModule,实现自己的模块,并通过重写Load()方法实现依赖注入(DI)。 12345678public class MyModule : Ninject.Modules.NinjectModule&#123; public override void Load() &#123; Bind&lt;ILogger&gt;().To&lt;FileLogger&gt;(); Bind&lt;ILogger&gt;().To&lt;DBLogger&gt;(); &#125;&#125; 通过StandardKernel加载模块和解析对象。 12345678private static IKernel kernel = new StandardKernel(new MyModule());static void Main(string[] args)&#123; ILogger logger = kernel.Get&lt;ILogger&gt;();//获取的是FileLogger logger.Write(' Hello Ninject!'); Console.Read();&#125; Ninject常用方法属性说明 Bind().To()就是接口IKernel的方法，把某个类绑定到某个接口，T1代表的就是接口或者抽象类，而T2代表的就是其实现类。 Get()获取某个接口的实例 Bind().To().WithPropertyValue(‘SomeProprity’, value);在绑定接口的实例时，同时给实例NinjectTester的属性赋值 1ninjectKernel.Bind&lt;ITester&gt;().To&lt;NinjectTester&gt;().WithPropertyValue(&apos;_Message&apos;, &apos;这是一个属性值注入&apos;); Bind().To(). WithConstructorArgument(‘someParam’, value);为实例的构造方法所用的参数赋值 Bind().ToConstant()意思是绑定到某个已经存在的常量 Bind().ToSelf()该方法是绑定到自身，但是这个绑定的对象只能是具体类，不能是抽象类。为什么要自身绑定呢？其实也就是为了能够利用Ninject解析对象本身而已。 12ninjectKernel.Bind&lt;StudentRepository&gt;().ToSelf();StudentRepository sr = ninjectKernel.Get&lt;StudentRepository&gt;(); Bind().To().WhenInjectedInto()这个方法是条件绑定，就是说只有当注入的对象是某个对象的实例时才会将绑定的接口进行实例化 Bind().To().InTransientScope()或者Bind().To().InSingletonScope()为绑定的对象指明生命周期 Load()方法Load()方法其实是抽象类Ninject.Modules.NinjectModule的一个抽象方法，通过重写Load()方法可以对相关接口和类进行集中绑定。 Inject属性可以通过在构造函数、属性和字段上加 Inject特性指定注入的属性、方法和字段等，如果没有在构造函数上指定Inject特性，则默认选择第一个构造函数 1234567891011121314151617181920212223public class MessageDB: IMessage&#123; public MessageDB() &#123; &#125; public MessageDB(object msg) &#123; Console.WriteLine('使用了object 参数构造：&#123;0&#125;',msg); &#125; [Inject] public MessageDB(int msg) &#123; Console.WriteLine('使用了int参数构造：&#123;0&#125;',msg); &#125; public string GetMsgNumber() &#123; return '从数据中读取消息号!'; &#125;&#125; ASP.NET MVC与Ninject 继承DefaultControllerFactory，重载GetControllerInstance方法，实现自己的NinjectControllerFactory类 1234567891011121314151617public class NinjectControllerFactory : DefaultControllerFactory&#123; private IKernel ninjectKernel; public NinjectControllerFactory() &#123; ninjectKernel = new StandardKernel(); AddBindings(); &#125; protected override IController GetControllerInstance(RequestContext requestContext, Type controllerType) &#123; return controllerType == null ? null : (IController)ninjectKernel.Get(controllerType); &#125; private void AddBindings() &#123; ninjectKernel.Bind&lt;IStudentRepository&gt;().To&lt;StudentRepository&gt;(); &#125;&#125; 在函数Application_Start() 注册自己的控制器工厂类 123456789101112131415public class MvcApplication : System.Web.HttpApplication&#123; protected void Application_Start() &#123; AreaRegistration.RegisterAllAreas(); WebApiConfig.Register(GlobalConfiguration.Configuration); FilterConfig.RegisterGlobalFilters(GlobalFilters.Filters); RouteConfig.RegisterRoutes(RouteTable.Routes); BundleConfig.RegisterBundles(BundleTable.Bundles); AuthConfig.RegisterAuth(); //设置控制器工厂生产类为自己定义的NinjectControllerFactory ControllerBuilder.Current.SetControllerFactory(new NinjectControllerFactory()); &#125;&#125; 最后添加控制器，并注入依赖代码 Asp.net Core 与Ninject参考资料 ASP.NET MVC IOC 之Ninject攻略]]></content>
      <categories>
        <category>ioc容器</category>
      </categories>
      <tags>
        <tag>Ioc</tag>
        <tag>依赖注入</tag>
        <tag>开源组件</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Ioc容器之Autofac]]></title>
    <url>%2Fhexo-blog-deploy%2F2018%2F09%2F26%2F2018-09-ioc-autofac-note%2F</url>
    <content type="text"><![CDATA[术语控制反转控制反转(Inversion of Control，缩写为IoC)，面向对象编程中的一种设计原则，用来减低计算机代码之间的耦合度。借助于”第三方[即IOC容器]”实现具有依赖关系的对象之间的解耦(责任的反转)。 通过引入第三方的Ioc容器，使得对象与对象之间没有了耦合性，全部对象的控制权全部上缴给第三方的IOC容器，所以，Ioc容器成为了真个系统的关键核心，它起到了一种类似“粘合剂”的作用，把系统中的所有对象粘合在一起发挥作用，如果没有这个“粘合剂”，对象与对象之间会彼此失去联系，这就是有人把IOC容器比喻成“粘合剂”的由来。 控制反转名称的由来?对象A获得依赖对象B的过程,由主动行为变为了被动行为，控制权颠倒过来了，这就是“控制反转”这个名称的由来（对象的创建与生命周期的维护的控制权转移）。 实现方法 依赖注入 构造注入 属性注入 通过注解 依赖查找 Ioc容器Ioc容器： 控制反转中引入的第三方对象，通过Ioc容器将对象与对象的关系进行解耦，对象的创建与维护让渡给第三方容器。Ioc容器负责维护对象与对象之间的关系，并负责对象的创建和对象生命周期的维护。 依赖注入依赖注入就是将实例变量传入到一个对象中去 什么是依赖?在Class A 中，有 Class B的实例，则称Class A 对 Class B 有一个依赖。 例如:12345678public class Human &#123; ... Father father; ... public Human() &#123; father = new Father(); &#125;&#125; Notes: Human中用到一个Father对象，我们就说类Human对类Father有一个依赖。 控制反转和依赖注入的关系 控制反转是一种思想 依赖注入是一种设计模式 依赖倒置依赖倒置(Dependence Inversion Principle，缩写为DIP)，是一种设计原则，是指: 高层模块不应该依赖底层模块，都应该依赖于抽象 抽象不应该依赖于具体，具体依赖于抽象 原因: 若高层依赖于底层，那么底层的变动也会导致高层的变动，这就会导致模块的复用性降低而且大大提高了开发的成本。 若是依赖于抽象的话，那么是比较稳定的，底层或者高层的变动都不会互相影响 低层模块不可分割的原子逻辑，可能会根据业务逻辑经常变化。 高层模块低层模块的再组合，对低层模块的抽象。 抽象接口或抽象类（是底层模块的抽象，特点：不能直接被实例化） Autofac简介Autcofac 是一个开源的Ioc框架。 将Autofac整合到应用的基本模式如下: 按照 控制反转 (IoC) 的思想构建你的应用. 添加Autofac引用. 在应用的 startup 处… 创建 ContainerBuilder. 注册组件. 创建 容器 ,将其保存以备后续使用. 应用执行阶段… 从容器中创建一个生命周期. 在此生命周期作用域内解析组件实例. 注册组建和构建Ioc容器Autofac 通过ContainerBuilder来注册组建并构建Ioc容器。通过 ContainerBuilder对象的Build()方法构建Ioc容器。 组件和服务组件可以通过 反射 (注册指定的.NET类或开放结构的泛型)创建; 通过提供现成的实例(你已创建的一个对象实例)创建; 或者通过lambda 表达式 (一个执行实例化对象的匿名方法)来创建. 注册 组件 时, 我们得告诉Autofac, 组件暴露了哪些 服务， 默认地, 类型注册时大部分情况下暴露它们自身: 123456789101112131415161718192021222324// Create the builder with which components/services are registered.var builder = new ContainerBuilder();// Register types that expose interfaces...builder.RegisterType&lt;ConsoleLogger&gt;().As&lt;ILogger&gt;();// Register instances of objects you create...var output = new StringWriter();builder.RegisterInstance(output).As&lt;TextWriter&gt;();// Register expressions that execute to create objects...builder.Register(c =&gt; new ConfigReader("mysection")).As&lt;IConfigReader&gt;();// Build the container to finalize registrations// and prepare for object resolution.var container = builder.Build();// Now you can resolve services using Autofac. For example,// this line will execute the lambda expression registered// to the IConfigReader service.using(var scope = container.BeginLifetimeScope())&#123; var reader = scope.Resolve&lt;IConfigReader&gt;();&#125; 注册组件的方法反射组件 通过类型注册 指定构造函数 12builder.RegisterType&lt;MyComponent&gt;() .UsingConstructor(typeof(ILogger), typeof(IConfigReader)); 实例组件Lambda表达式组件1builder.Register(c =&gt; new A(c.Resolve&lt;B&gt;())); 表达式提供的参数 c 是 组件上下文 (一个 IComponentContext 对象) , 组件在其中被创建. 你可以使用这个参数来从容器中解析出其他值来帮助创建你的组件. 使用这个参数而不是一个闭包来访问容器非常重要 这样可以保证 对象精确的释放 并且可以很好的支持嵌套容器. 复杂参数 参数注入 通过参数值选择具体的实现12345678910111213builder.Register&lt;CreditCard&gt;( (c, p) =&gt; &#123; var accountId = p.Named&lt;string&gt;("accountId"); if (accountId.StartsWith("9")) &#123; return new GoldCard(accountId); &#125; else &#123; return new StandardCard(accountId); &#125; &#125;); 泛型注入 通过RegisterGeneric() 方法 123builder.RegisterGeneric(typeof(NHibernateRepository&lt;&gt;)) .As(typeof(IRepository&lt;&gt;)) .InstancePerLifetimeScope(); 解析服务在注册完组件并暴露相应的服务后, 你可以从创建的容器或其子 生命周期 中解析服务. 让我们使用 Resolve() 方法来实现: 12345678var builder = new ContainerBuilder();builder.RegisterType&lt;MyComponent&gt;().As&lt;IService&gt;();var container = builder.Build();using(var scope = container.BeginLifetimeScope())&#123; var service = scope.Resolve&lt;IService&gt;();&#125; Notes: 有时在我们的应用中也许可以从根容器中解析组件, 然而这么做有可能会导致 内存泄漏. 推荐你 总是从生命周期中解析组件, 以确保服务实例被妥善地释放和垃圾回收。 解析服务时, Autofac 自动链接起服务所需的整个依赖链上不同层级并解析所有的依赖来完整地构建服务. 如果你有处理不当的 循环依赖 或缺少了必需的依赖, 你将得到一个 DependencyResolutionException. 如果你不清楚一个服务是否被注册了, 你可以通过 ResolveOptional() 或 TryResolve() 尝试解析: 123456789101112// If IService is registered, it will be resolved; if// it isn't registered, the return value will be null.var service = scope.ResolveOptional&lt;IService&gt;();// If IProvider is registered, the provider variable// will hold the value; otherwise you can take some// other action.IProvider provider = null;if(scope.TryResolve&lt;IProvider&gt;(out provider))&#123; // Do something with the resolved provider value.&#125; 控制作用域和生命周期服务的生命周期服务的 生命周期 是指服务实例在你的应用中存在的时长 - 从开始实例化到最后 释放 结束 服务的作用域服务的 作用域 是指它在应用中能共享给其他组件并被消费的作用域。 在你的应用中你有个全局的静态单例 - 该全局对象实例的 “作用域” 将会是整个应用. 另一方面, 如果你在一个 for 循环中创建了引用了全局单例的一个局部变量 - 那么这个局部变量就拥有比全局变量小很多的作用域 生命周期作用域生命周期作用域等同于你应用中的一个工作单元. 一个工作单元将会在开始时启动生命周期作用域, 然后需要该工作单元的服务被从生命周期作用域中解析出. 当你解析服务时, Autofac将会追踪被解析的可释放/可销毁 (IDisposable) 组件. 在工作单元最后, 你释放了相关的生命周期作用域然后Autofac将会自动清理/释放那些被解析的服务.生命周期作用域等同于你应用中的一个工作单元. 一个工作单元将会在开始时启动生命周期作用域, 然后需要该工作单元的服务被从生命周期作用域中解析出. 当你解析服务时, Autofac将会追踪被解析的可释放/可销毁 (IDisposable) 组件. 在工作单元最后, 你释放了相关的生命周期作用域然后Autofac将会自动清理/释放那些被解析的服务. 在你的应用中, 最好记住以下概念这样就能有效使用你的资源: 永远从一个生命周期作用域而不是从根容器中解析服务. 由于生命周期作用域有追踪可释放资源的性质, 如果你从一个容器 (“根生命周期作用域”) 中解析了太多组件, 无意间也许你就会造成内存泄露. 根生命周期会在它存在的时间 (通常是应用的生命周期) 内保持住可释放组件因此它也能释放它们. 你可以选择性的改变释放行为, 但从作用域内解析是个良好的实践. 如果Autofac检测到使用单例或共享组件, 它会自动把它们安放在一个合适的追踪作用域之内 生命周期事件Autofac暴露了一些能在实例生命周期多个阶段拦截到的事件. 这些事件在组件注册时被订阅 (或者也可以通过附加到 IComponentRegistration 接口 激活时123builder.RegisterType&lt;TConcrete&gt;() // FAILS: will throw at cast of TInterfaceSubclass .As&lt;TInterface&gt;() // to type TConcrete .OnActivating(e =&gt; e.ReplaceInstance(new TInterfaceSubclass())); 激活后释放时注册Named命名和Key Service服务注册命名服务可以通过一个字符串名字要标示服务，这时我们用Named代替As： 1builder.Register&lt;OnlineState&gt;().Named&lt;IDeviceState&gt;("online"); 解析:1var r = container.ResolveNamed&lt;IDeviceState&gt;("online"); 注册Key Service服务假设存在设备状态枚举:1public enum DeviceState &#123; Online, Offline &#125; 枚举每一个值分别对应一个具体的实现类: 12public class OnlineState : IDeviceState &#123; &#125;public class OfflineState : IDeviceState &#123; &#125; 每一个枚举值对应的组件分别注册到容器中:123var builder = new ContainerBuilder();builder.RegisterType&lt;OnlineState&gt;().Keyed&lt;IDeviceState&gt;(DeviceState.Online);builder.RegisterType&lt;OfflineState&gt;().Keyed&lt;IDeviceState&gt;(DeviceState.Offline); 解析其中一种状态对应的组件：1var r = container.ResolveKeyed&lt;IDeviceState&gt;(DeviceState.Online);]]></content>
      <categories>
        <category>ioc容器</category>
      </categories>
      <tags>
        <tag>Ioc</tag>
        <tag>依赖注入</tag>
        <tag>开源组件</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Ocelot笔记]]></title>
    <url>%2Fhexo-blog-deploy%2F2018%2F09%2F26%2F2018-09-ocelot-note%2F</url>
    <content type="text"><![CDATA[简介Ocelot是一个用.NET Core实现并且开源的API网关，它功能强大，包括了：路由、请求聚合、服务发现、认证、鉴权、限流熔断、并内置了 负载均衡器 与 Service Fabric 、Butterfly Tracing 集成。 本质上,Ocelot是一堆的asp.net core middleware 组成的一个管道。当它拿到请求之后会用一个request builder来构造一个HttpRequestMessage发到下游的真实服务器，等下游的服务返回response之后再由一个middleware将它返回的HttpResponseMessage映射到HttpResponse上。 asp.net core中间件示意图 API网关API网关—— 它是系统的暴露在外部的一个访问入口。这个有点像代理访问，就像一个公司的门卫承担着寻址、限制进入、安全检查、位置引导、等等功能。 路由配置文件中的ReRoutes可以实现由上游到下游路由的转发。 上游路由API网关匹配到的请求路由地址。 下游路由API网关转发到真实服务主机的路由地址。 路由负载均衡当下游服务有多个结点的时候，我们可以在DownstreamHostAndPorts中进行配置: 1234567891011121314151617&#123; "DownstreamPathTemplate": "/api/posts/&#123;postId&#125;", "DownstreamScheme": "https", "DownstreamHostAndPorts": [ &#123; "Host": "10.0.1.10", "Port": 5000, &#125;, &#123; "Host": "10.0.1.11", "Port": 5000, &#125; ], "UpstreamPathTemplate": "/posts/&#123;postId&#125;", "LoadBalancer": "LeastConnection", "UpstreamHttpMethod": [ "Put", "Delete" ]&#125; 部署基本使用 与 IdentityServer 集成当我们涉及到认证和鉴权的时候，我们可以跟Identity Server进行结合。当网关需要请求认证信息的时候会与Identity Server服务器进行交互来完成 网关集群只有一个网关是很危险的，也就是我们通常所讲的单点，只要它挂了，所有的服务全挂。这显然无法达到高可用，所以我们也可以部署多台网关。 Consul服务发现在Ocelot已经支持简单的负载功能，也就是当下游服务存在多个结点的时候，Ocelot能够承担起负载均衡的作用。但是它不提供健康检查，服务的注册也只能通过手动在配置文件里面添加完成。这不够灵活并且在一定程度下会有风险。这个时候我们就可以用Consul来做服务发现，它能与Ocelot完美结合。 配置Ocelot有两个配置块。一个ReRoutes数组和一个GlobalConfiguration。 ReRoutes配置块是一些告诉Ocelot如何处理上游请求的对象 Globalconfiguration有些奇特，可以覆盖ReRoute节点的特殊设置。如果你不想管理大量的ReRoute特定的设置的话，这将很有用。 1234&#123; "ReRoutes": [], "GlobalConfiguration": &#123;&#125;&#125; ReRoutes路由配置例子 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849&#123; "DownstreamPathTemplate": "/", "UpstreamPathTemplate": "/", "UpstreamHttpMethod": [ "Get" ], "AddHeadersToRequest": &#123;&#125;, "AddClaimsToRequest": &#123;&#125;, "RouteClaimsRequirement": &#123;&#125;, "AddQueriesToRequest": &#123;&#125;, "RequestIdKey": "", "FileCacheOptions": &#123; "TtlSeconds": 0, "Region": "" &#125;, "ReRouteIsCaseSensitive": false, "ServiceName": "", "DownstreamScheme": "http", "DownstreamHostAndPorts": [ &#123; "Host": "localhost", "Port": 51876, &#125; ], "QoSOptions": &#123; "ExceptionsAllowedBeforeBreaking": 0, "DurationOfBreak": 0, "TimeoutValue": 0 &#125;, "LoadBalancer": "", "RateLimitOptions": &#123; "ClientWhitelist": [], "EnableRateLimiting": false, "Period": "", "PeriodTimespan": 0, "Limit": 0 &#125;, "AuthenticationOptions": &#123; "AuthenticationProviderKey": "", "AllowedScopes": [] &#125;, "HttpHandlerOptions": &#123; "AllowAutoRedirect": true, "UseCookieContainer": true, "UseTracing": true &#125;, "UseServiceDiscovery": false, "DangerousAcceptAnyServerCertificateValidator": false &#125; 请求聚合什么是聚合路由?把多个正常的ReRoutes打包并映射到一个对象来对客户端的请求进行响应。 比如，你请求订单信息，订单中又包含商品信息，这里就设计到两个微服务，一个是商品服务，一个是订单服务。如果不运用聚合路由的话，对于一个订单信息，客户端可能需要请求两次服务端。实际上这会造成服务端额外的开销。这时候有了聚合路由后，你只需要请求一次聚合路由，然后聚合路由会合并订单跟商品的结果都一个对象中，并把这个对象响应给客户端。使用Ocelot的此特性可以让你很容易的实现前后端分离的架构。 为了实现Ocelot的请求功能，你需要在ocelot.json中进行如下的配置。这里我们指定了了两个正常的ReRoutes,然后给每个ReRoute设置一个Key属性。最后我们再Aggregates节点中的ReRouteKeys属性中加入我们刚刚指定的两个Key从而组成了两个ReRoutes的聚合。当然我们还需要设置UpstreamPathTemplate匹配上游的用户请求，它的工作方式与正常的ReRoute类似。 Notes: 不要把Aggregates中UpstreamPathTemplate设置的跟ReRoutes中的UpstreamPathTemplate设置成一样 例如: 存在两个微服务: OrderApi 和 GoodApi 123456789101112131415161718192021222324252627282930313233//GoodApi项目中 [Route("api/[controller]")] [ApiController] public class GoodController : ControllerBase &#123; // GET api/Good/5 [HttpGet("&#123;id&#125;")] public ActionResult&lt;string&gt; Get(int id) &#123; var item = new Goods &#123; Id = id, Content = $"&#123;id&#125;的关联的商品明细", &#125;; return JsonConvert.SerializeObject(item); &#125; &#125; //OrderApi项目中 [Route("api/[controller]")] [ApiController] public class OrderController : ControllerBase &#123; // GET api/Order/5 [HttpGet("&#123;id&#125;")] public ActionResult&lt;string&gt; Get(int id) &#123; var item = new Orders &#123; Id=id, Content=$"&#123;id&#125;的订单明细", &#125;; return JsonConvert.SerializeObject(item); &#125; &#125; 分别在ocelot.good.json以及ocelot.order.json中新增一个路由，并给出Keys 123456789101112131415161718192021222324252627282930//ocelot.good.json&#123; "DownstreamPathTemplate": "/api/Good/&#123;id&#125;", "DownstreamScheme": "http", "DownstreamHostAndPorts": [ &#123; "Host": "localhost", "Port": 1001 &#125; ], "UpstreamPathTemplate": "/good/&#123;id&#125;", "UpstreamHttpMethod": [ "Get", "Post" ], "Key": "Good", "Priority": 2 &#125;//ocelot.order.json&#123; "DownstreamPathTemplate": "/api/Order/&#123;id&#125;", "DownstreamScheme": "http", "DownstreamHostAndPorts": [ &#123; "Host": "localhost", "Port": 1002 &#125; ], "UpstreamPathTemplate": "/order/&#123;id&#125;", "UpstreamHttpMethod": [ "Get", "Post" ], "Key": "Order", "Priority": 2&#125; 在ocelot.all.json中加入聚合配置 123456789"Aggregates": [ &#123; "ReRouteKeys": [ "Good", "Order" ], "UpstreamPathTemplate": "/GetOrderDetail/&#123;id&#125;" &#125; ] Notes: 这里Aggregates跟ReRoutes同级，ReRouteKeys中填写的数组就是上面步骤3中设置的Key属性对应的值。 客户端请求接口地址 http://localhost:1000/GetOrderDetail/1 叫得到如下响应 12345678910&#123; "Good":&#123; "Id":1, "Content":"1的关联的商品明细" &#125;, "Order":&#123; "Id":1, "Content":"1的订单明细" &#125;&#125; 服务发现Ocelot允许您指定服务发现提供程序，并将使用它来查找Ocelot将请求转发到的下游服务的主机和端口。目前，这仅在GlobalConfiguration部分中受支持，这意味着相同的服务发现提供程序将用于为ReRoute级别指定ServiceName的所有ReRoutes。 使用步骤 安装Consul支持包 1Install-Package Ocelot.Provider.Consul 在startup类中的ConfigureServices方法中增加 12services.AddOcelot()//注入Ocelot服务 .AddConsul(); GlobalConfiguration中需要加入以下内容。如果您未指定主机和端口，则将使用Consul默认值。 12345"ServiceDiscoveryProvider": &#123; "Host": "localhost", "Port": 8500, "Type": "Consul"&#125;]]></content>
      <categories>
        <category>微服务</category>
      </categories>
      <tags>
        <tag>微服务</tag>
        <tag>网关</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[consul笔记]]></title>
    <url>%2Fhexo-blog-deploy%2F2018%2F09%2F24%2F2018-09-consul%2F</url>
    <content type="text"><![CDATA[Consul简介consul介绍consul 是Google开源的，使用go语言开发的一个服务发现、配置管理服务的一个工具。内置了 服务注册与发现框架、分布一致性协议实现、健康检查、Key/Value存储、多数据中心方案，不再需要依赖其他工具（比如ZooKeeper等）。服务部署简单，只有一个可运行的二进制的包。 几个关键的功能介绍(作用): 服务发现: Consul的某些客户端可以提供一个服务，例如api或者mysql，其它客户端可以使用Consul去发现这个服务的提供者。使用DNS或者HTTP，应用可以很容易的找到他们所依赖的服务。 健康检查: Consul客户端可以提供一些健康检查，这些健康检查可以关联到一个指定的服务（服务是否返回200 OK），也可以关联到本地节点（内存使用率是否在90%以下）。这些信息可以被一个操作员用来监控集群的健康状态，被服务发现组件路由时用来远离不健康的主机。 健值(Key/Value)存储: 应用可以使用Consul提供的分层键值存储用于一些目的，包括 动态配置 、特征标记、协作、leader选举等等。通过一个简单的HTTP API可以很容易的使用这个组件。 多数据中心: Consul对多数据中心有非常好的支持，这意味着Consul用户不必担心由于创建更多抽象层而产生的多个区域。 基础架构每个节点都需要运行agent，他有两种运行模式server和client。每个数据中心官方建议需要3或5个server节点以保证数据安全，同时保证server-leader的选举能够正确的进行。 @clientCLIENT表示consul的client模式，就是客户端模式。是consul节点的一种模式，这种模式下，所有注册到当前节点的服务会被转发到SERVER，本身是不持久化这些信息。 @serverSERVER表示consul的server模式，表明这个consul是个server，这种模式下，功能和CLIENT都一样，唯一不同的是，它会把所有的信息持久化的本地，这样遇到故障，信息是可以被保留的 @server-leader中间那个SERVER下面有LEADER的字眼，表明这个SERVER是它们的老大，它和其它SERVER不一样的一点是，它需要负责同步注册的信息给其它的SERVER，同时也要负责各个节点的健康监测。 @raftserver节点之间的数据一致性保证，一致性协议使用的是raft协议。 安装1.通过choco工具安装1choco install -y consul 2. 官方安装从官方下载 对应系统的zip包,解压到安装目录，并将安装目录的路径添加到环境变量PATH中。 启动完成consul安装之后必须运行agent,agent 可以运行server或client模式。每个数据中心至少必须拥有一台server， 建议在一个集群中有3或者5个server.部署单一的server,在出现失败时会不可避免的造成数据丢失。 运行Consul Server1consul agent -server -bootstrap-expect 3 -data-dir /tmp/consul -node=s1 -bind 192.168.31.115 -ui-dir ./consul_ui/ -rejoin -config-dir=/etc/consul.d/ -client 0.0.0.0 -server1： 定义agent运行在server模式 -bootstrap-expect ：在一个datacenter中期望提供的server节点数目，当该值提供的时候，consul一直等到达到指定sever数目的时候才会引导整个集群，该标记不能和bootstrap共用 -bind：该地址用来在集群内部的通讯，集群内的所有节点到地址都必须是可达的，默认是0.0.0.0 -node：节点在集群中的名称，在一个集群中必须是唯一的，默认是该节点的主机名 -ui-dir： 提供存放web ui资源的路径，该目录必须是可读的 -rejoin：使consul忽略先前的离开，在再次启动后仍旧尝试加入集群中。 -config-dir：：配置文件目录，里面所有以.json结尾的文件都会被加载 -client：consul服务侦听地址，这个地址提供HTTP、DNS、RPC等服务，默认是127.0.0.1所以不对外提供服务，如果你要对外提供服务改成0.0.0.0 -ui： 使用默认的ui管理界面 运行Consul Client1consul agent -data-dir /tmp/consul -node=c1 -bind=192.168.31.23 -config-dir=/etc/consul.d/ -join 192.168.31.115 查看集群成员1consul members 加入集群1consul join 192.168.31.115 停止agent你可以使用Ctrl-C 优雅的关闭Agent. 中断Agent之后你可以看到他离开了集群并关闭. 开发模式开发过程中只需要简单的运行一个consul Agent即可,可通过如下命令实现:1consul agent --dev 服务注册与发现服务注册consul支持两种方式实现服务注册，一种是通过consul的服务注册http API，由服务自己调用API实现注册，另一种方式是通过json个是的配置文件实现注册，将需要注册的服务以json格式的配置文件给出。consul官方建议使用第二种方式。 通过Http API注册1/v1/agent/service/register -PUT 通过配置文件注册文件 将注册的服务写到 consul配置目录下 1echo '&#123;"service": &#123;"name": "web", "tags": ["rails"], "port": 80&#125;&#125;' &gt;/etc/consul.d/web.json 启动consul服务时,指定配置目录 1-config-dir=/etc/consul.d/ 服务发现consul支持两种方式实现服务发现，一种是通过http API来查询有哪些服务，另外一种是通过consul agent 自带的DNS（8600端口），域名是以NAME.service.consul的形式给出，NAME即在定义的服务配置文件中服务的名称。DNS方式可以通过check的方式检查服务。 例如: 已经向consul集群中注册了一个服务名为Web的服务，那么他的域名是web.service.consul： 1dig @127.0.0.1 -p 8600 web.service.consul Http API 查询制定服务 1curl 127.0.0.1:8500/v1/catalog/service/web 通过目录API给出所有节点提供的服务 1curl 127.0.0.1:8500/v1/catalog/service/web?passing DNS APIDNS API中,服务的DNS名字是 NAME.service.consul. 虽然是可配置的,但默认的所有DNS名字会都在consul命名空间下.这个子域告诉Consul,我们在查询服务,NAME则是服务的名称。 健康检查健康检查是服务发现的关键组件.预防使用到不健康的服务 自定义检查使用和检查定义来注册检查，和服务类似,因为这是建立检查最常用的方式 通过配置服务下的check节点自定义检查:123456789101112&#123;"service": &#123; "name": "Faceid", "tags": ["extract", "verify", "compare", "idcard"], "address": "10.201.102.198", "port": 9000, "check": &#123; "name": "ping", "script": "curl -s localhost:9000", "interval": "3s" &#125; &#125;&#125; K/VConsul提供了一个易用的键/值存储,这可以用来 保持动态配置 ,协助服务协调,领袖选举,做开发者可以想到的任何事情可以通过Http API v1/kv/?{key}来获取设置获取KEY/VALUE的存储与设置 常用命令概述consul只有一个命令行应用，就是consul命令，consul命令可以包含agent、members等参数进行使用,consul -h即可看到consul cli所支持的参数，而每个参数里面又支持其他参数。 123456789101112131415161718192021222324[root@consul ~]# consulusage: consul [--version] [--help] &lt;command&gt; [&lt;args&gt;]Available commands are: agent Runs a Consul agent 运行一个consul agent configtest Validate config file event Fire a new event exec Executes a command on Consul nodes 在consul节点上执行一个命令 force-leave Forces a member of the cluster to enter the "left" state 强制节点成员在集群中的状态转换到left状态 info Provides debugging information for operators 提供操作的debug级别的信息 join Tell Consul agent to join cluster 加入consul节点到集群中 keygen Generates a new encryption key 生成一个新的加密key keyring Manages gossip layer encryption keys kv Interact with the key-value store leave Gracefully leaves the Consul cluster and shuts down lock Execute a command holding a lock maint Controls node or service maintenance mode members Lists the members of a Consul cluster 列出集群中成员 monitor Stream logs from a Consul agent 打印consul节点的日志信息 operator Provides cluster-level tools for Consul operators reload Triggers the agent to reload configuration files 触发节点重新加载配置文件 rtt Estimates network round trip time between nodes snapshot Saves, restores and inspects snapshots of Consul server state version Prints the Consul version 打印consul的版本信息 watch Watch for changes in Consul 监控consul的改变 Agentagent指令是consul的核心，它运行agent来维护成员的重要信息、运行检查、服务宣布、查询处理等等 eventevent命令提供了一种机制，用来fire自定义的用户事件，这些事件对consul来说是不透明的，但它们可以用来构建自动部署、重启服务或者其他行动的脚本。 123456-http-addr：http服务的地址，agent可以链接上来发送命令，如果没有设置，则默认是127.0.0.1:8500。-datacenter：数据中心。-name：事件的名称-node：一个正则表达式，用来过滤节点-service：一个正则表达式，用来过滤节点上匹配的服务-tag：一个正则表达式，用来过滤节点上符合tag的服务，必须和-service一起使用。 execexec指令提供了一种远程执行机制，比如你要在所有的机器上执行uptime命令，远程执行的工作通过job来指定，存储在KV中，agent使用event系统可以快速的知道有新的job产生，消息是通过gossip协议来传递的，因此消息传递是最佳的，但是并不保证命令的执行。事件通过gossip来驱动，远程执行依赖KV存储系统(就像消息代理一样)。 123456789-http-addr：http服务的地址，agent可以链接上来发送命令，如果没有设置，则默认是127.0.0.1:8500。-datacenter：数据中心。-prefix：key在KV系统中的前缀，用来存储请求数据，默认是_rexec-node：一个正则表达式，用来过滤节点，评估事件-service：一个正则表达式，用来过滤节点上匹配的服务-tag：一个正则表达式，用来过滤节点上符合tag的服务，必须和-service一起使用。-wait：在节点多长时间没有响应后，认为job已经完成。-wait-repl：-verbose：输出更多信息 joinjoin指令告诉consul agent加入一个已经存在的集群中，一个新的consul agent必须加入一个已经有至少一个成员的集群中，这样它才能加入已经存在的集群中，如果你不加入一个已经存在的集群，则agent是它自身集群的一部分，其他agent则可以加入进来。agents可以加入其他agent多次。consul join [options] address。如果你想加入多个集群，则可以写多个地址，consul会加入所有的地址。 leaveleave指令触发一个优雅的离开动作并关闭agent，节点离开后不会尝试重新加入集群中。运行在server状态的节点，节点会被优雅的删除，这是很严重的，在某些情况下一个不优雅的离开会影响到集群的可用性。 membersmembers指令输出consul agent目前所知道的所有的成员以及它们的状态，节点的状态只有alive、left、failed三种状态。 monitormonitor指令用来链接运行的agent，并显示日志。monitor会显示最近的日志，并持续的显示日志流，不会自动退出，除非你手动或者远程agent自己退出。 reloadreload指令可以重新加载agent的配置文件。SIGHUP指令在重新加载配置文件时使用，任何重新加载的错误都会写在agent的log文件中，并不会打印到屏幕。 watchwatch指令提供了一个机制，用来监视实际数据视图的改变(节点列表、成员服务、KV)，如果没有指定进程，当前值会被dump出来 Consul 配置agent有各种各样的配置项可以在命令行或者配置文件进行定义，所有的配置项都是可选择的，当加载配置文件的时候，consul从配置文件或者配置目录加载配置。后面定义的配置会合并前面定义的配置，但是大多数情况下，合并的意思是后面定义的配置会覆盖前面定义的配置。 详细的配置文件参数12345678910111213141516171819202122232425262728293031323334353637383940414243444546acl_datacenter：只用于server，指定的datacenter的权威ACL信息，所有的servers和datacenter必须同意ACL datacenteracl_default_policy：默认是allowacl_down_policy：acl_master_token：acl_token：agent会使用这个token和consul server进行请求acl_ttl：控制TTL的cache，默认是30saddresses：一个嵌套对象，可以设置以下key：dns、http、rpcadvertise_addr：等同于-advertisebootstrap：等同于-bootstrapbootstrap_expect：等同于-bootstrap-expectbind_addr：等同于-bindca_file：提供CA文件路径，用来检查客户端或者服务端的链接cert_file：必须和key_file一起check_update_interval：client_addr：等同于-clientdatacenter：等同于-dcdata_dir：等同于-data-dirdisable_anonymous_signature：在进行更新检查时禁止匿名签名disable_remote_exec：禁止支持远程执行，设置为true，agent会忽视所有进入的远程执行请求disable_update_check：禁止自动检查安全公告和新版本信息dns_config：是一个嵌套对象，可以设置以下参数：allow_stale、max_stale、node_ttl 、service_ttl、enable_truncatedomain：默认情况下consul在进行DNS查询时，查询的是consul域，可以通过该参数进行修改enable_debug：开启debug模式enable_syslog：等同于-syslogencrypt：等同于-encryptkey_file：提供私钥的路径leave_on_terminate：默认是false，如果为true，当agent收到一个TERM信号的时候，它会发送leave信息到集群中的其他节点上。log_level：等同于-log-levelnode_name:等同于-nodeports：这是一个嵌套对象，可以设置以下key：dns(dns地址：8600)、http(http api地址：8500)、rpc(rpc:8400)、serf_lan(lan port:8301)、serf_wan(wan port:8302)、server(server rpc:8300)protocol：等同于-protocolrecursor：rejoin_after_leave：等同于-rejoinretry_join：等同于-retry-joinretry_interval：等同于-retry-intervalserver：等同于-serverserver_name：会覆盖TLS CA的node_name，可以用来确认CA name和hostname相匹配skip_leave_on_interrupt：和leave_on_terminate比较类似，不过只影响当前句柄start_join：一个字符数组提供的节点地址会在启动时被加入statsd_addr：statsite_addr：syslog_facility：当enable_syslog被提供后，该参数控制哪个级别的信息被发送，默认Local0ui_dir：等同于-ui-dirverify_incoming：默认false，如果为true，则所有进入链接都需要使用TLS，需要客户端使用ca_file提供ca文件，只用于consul server端，因为client从来没有进入的链接verify_outgoing：默认false，如果为true，则所有出去链接都需要使用TLS，需要服务端使用ca_file提供ca文件，consul server和client都需要使用，因为两者都有出去的链接watches：watch一个详细名单 常用APIconsul的主要接口是RESTful HTTP API，该API可以用来增删查改nodes、services、checks、configguration。所有的endpoints主要分为以下类别:12345678kv - Key/Value存储agent - Agent控制catalog - 管理nodes和serviceshealth - 管理健康监测session - Session操作acl - ACL创建和管理event - 用户Eventsstatus - Consul系统状态 agentagent endpoints用来和本地agent进行交互，一般用来服务注册和检查注册，支持以下接口 12345678910111213/v1/agent/checks : 返回本地agent注册的所有检查(包括配置文件和HTTP接口)/v1/agent/services : 返回本地agent注册的所有 服务/v1/agent/members : 返回agent在集群的gossip pool中看到的成员/v1/agent/self : 返回本地agent的配置和成员信息/v1/agent/join/&lt;address&gt; : 触发本地agent加入node/v1/agent/force-leave/&lt;node&gt;&gt;: 强制删除node/v1/agent/check/register : 在本地agent增加一个检查项，使用PUT方法传输一个json格式的数据/v1/agent/check/deregister/&lt;checkID&gt; : 注销一个本地agent的检查项/v1/agent/check/pass/&lt;checkID&gt; : 设置一个本地检查项的状态为passing/v1/agent/check/warn/&lt;checkID&gt; : 设置一个本地检查项的状态为warning/v1/agent/check/fail/&lt;checkID&gt; : 设置一个本地检查项的状态为critical/v1/agent/service/register : 在本地agent增加一个新的服务项，使用PUT方法传输一个json格式的数据/v1/agent/service/deregister/&lt;serviceID&gt; : 注销一个本地agent的服务项 catalogcatalog endpoints用来注册/注销nodes、services、checks 1234567/v1/catalog/register : Registers a new node, service, or check/v1/catalog/deregister : Deregisters a node, service, or check/v1/catalog/datacenters : Lists known datacenters/v1/catalog/nodes : Lists nodes in a given DC/v1/catalog/services : Lists services in a given DC/v1/catalog/service/&lt;service&gt; : Lists the nodes in a given service/v1/catalog/node/&lt;node&gt; : Lists the services provided by a node healthhealth endpoints用来查询健康状况相关信息，该功能从catalog中单独分离出来1234/v1/healt/node/&lt;node&gt;: 返回node所定义的检查，可用参数?dc=/v1/health/checks/&lt;service&gt;: 返回和服务相关联的检查，可用参数?dc=/v1/health/service/&lt;service&gt;: 返回给定datacenter中给定node中service/v1/health/state/&lt;state&gt;: 返回给定datacenter中指定状态的服务，state可以是"any", "unknown", "passing", "warning", or "critical"，可用参数?dc= sessionsession endpoints用来create、update、destory、query sessions12345/v1/session/create: Creates a new session/v1/session/destroy/&lt;session&gt;: Destroys a given session/v1/session/info/&lt;session&gt;: Queries a given session/v1/session/node/&lt;node&gt;: Lists sessions belonging to a node/v1/session/list: Lists all the active sessions aclacl endpoints用来create、update、destory、query acl123456/v1/acl/create: Creates a new token with policy/v1/acl/update: Update the policy of a token/v1/acl/destroy/&lt;id&gt;: Destroys a given token/v1/acl/info/&lt;id&gt;: Queries the policy of a given token/v1/acl/clone/&lt;id&gt;: Creates a new token by cloning an existing token/v1/acl/list: Lists all the active tokens eventevent endpoints用来fire新的events、查询已有的events12/v1/event/fire/&lt;name&gt;: 触发一个新的event，用户event需要name和其他可选的参数，使用PUT方法/v1/event/list: 返回agent知道的events statusstatus endpoints用来或者consul 集群的信息12/v1/status/leader : 返回当前集群的Raft leader/v1/status/peers : 返回当前集群中同事 高可用Consul Cluster集群架构图如下: 为保证consul集群服务的可靠性,一般需要配置3~5个server, client集群可以配置n个(n&gt;=0),当server-leader问题,其他server会重新选举server-leader,从而保证集群的可靠性。 参考资料 Consul服务手册 Consul官方文档 Consul中文翻译]]></content>
      <categories>
        <category>微服务</category>
      </categories>
      <tags>
        <tag>微服务</tag>
        <tag>分布式系统</tag>
        <tag>服务发现</tag>
      </tags>
  </entry>
</search>
